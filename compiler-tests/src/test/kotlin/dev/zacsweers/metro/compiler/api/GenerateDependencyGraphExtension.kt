// Copyright (C) 2025 Zac Sweers
// SPDX-License-Identifier: Apache-2.0
package dev.zacsweers.metro.compiler.api

import dev.zacsweers.metro.compiler.MetroOptions
import dev.zacsweers.metro.compiler.api.fir.MetroFirDeclarationGenerationExtension
import org.jetbrains.kotlin.GeneratedDeclarationKey
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.descriptors.Visibilities
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.FirResolvePhase
import org.jetbrains.kotlin.fir.declarations.builder.buildRegularClass
import org.jetbrains.kotlin.fir.declarations.impl.FirResolvedDeclarationStatusImpl
import org.jetbrains.kotlin.fir.declarations.origin
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotation
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationArgumentMapping
import org.jetbrains.kotlin.fir.expressions.builder.buildArgumentList
import org.jetbrains.kotlin.fir.expressions.builder.buildGetClassCall
import org.jetbrains.kotlin.fir.expressions.builder.buildResolvedQualifier
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.MemberGenerationContext
import org.jetbrains.kotlin.fir.extensions.NestedClassGenerationContext
import org.jetbrains.kotlin.fir.extensions.predicate.LookupPredicate
import org.jetbrains.kotlin.fir.extensions.predicateBasedProvider
import org.jetbrains.kotlin.fir.moduleData
import org.jetbrains.kotlin.fir.plugin.createMemberFunction
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.scopes.kotlinScopeProvider
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.toEffectiveVisibility
import org.jetbrains.kotlin.fir.types.ConeKotlinType
import org.jetbrains.kotlin.fir.types.FirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.builder.buildResolvedTypeRef
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.fir.types.toLookupTag
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.StandardClassIds

private val DEPENDENCY_GRAPH_CLASS_ID =
  ClassId(FqName("dev.zacsweers.metro"), Name.identifier("DependencyGraph"))
private val DEPENDENCY_GRAPH_FACTORY_CLASS_ID =
  DEPENDENCY_GRAPH_CLASS_ID.createNestedClassId(Name.identifier("Factory"))
private val PROVIDES_CLASS_ID = ClassId(FqName("dev.zacsweers.metro"), Name.identifier("Provides"))

private val APP_GRAPH_NAME = Name.identifier("AppGraph")
private val FACTORY_NAME = Name.identifier("Factory")
private val CREATE_NAME = Name.identifier("create")

/**
 * Test extension that generates a `@DependencyGraph(AppScope::class)` interface with a
 * `@DependencyGraph.Factory` for classes annotated with `@GenerateGraphFactory`.
 *
 * For a class like:
 * ```
 * @GenerateGraphFactory
 * class Application
 * ```
 *
 * This generates a nested interface:
 * ```
 * class Application {
 *   @DependencyGraph(AppScope::class)
 *   interface AppGraph {
 *     @DependencyGraph.Factory
 *     fun interface Factory {
 *       fun create(@Provides text: String): AppGraph
 *     }
 *   }
 * }
 * ```
 *
 * This exercises the fix in `DependencyGraphFirGenerator.findCreator` that falls back to
 * scope-based lookup for classifiers generated by external FIR extensions (which are visible in
 * scope but not in `declarationSymbols`).
 */
internal class GenerateDependencyGraphExtension(session: FirSession) :
  MetroFirDeclarationGenerationExtension(session) {

  companion object {
    val ANNOTATION_FQ_NAME = FqName("test.GenerateGraphFactory")
  }

  object Key : GeneratedDeclarationKey()

  private val predicate = LookupPredicate.BuilderContext.annotated(ANNOTATION_FQ_NAME)

  private val annotatedClasses by lazy {
    session.predicateBasedProvider
      .getSymbolsByPredicate(predicate)
      .filterIsInstance<FirRegularClassSymbol>()
      .toList()
  }

  /** ClassIds of AppGraph interfaces we generate (nested inside annotated classes). */
  private val generatedGraphClassIds by lazy {
    annotatedClasses.map { it.classId.createNestedClassId(APP_GRAPH_NAME) }.toSet()
  }

  /** ClassIds of Factory interfaces nested inside generated graphs. */
  private val generatedFactoryClassIds by lazy {
    generatedGraphClassIds.map { it.createNestedClassId(FACTORY_NAME) }.toSet()
  }

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(predicate)
  }

  // -- AppGraph generation (nested inside annotated class) --

  override fun getNestedClassifiersNames(
    classSymbol: FirClassSymbol<*>,
    context: NestedClassGenerationContext,
  ): Set<Name> {
    // Generate AppGraph inside annotated classes
    if (classSymbol in annotatedClasses) return setOf(APP_GRAPH_NAME)
    // Generate Factory inside generated AppGraph
    if (classSymbol.classId in generatedGraphClassIds) return setOf(FACTORY_NAME)
    return emptySet()
  }

  override fun generateNestedClassLikeDeclaration(
    owner: FirClassSymbol<*>,
    name: Name,
    context: NestedClassGenerationContext,
  ): FirClassLikeSymbol<*>? {
    return when (name) {
      APP_GRAPH_NAME -> generateAppGraph(owner, name)
      FACTORY_NAME -> generateFactory(owner, name)
      else -> null
    }
  }

  private fun generateAppGraph(owner: FirClassSymbol<*>, name: Name): FirClassLikeSymbol<*>? {
    if (owner !in annotatedClasses) return null

    val nestedClassId = owner.classId.createNestedClassId(name)
    val classSymbol = FirRegularClassSymbol(nestedClassId)

    buildRegularClass {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = Key.origin
      source = owner.source
      classKind = ClassKind.INTERFACE
      scopeProvider = session.kotlinScopeProvider
      this.name = nestedClassId.shortClassName
      symbol = classSymbol
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.ABSTRACT,
          Visibilities.Public.toEffectiveVisibility(owner, forClass = true),
        )
      superTypeRefs += session.builtinTypes.anyType
      annotations += buildDependencyGraphAnnotation(APP_SCOPE_CLASS_ID)
    }

    return classSymbol
  }

  private fun generateFactory(owner: FirClassSymbol<*>, name: Name): FirClassLikeSymbol<*>? {
    if (owner.classId !in generatedGraphClassIds) return null

    val nestedClassId = owner.classId.createNestedClassId(name)
    val classSymbol = FirRegularClassSymbol(nestedClassId)

    buildRegularClass {
      resolvePhase = FirResolvePhase.BODY_RESOLVE
      moduleData = session.moduleData
      origin = Key.origin
      source = owner.source
      classKind = ClassKind.INTERFACE
      scopeProvider = session.kotlinScopeProvider
      this.name = nestedClassId.shortClassName
      symbol = classSymbol
      status =
        FirResolvedDeclarationStatusImpl(
          Visibilities.Public,
          Modality.ABSTRACT,
          Visibilities.Public.toEffectiveVisibility(owner, forClass = true),
        )
      superTypeRefs += session.builtinTypes.anyType
      annotations += buildDependencyGraphFactoryAnnotation()
    }

    return classSymbol
  }

  // -- Factory SAM function generation --

  override fun getCallableNamesForClass(
    classSymbol: FirClassSymbol<*>,
    context: MemberGenerationContext,
  ): Set<Name> {
    if (classSymbol.classId in generatedFactoryClassIds) return setOf(CREATE_NAME)
    return emptySet()
  }

  override fun generateFunctions(
    callableId: CallableId,
    context: MemberGenerationContext?,
  ): List<FirNamedFunctionSymbol> {
    if (context == null) return emptyList()
    val owner = context.owner
    if (owner.classId !in generatedFactoryClassIds) return emptyList()
    if (callableId.callableName != CREATE_NAME) return emptyList()

    // The graph class is the parent of this Factory
    val graphClassId = owner.classId.parentClassId ?: return emptyList()
    val graphSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(graphClassId) as? FirRegularClassSymbol
        ?: return emptyList()
    val graphType = graphSymbol.defaultType()

    // String type for the @Provides parameter
    val stringSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(StandardClassIds.String)
        as FirRegularClassSymbol
    val stringType = stringSymbol.defaultType()

    // Create: fun create(@Provides text: String): GraphType
    val createFunction =
      createMemberFunction(owner, Key, CREATE_NAME, graphType) {
        valueParameter(Name.identifier("text"), stringType, key = Key)
      }

    // Set ABSTRACT modality (createMemberFunction may default to a different modality)
    createFunction.replaceStatus(
      FirResolvedDeclarationStatusImpl(
        Visibilities.Public,
        Modality.ABSTRACT,
        Visibilities.Public.toEffectiveVisibility(owner, forClass = true),
      )
    )

    // Add @Provides annotation to the text parameter
    createFunction.valueParameters[0].replaceAnnotations(listOf(buildProvidesAnnotation()))

    return listOf(createFunction.symbol)
  }

  // -- Annotation builders --

  private fun buildDependencyGraphAnnotation(scopeClassId: ClassId): FirAnnotation {
    val annotationClassSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(DEPENDENCY_GRAPH_CLASS_ID)
        as FirRegularClassSymbol
    val scopeSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(scopeClassId) as FirRegularClassSymbol
    val scopeType = scopeSymbol.defaultType()

    return buildAnnotation {
      annotationTypeRef = annotationClassSymbol.defaultType().toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping {
        mapping[Name.identifier("scope")] = buildGetClassCall {
          argumentList = buildArgumentList {
            arguments += buildResolvedQualifier {
              packageFqName = scopeClassId.packageFqName
              relativeClassFqName = scopeClassId.relativeClassName
              symbol = scopeSymbol
              resolvedToCompanionObject = false
              isFullyQualified = true
              coneTypeOrNull = scopeType
            }
          }
          coneTypeOrNull =
            ConeClassLikeTypeImpl(
              StandardClassIds.KClass.toLookupTag(),
              arrayOf(scopeType),
              isMarkedNullable = false,
            )
        }
      }
    }
  }

  private fun buildDependencyGraphFactoryAnnotation(): FirAnnotation {
    val annotationClassSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(DEPENDENCY_GRAPH_FACTORY_CLASS_ID)
        as FirRegularClassSymbol
    return buildAnnotation {
      annotationTypeRef = annotationClassSymbol.defaultType().toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping()
    }
  }

  private fun buildProvidesAnnotation(): FirAnnotation {
    val annotationClassSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(PROVIDES_CLASS_ID) as FirRegularClassSymbol
    return buildAnnotation {
      annotationTypeRef = annotationClassSymbol.defaultType().toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping()
    }
  }

  private fun ConeKotlinType.toFirResolvedTypeRef(): FirResolvedTypeRef {
    return buildResolvedTypeRef { coneType = this@toFirResolvedTypeRef }
  }

  class Factory : MetroFirDeclarationGenerationExtension.Factory {
    override fun create(
      session: FirSession,
      options: MetroOptions,
    ): MetroFirDeclarationGenerationExtension = GenerateDependencyGraphExtension(session)
  }
}
