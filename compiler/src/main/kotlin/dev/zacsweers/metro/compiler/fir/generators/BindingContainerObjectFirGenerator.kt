// Copyright (C) 2025 Zac Sweers
// SPDX-License-Identifier: Apache-2.0
package dev.zacsweers.metro.compiler.fir.generators

import dev.zacsweers.metro.compiler.asName
import dev.zacsweers.metro.compiler.compat.CompatContext
import dev.zacsweers.metro.compiler.fir.Keys
import dev.zacsweers.metro.compiler.fir.argumentAsOrNull
import dev.zacsweers.metro.compiler.fir.buildSimpleAnnotation
import dev.zacsweers.metro.compiler.fir.classIds
import dev.zacsweers.metro.compiler.fir.hasOrigin
import dev.zacsweers.metro.compiler.fir.isAnnotatedWithAny
import dev.zacsweers.metro.compiler.fir.isResolved
import dev.zacsweers.metro.compiler.fir.markAsDeprecatedHidden
import dev.zacsweers.metro.compiler.fir.metroFirBuiltIns
import dev.zacsweers.metro.compiler.fir.predicates
import dev.zacsweers.metro.compiler.fir.replaceAnnotationsSafe
import dev.zacsweers.metro.compiler.fir.resolvedClassId
import dev.zacsweers.metro.compiler.symbols.Symbols
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.descriptors.ClassKind
import org.jetbrains.kotlin.descriptors.Modality
import org.jetbrains.kotlin.fir.FirSession
import org.jetbrains.kotlin.fir.declarations.DirectDeclarationsAccess
import org.jetbrains.kotlin.fir.declarations.toAnnotationClassIdSafe
import org.jetbrains.kotlin.fir.declarations.utils.isAbstract
import org.jetbrains.kotlin.fir.expressions.FirAnnotation
import org.jetbrains.kotlin.fir.expressions.FirCall
import org.jetbrains.kotlin.fir.expressions.FirExpression
import org.jetbrains.kotlin.fir.expressions.FirGetClassCall
import org.jetbrains.kotlin.fir.expressions.FirQualifiedAccessExpression
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotation
import org.jetbrains.kotlin.fir.expressions.builder.buildAnnotationArgumentMapping
import org.jetbrains.kotlin.fir.expressions.builder.buildArgumentList
import org.jetbrains.kotlin.fir.expressions.builder.buildGetClassCall
import org.jetbrains.kotlin.fir.expressions.builder.buildResolvedQualifier
import org.jetbrains.kotlin.fir.extensions.FirDeclarationGenerationExtension
import org.jetbrains.kotlin.fir.extensions.FirDeclarationPredicateRegistrar
import org.jetbrains.kotlin.fir.extensions.MemberGenerationContext
import org.jetbrains.kotlin.fir.extensions.NestedClassGenerationContext
import org.jetbrains.kotlin.fir.plugin.createDefaultPrivateConstructor
import org.jetbrains.kotlin.fir.plugin.createNestedClass
import org.jetbrains.kotlin.fir.references.FirNamedReference
import org.jetbrains.kotlin.fir.resolve.defaultType
import org.jetbrains.kotlin.fir.resolve.providers.symbolProvider
import org.jetbrains.kotlin.fir.resolve.substitution.substitutorByMap
import org.jetbrains.kotlin.fir.symbols.impl.FirClassLikeSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirClassSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirConstructorSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirNamedFunctionSymbol
import org.jetbrains.kotlin.fir.symbols.impl.FirRegularClassSymbol
import org.jetbrains.kotlin.fir.toFirResolvedTypeRef
import org.jetbrains.kotlin.fir.types.impl.ConeClassLikeTypeImpl
import org.jetbrains.kotlin.fir.types.toLookupTag
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.ClassId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name
import org.jetbrains.kotlin.name.SpecialNames
import org.jetbrains.kotlin.name.StandardClassIds

/**
 * Generates nested binding container objects for classes annotated with
 * `@ContributesTemplate`-annotated custom annotations.
 *
 * For example, given:
 * ```kotlin
 * @ContributesTemplate.Template
 * object MyTemplate {
 *   @Provides @IntoSet fun <T : Any> provideIntoSet(target: T): Any = target
 * }
 *
 * @ContributesTemplate(template = MyTemplate::class)
 * annotation class CustomAnnotation(val scope: KClass<*>, val replaces: Array<KClass<*>> = [])
 *
 * @CustomAnnotation(AppScope::class)
 * @Inject
 * class TargetClass
 * ```
 *
 * This generates a nested class inside TargetClass:
 * ```kotlin
 * class TargetClass @Inject constructor() {
 *   @ContributesTo(AppScope::class)
 *   @BindingContainer
 *   @Origin(TargetClass::class)
 *   object MetroBindingContainerForCustomAnnotation {
 *     @Provides @IntoSet fun provideIntoSet(target: TargetClass): Any =
 *       MyTemplate.provideIntoSet(target)
 *   }
 * }
 * ```
 *
 * Factory classes for the generated @Provides functions are generated by
 * [ProvidesFactoryFirGenerator], which discovers them from the binding container's own
 * declarations.
 */
internal class BindingContainerObjectFirGenerator(
  session: FirSession,
  compatContext: CompatContext,
) : FirDeclarationGenerationExtension(session), CompatContext by compatContext {

  private data class BindingContainerInfo(
    val nestedName: Name,
    val targetClassId: ClassId,
    val annotationClassId: ClassId,
    val templateClassId: ClassId,
    val templateFunctions: Map<Name, FirNamedFunctionSymbol>,
    val scopeArg: FirGetClassCall,
    val replacesArg: FirExpression?,
    val isBindsTemplate: Boolean,
  )

  /** Binding container info by generated nested class ID. */
  private val bindingContainerInfoByNestedClassId = mutableMapOf<ClassId, BindingContainerInfo>()

  override fun FirDeclarationPredicateRegistrar.registerPredicates() {
    register(session.predicates.contributesTemplatePredicate)
    register(session.predicates.contributesTemplateTemplatePredicate)
  }

  override fun getNestedClassifiersNames(
    classSymbol: FirClassSymbol<*>,
    context: NestedClassGenerationContext,
  ): Set<Name> {
    // Don't recurse into generated binding containers
    if (classSymbol.hasOrigin(Keys.BindingContainerObjectDeclaration)) return emptySet()
    // Skip annotation classes (these are the custom annotations, not targets)
    if (classSymbol.classKind == ClassKind.ANNOTATION_CLASS) return emptySet()
    // Skip enum classes and enum entries
    if (
      classSymbol.classKind == ClassKind.ENUM_CLASS || classSymbol.classKind == ClassKind.ENUM_ENTRY
    )
      return emptySet()

    val classIds = session.classIds
    val names = mutableSetOf<Name>()

    for (annotation in classSymbol.resolvedCompilerAnnotationsWithClassIds) {
      if (!annotation.isResolved) continue
      val annotationClassId = annotation.toAnnotationClassIdSafe(session) ?: continue

      val annotationClassSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(annotationClassId)
          as? FirRegularClassSymbol ?: continue

      // Check if the annotation class has @ContributesTemplate meta-annotation
      val metaAnnotation =
        annotationClassSymbol.resolvedCompilerAnnotationsWithClassIds.firstOrNull {
          it.isResolved &&
            it.toAnnotationClassIdSafe(session) == classIds.contributesTemplateAnnotation
        } ?: continue

      // Extract template class from meta-annotation
      val templateClassId = extractTemplateClassId(metaAnnotation, annotationClassId)
      if (templateClassId == null) continue

      // Resolve template class to check if it's object (@Provides) or abstract class (@Binds)
      val templateClassSymbol =
        session.symbolProvider.getClassLikeSymbolByClassId(templateClassId)
          as? FirRegularClassSymbol ?: continue
      val isBindsTemplate =
        templateClassSymbol.classKind == ClassKind.CLASS && templateClassSymbol.isAbstract

      // Try meta-annotation scope first, then custom annotation scope
      val metaScopeArg = extractMetaScopeArg(metaAnnotation, annotationClassId)
      val directScopeArg = extractScopeArg(annotation)
      val scopeArg = metaScopeArg ?: directScopeArg ?: continue

      val replacesArg = extractReplacesArg(annotation)

      val nestedName =
        (Symbols.StringNames.METRO_BINDING_CONTAINER_FOR_PREFIX +
            annotationClassId.shortClassName.identifier)
          .asName()

      val templateFunctions = getTemplateFunctions(templateClassId, isBindsTemplate)

      val nestedClassId = classSymbol.classId.createNestedClassId(nestedName)

      val info =
        BindingContainerInfo(
          nestedName = nestedName,
          targetClassId = classSymbol.classId,
          annotationClassId = annotationClassId,
          templateClassId = templateClassId,
          templateFunctions = templateFunctions,
          scopeArg = scopeArg,
          replacesArg = replacesArg,
          isBindsTemplate = isBindsTemplate,
        )

      bindingContainerInfoByNestedClassId[nestedClassId] = info

      // Store hint for ContributionHintFirGenerator to discover this binding container
      val scopeClassId = scopeArg.resolvedClassId()
      if (scopeClassId != null) {
        session.metroFirBuiltIns.bindingContainerHints.add(nestedClassId to scopeClassId)
      }

      names += nestedName
    }

    return names
  }

  override fun generateNestedClassLikeDeclaration(
    owner: FirClassSymbol<*>,
    name: Name,
    context: NestedClassGenerationContext,
  ): FirClassLikeSymbol<*>? {
    if (!name.identifier.startsWith(Symbols.StringNames.METRO_BINDING_CONTAINER_FOR_PREFIX)) {
      return null
    }

    val nestedClassId = owner.classId.createNestedClassId(name)
    val info = bindingContainerInfoByNestedClassId[nestedClassId] ?: return null

    val classKind = if (info.isBindsTemplate) ClassKind.CLASS else ClassKind.OBJECT

    return createNestedClass(
        owner,
        name,
        Keys.BindingContainerObjectDeclaration,
        classKind = classKind,
      ) {
        if (info.isBindsTemplate) {
          modality = Modality.ABSTRACT
        }
      }
      .apply {
        markAsDeprecatedHidden(session)

        val annotations = buildList {
          add(buildContributesToAnnotation(info.scopeArg, info.replacesArg))
          add(buildBindingContainerAnnotation())
          add(buildOriginAnnotation(info.targetClassId))
        }

        replaceAnnotations(this@apply.annotations + annotations)
      }
      .symbol
  }

  @OptIn(DirectDeclarationsAccess::class)
  private fun getTemplateFunctions(
    templateClassId: ClassId,
    isBindsTemplate: Boolean,
  ): Map<Name, FirNamedFunctionSymbol> {
    val templateClassSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(templateClassId) as? FirRegularClassSymbol
        ?: return emptyMap()

    val classIds = session.classIds
    return templateClassSymbol.declarationSymbols
      .filterIsInstance<FirNamedFunctionSymbol>()
      .filter { fn ->
        if (isBindsTemplate) {
          fn.isAnnotatedWithAny(session, classIds.bindsAnnotations)
        } else {
          fn.isAnnotatedWithAny(session, classIds.providesAnnotations)
        }
      }
      .associateBy { it.name }
  }

  private fun FirClassSymbol<*>.isGeneratedBindingContainerObject(): Boolean {
    return !name.isSpecial &&
      name.identifier.startsWith(Symbols.StringNames.METRO_BINDING_CONTAINER_FOR_PREFIX) &&
      hasOrigin(Keys.BindingContainerObjectDeclaration)
  }

  override fun getCallableNamesForClass(
    classSymbol: FirClassSymbol<*>,
    context: MemberGenerationContext,
  ): Set<Name> {
    if (classSymbol.isGeneratedBindingContainerObject()) {
      val info = bindingContainerInfoByNestedClassId[classSymbol.classId]
      return buildSet {
        add(SpecialNames.INIT)
        info?.templateFunctions?.keys?.let(::addAll)
      }
    }

    return emptySet()
  }

  override fun generateConstructors(context: MemberGenerationContext): List<FirConstructorSymbol> {
    if (context.owner.isGeneratedBindingContainerObject()) {
      return listOf(
        createDefaultPrivateConstructor(context.owner, Keys.BindingContainerObjectDeclaration)
          .symbol
      )
    }

    return emptyList()
  }

  override fun generateFunctions(
    callableId: CallableId,
    context: MemberGenerationContext?,
  ): List<FirNamedFunctionSymbol> {
    val nonNullContext = context ?: return emptyList()
    if (callableId.callableName == SpecialNames.INIT) return emptyList()

    val info =
      bindingContainerInfoByNestedClassId[nonNullContext.owner.classId] ?: return emptyList()

    if (callableId.callableName !in info.templateFunctions) return emptyList()

    if (nonNullContext.owner.hasOrigin(Keys.BindingContainerObjectDeclaration)) {
      return generateDelegateFunction(callableId, nonNullContext, info)
    }

    return emptyList()
  }

  @OptIn(DirectDeclarationsAccess::class)
  private fun generateDelegateFunction(
    callableId: CallableId,
    context: MemberGenerationContext,
    info: BindingContainerInfo,
  ): List<FirNamedFunctionSymbol> {
    val templateFunction = info.templateFunctions[callableId.callableName] ?: return emptyList()

    val targetClassSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(info.targetClassId)
        as? FirRegularClassSymbol ?: return emptyList()
    val targetClassType = targetClassSymbol.defaultType()

    // Substitute the template function's type parameter T -> TargetClass
    val substitutionMap = templateFunction.typeParameterSymbols.zip(listOf(targetClassType)).toMap()
    val substitutor = substitutorByMap(substitutionMap, session)

    val returnType = substitutor.substituteOrSelf(templateFunction.resolvedReturnType)

    if (info.isBindsTemplate) {
      // For @Binds templates, generate abstract function (no body needed)
      val keptParams = templateFunction.valueParameterSymbols
      val function =
        createMemberFunction(
            context.owner,
            Keys.BindingContainerGeneratedFunction,
            callableId.callableName,
            returnType = returnType,
          ) {
            modality = Modality.ABSTRACT
            for (param in keptParams) {
              val substitutedType = substitutor.substituteOrSelf(param.resolvedReturnType)
              valueParameter(name = param.name, key = Keys.RegularParameter, type = substitutedType)
            }
          }
          .apply {
            val templateAnnotations =
              substituteTemplateAnnotations(
                templateFunction.resolvedCompilerAnnotationsWithClassIds.toList(),
                info.scopeArg,
                info.targetClassId,
              )
            replaceAnnotationsSafe(annotations + templateAnnotations)
          }
          .symbol as FirNamedFunctionSymbol
      return listOf(function)
    } else {
      // For @Provides templates, generate delegate function (with body in IR)
      val keptParams = templateFunction.valueParameterSymbols
      val function =
        createMemberFunction(
            context.owner,
            Keys.BindingContainerGeneratedFunction,
            callableId.callableName,
            returnType = returnType,
          ) {
            for (param in keptParams) {
              val substitutedType = substitutor.substituteOrSelf(param.resolvedReturnType)
              valueParameter(name = param.name, key = Keys.RegularParameter, type = substitutedType)
            }
          }
          .apply {
            // Copy annotations from the template function, substituting TemplateScope +
            // TemplateTarget
            val templateAnnotations =
              substituteTemplateAnnotations(
                templateFunction.resolvedCompilerAnnotationsWithClassIds.toList(),
                info.scopeArg,
                info.targetClassId,
              )
            replaceAnnotationsSafe(annotations + templateAnnotations)
            // Copy parameter annotations
            for ((i, param) in keptParams.withIndex()) {
              if (i < valueParameters.size) {
                valueParameters[i].replaceAnnotationsSafe(
                  substituteTemplateAnnotations(
                    param.resolvedCompilerAnnotationsWithClassIds.toList(),
                    info.scopeArg,
                    info.targetClassId,
                  )
                )
              }
            }
          }
          .symbol as FirNamedFunctionSymbol

      return listOf(function)
    }
  }

  private fun substituteTemplateAnnotations(
    annotations: List<FirAnnotation>,
    scopeArg: FirGetClassCall,
    targetClassId: ClassId,
  ): List<FirAnnotation> {
    return annotations.map { annotation ->
      val mapping = annotation.argumentMapping.mapping
      val needsSubstitution =
        mapping.values.any {
          (it is FirGetClassCall && (it.isTemplateScope() || it.isTemplateTarget()))
        }
      if (!needsSubstitution) {
        annotation
      } else {
        buildAnnotation {
          annotationTypeRef = annotation.annotationTypeRef
          argumentMapping = buildAnnotationArgumentMapping {
            for ((name, value) in mapping) {
              if (value is FirGetClassCall && value.isTemplateScope()) {
                this.mapping[name] = scopeArg
              } else if (value is FirGetClassCall && value.isTemplateTarget()) {
                val targetSymbol =
                  session.symbolProvider.getClassLikeSymbolByClassId(targetClassId)
                    as? FirRegularClassSymbol
                if (targetSymbol != null) {
                  this.mapping[name] = buildResolvedGetClassCall(targetClassId, targetSymbol)
                } else {
                  this.mapping[name] = value
                }
              } else {
                this.mapping[name] = value
              }
            }
          }
        }
      }
    }
  }

  private fun FirGetClassCall.isTemplateScope(): Boolean {
    resolvedClassId()?.let {
      return it == Symbols.ClassIds.metroTemplateScope
    }
    val ref =
      (argument as? FirQualifiedAccessExpression)
        ?.calleeReference
        ?.let { it as? FirNamedReference }
        ?.name
    return ref?.identifier == Symbols.StringNames.TEMPLATE_SCOPE
  }

  private fun FirGetClassCall.isTemplateTarget(): Boolean {
    resolvedClassId()?.let {
      return it == Symbols.ClassIds.metroTemplateTarget
    }
    val ref =
      (argument as? FirQualifiedAccessExpression)
        ?.calleeReference
        ?.let { it as? FirNamedReference }
        ?.name
    return ref?.identifier == Symbols.StringNames.TEMPLATE_TARGET
  }

  private fun extractTemplateClassId(
    metaAnnotation: FirAnnotation,
    annotationClassId: ClassId,
  ): ClassId? {
    val getClassCall =
      metaAnnotation.argumentAsOrNull<FirGetClassCall>(Symbols.Names.template, 0) ?: return null

    val resolvedClassId = getClassCall.resolvedClassId()
    if (resolvedClassId != null) return resolvedClassId

    return resolveClassReference(getClassCall, annotationClassId)?.first
  }

  private fun extractScopeArg(annotation: FirAnnotation): FirGetClassCall? {
    return annotation.argumentAsOrNull<FirGetClassCall>(Symbols.Names.scope, 0)
  }

  /** Returns null if not set (Nothing::class sentinel). */
  private fun extractMetaScopeArg(
    metaAnnotation: FirAnnotation,
    annotationClassId: ClassId,
  ): FirGetClassCall? {
    val getClassCall =
      metaAnnotation.argumentAsOrNull<FirGetClassCall>(Symbols.Names.scope, 1) ?: return null

    val resolvedClassId = getClassCall.resolvedClassId()
    if (resolvedClassId != null) {
      if (resolvedClassId == StandardClassIds.Nothing) return null
      return getClassCall
    }

    val (classId, symbol) = resolveClassReference(getClassCall, annotationClassId) ?: return null
    return buildResolvedGetClassCall(classId, symbol)
  }

  /**
   * Resolves a [FirGetClassCall] to a [ClassId] and [FirRegularClassSymbol] pair. Falls back to
   * candidate package resolution during COMPANION_GENERATION phase when annotation arguments may
   * not be fully resolved yet.
   */
  private fun resolveClassReference(
    getClassCall: FirGetClassCall,
    annotationClassId: ClassId,
  ): Pair<ClassId, FirRegularClassSymbol>? {
    getClassCall.resolvedClassId()?.let { classId ->
      val symbol =
        session.symbolProvider.getClassLikeSymbolByClassId(classId) as? FirRegularClassSymbol
          ?: return null
      return classId to symbol
    }

    val simpleName =
      (getClassCall.argument as? FirQualifiedAccessExpression)
        ?.calleeReference
        ?.let { it as? FirNamedReference }
        ?.name ?: return null

    val candidatePackages =
      listOf(annotationClassId.packageFqName, FqName.ROOT, Symbols.FqNames.metroRuntimePackage)
    for (pkg in candidatePackages.distinct()) {
      val candidateClassId = ClassId(pkg, simpleName)
      val symbol =
        session.symbolProvider.getClassLikeSymbolByClassId(candidateClassId)
          as? FirRegularClassSymbol ?: continue
      return candidateClassId to symbol
    }

    return null
  }

  private fun extractReplacesArg(annotation: FirAnnotation): FirExpression? {
    val arg = annotation.argumentAsOrNull<FirExpression>(Symbols.Names.replaces, 1) ?: return null
    // Skip empty array literals (default values) â€” they don't need propagation since
    // @ContributesTo already defaults to []. Copying unresolved FirArrayLiteralImpl
    // causes Fir2Ir failures because the expression has no resolved type set.
    if (arg is FirCall && arg.argumentList.arguments.isEmpty()) return null
    return arg
  }

  private fun buildResolvedGetClassCall(
    classId: ClassId,
    symbol: FirRegularClassSymbol,
  ): FirGetClassCall {
    val classType = symbol.defaultType()
    return buildGetClassCall {
      argumentList = buildArgumentList {
        arguments += buildResolvedQualifier {
          packageFqName = classId.packageFqName
          relativeClassFqName = classId.relativeClassName
          this.symbol = symbol
          resolvedToCompanionObject = false
          isFullyQualified = true
          coneTypeOrNull = classType
        }
      }
      coneTypeOrNull =
        ConeClassLikeTypeImpl(
          StandardClassIds.KClass.toLookupTag(),
          arrayOf(classType),
          isMarkedNullable = false,
        )
    }
  }

  private fun buildContributesToAnnotation(
    scopeArg: FirGetClassCall,
    replacesArg: FirExpression?,
  ): FirAnnotation {
    val contributesToClassId = session.classIds.contributesToAnnotations.first()
    val contributesToSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(contributesToClassId)
        as FirRegularClassSymbol
    return buildAnnotation {
      annotationTypeRef = contributesToSymbol.defaultType().toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping {
        mapping[Symbols.Names.scope] = scopeArg
        if (replacesArg != null) {
          mapping[Symbols.Names.replaces] = replacesArg
        }
      }
    }
  }

  private fun buildBindingContainerAnnotation(): FirAnnotation {
    val bindingContainerClassId = session.classIds.bindingContainerAnnotations.first()
    val bindingContainerSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(bindingContainerClassId)
        as FirRegularClassSymbol
    return buildSimpleAnnotation { bindingContainerSymbol }
  }

  private fun buildOriginAnnotation(targetClassId: ClassId): FirAnnotation {
    val originSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(Symbols.ClassIds.metroOrigin)
        as FirRegularClassSymbol

    val targetSymbol =
      session.symbolProvider.getClassLikeSymbolByClassId(targetClassId) as? FirRegularClassSymbol
        ?: error("Could not find target class: $targetClassId")

    return buildAnnotation {
      annotationTypeRef = originSymbol.defaultType().toFirResolvedTypeRef()
      argumentMapping = buildAnnotationArgumentMapping {
        mapping[StandardNames.DEFAULT_VALUE_PARAMETER] =
          buildResolvedGetClassCall(targetClassId, targetSymbol)
      }
    }
  }
}
