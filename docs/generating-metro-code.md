# Generating Metro Code

Java annotation processing and KSP both support multiple rounds of processing, allowing custom processors to generate new code with injection annotations that can be processed in later rounds. Anvil supported custom `CodeGenerator` implementations in K1 and anvil-ksp and kotlin-inject-anvil support specifying custom contributing annotations to allow them to intelligently defer processing to later rounds.

Since Metro is implemented as a compiler plugin, asking users to write compiler plugins to interact with it would be a bit unwieldy. However, KSP processors that generate metro-annotated code work out of the box with it since they run before Metro's plugin does.

If you have an existing KSP processor for a different framework, you could leverage it + custom annotations interop support described above to make them work out of the box with Metro.

## Origin Annotations

When code generators create Metro-annotated types, they can use the `@Origin` annotation to link the generated type back to its source. This is particularly useful for contribution merging - when a source type is excluded or replaced in a `@DependencyGraph`, any generated types with `@Origin` pointing to it will also be excluded or replaced automatically.

```kotlin
// Source type
@GenerateSomething
class UserRepository

// Generated by your KSP processor
@ContributesBinding(AppScope::class)
@Origin(UserRepository::class)  // Links back to the source
class UserRepository_Impl : UserRepository
```

Now if `UserRepository` is excluded in a graph:

```kotlin
@DependencyGraph(
  scope = AppScope::class,
  excludes = [UserRepository::class]  // This also excludes UserRepository_Impl
)
interface AppGraph
```

### Custom Origin Annotations

You can configure Metro to recognize custom origin annotations through the Gradle plugin:

```kotlin
metro {
  interop {
    origin.add("com.example.GeneratedFrom")
  }
}
```

The annotation must have a `KClass` parameter at index `0`.

If using Anvil interop, kotlin-inject-anvil's `@Origin` annotation is automatically recognized.


```kotlin
metro {
  interop {
    includeAnvil(includeKotlinInjectAnvil = true)
  }
}
```

## @ContributesTemplate

`@ContributesTemplate` is a meta-annotation for defining custom annotations that automatically generate bindings for every annotated class. The annotation's companion object contains template `@Provides` functions, each with a single type parameter `T` that is substituted with the target class.

```kotlin
@ContributesTemplate
annotation class ContributesFeature(val scope: KClass<*>) {
  companion object {
    @Provides @IntoSet fun <T : Feature> intoSet(target: T): Feature = target
  }
}

@ContributesFeature(AppScope::class)
@Inject
class UserScreen : Feature

@ContributesFeature(AppScope::class)
object SettingsScreen : Feature
```

`@Inject` classes, `object`s, and `interface`s are all supported as targets. Upper bounds on `T` are validated at compile time.

### Reified type access

Template functions can be declared `inline reified` to access the target class at runtime.

```kotlin
@ContributesTemplate
annotation class ContributesClassToSet(val scope: KClass<*>) {
  companion object {
    @Provides @IntoSet inline fun <reified T> name(): KClass<*> = T::class
  }
}
```

### TemplateScope

`TemplateScope` can be used as a placeholder in scoping annotations. Metro substitutes it with the resolved scope â€” either the `scope` parameter from the custom annotation or the `scope` specified on `@ContributesTemplate`. When `@ContributesTemplate` specifies a `scope`, the custom annotation must not have its own `scope` parameter. These are mutually exclusive.

```kotlin
@Provides @SingleIn(TemplateScope::class) @IntoSet fun <T : Feature> intoSet(target: T): Feature = target
```

### Replacing generated containers

Generated containers can be replaced via `replaces`, targeting the annotated class itself:

```kotlin
@ContributesTo(AppScope::class, replaces = [UserScreen::class])
@BindingContainer
object ReplacementBinding {
  @Provides @IntoSet fun replacement(): Feature = FakeUserScreen()
}
```