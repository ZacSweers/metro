{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"\ud83d\ude87 Metro","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Metro is a compile-time dependency injection framework that draws heavy inspiration from Dagger, Anvil, and Kotlin-Inject. It seeks to unify their best features under one, cohesive solution while adding a few new features and implemented as a compiler plugin.</p>"},{"location":"#why-another-di-framework","title":"Why another DI framework?","text":"<p>It\u2019s felt for some time like the Kotlin community has been waiting for a library at the intersection of these different tools and features. Different tools exist for parts of these, but there\u2019s not yet been a unified solution that checks all these boxes, leaves behind some of these tools\u2019 limitations, and embraces newer features that native compiler plugins offer.</p> <p>In short, Metro stands on the shoulders of giants. It doesn\u2019t try to reinvent the wheel, it does try to make those wheels work better together.</p> <p>Note</p> <p>I\u2019m aware of the XKCD comic \ud83d\ude42, I think Metro offers a compelling feature set with interop hooks that make it easy to integrate with an existing codebase.</p>"},{"location":"#installation","title":"Installation","text":"<p>Apply the gradle plugin.</p> <pre><code>plugins {\n  id(\"dev.zacsweers.metro\") version \"x.y.z\"\n}\n</code></pre> <p>And that\u2019s it! The default configuration will add the multiplatform <code>runtime</code> artifact (which has annotations you can use) and wire it all automatically.</p> <p>You can configure custom behaviors with APIs on the <code>metro</code> DSL extension.</p> <pre><code>metro {\n  // Defines whether or not metro is enabled. Useful if you want to gate this behind a dynamic\n  // build configuration.\n  enabled = true // Default\n\n  // Enable (extremely) verbose debug logging\n  debug = false // Default\n\n  // See the kdoc on MetroPluginExtension for full details\n}\n</code></pre> <p>Snapshots of the development version are available in Sonatype\u2019s <code>snapshots</code> repository.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>The compiler plugin itself supports all multiplatform project types. The first-party annotations artifact is also multiplatform and supports all common JVM, JS, and native targets.</p> <p>Contribution hint generation is not currently supported on native or Wasm targets until KT-58886 is resolved. They do work within the same compilation though.</p>"},{"location":"#caveats","title":"Caveats","text":"<ul> <li>Kotlin compiler plugins are not a stable API! Compiled outputs from this plugin should be stable, but usage in newer versions of kotlinc are not guaranteed to be stable. That said, Metro will strive to make matching releases available quickly and test against Kotlin prereleases eagerly.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Special thanks to the many people that helped advise and offer feedback on Metro\u2019s design and implementation.</p> <ul> <li>Brian Norman</li> <li>Ralf Wondratschek</li> <li>Jesse Wilson</li> <li>Dany Santiago</li> <li>Eva Tatarka</li> <li>Bridget Phillips</li> <li>Bryan Stern</li> <li>James Barr</li> <li>and many more!</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>Copyright (C) 2025 Zac Sweers\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"adoption/","title":"Adoption Strategies","text":"<p>If adopting Metro into an existing codebase, you can use a few different strategies.</p> <ol> <li>First, add the Metro Gradle plugin and runtime deps. The plugin id is <code>dev.zacsweers.metro</code>, runtime is <code>dev.zacsweers.metro:runtime</code>. The Gradle Plugin should add the runtime automatically, but it\u2019s there just in case!</li> <li>Apply the Gradle plugin to your relevant project(s).</li> </ol> From DaggerFrom kotlin-inject"},{"location":"adoption/#precursor-steps","title":"Precursor steps","text":"<p>Compiler options you should enable in Dagger</p> <p>Dagger has some compiler options you should enable and get working first to make it easier to move to Metro.</p> <ul> <li>useBindingGraphFix <ul> <li>The issue it fixes is something that Metro catches as well.</li> </ul> </li> <li>ignoreProvisionKeyWildcards</li> </ul> <p>K2 Migration</p> <p>If you are migrating from square/anvil, you likely are also going to have to migrate to Kotlin K2 as a part of this. If you want to split that effort up, you can consider migrating to anvil-ksp first. This would move fully over to KSP and K2 first, then you can resume here.</p>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level","title":"Option 1: Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on Dagger components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is also good if you just want to do a simple, isolated introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations","title":"Option 2: Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from Dagger/Anvil. Here is an example for enabling that in Gradle.</p> <ol> <li>Remove the dagger-compiler/anvil plugin (but keep their runtime deps).</li> <li>Enable interop with the Metro gradle plugin</li> </ol> <pre><code>metro {\n  interop {\n    includeDagger()\n    includeAnvil() // If using Anvil\n  }\n}\n</code></pre> <p>Most things will Just Work\u2122, but you will still possibly need to do some manual migrations.</p> <ul> <li>If you use <code>KClass</code> and <code>Class</code> interchangeably in your graph, Metro distinguishes between these and you\u2019ll need to move fully over to one or the other, likely <code>KClass</code>.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>If you use <code>@MergeComponent</code> with <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>Not necessary if coming from anvil-ksp.</li> <li>Migrate <code>@BindsInstance</code> to <code>@Provides</code>. Metro consolidated these to just one annotation.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul> <p>You can also remove any <code>@JvmSuppressWildcard</code> annotations, these are ignored in Metro.</p>"},{"location":"adoption/#option-3-full-migration","title":"Option 3: Full migration","text":"<ul> <li>Remove the Dagger and anvil runtimes.</li> <li>Replace all Dagger/anvil annotations with Metro equivalents.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> <li>Migrate from javax/jakarta <code>Provider</code> and <code>dagger.Lazy</code> APIs to Metro\u2019s <code>Provider</code> and the stdlib\u2019s <code>Lazy</code> APIs.</li> </ul>"},{"location":"adoption/#precursor-steps_1","title":"Precursor steps","text":"<ol> <li>Remove the kotlin-inject(-anvil) dependencies (but keep their runtime deps if you use option 1 below!).</li> <li>Migrate to <code>@AssistedFactory</code> if you haven\u2019t already.</li> </ol>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level_1","title":"Option 1: Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on kotlin-inject components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is also good if you want to do a simple, isolated introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations_1","title":"Option 2: Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from kotlin-inject/kotlin-inject-anvil. Here is an example for enabling that in Gradle.</p> <ol> <li>Remove the kotlin-inject and kotlin-inject-anvil KSP processors (but keep their runtime deps).</li> <li>Enable interop with the Metro Gradle plugin</li> </ol> <pre><code>metro {\n  interop {\n    includeKotlinInject()\n    includeAnvil() // If using kotlin-inject-anvil\n  }\n}\n</code></pre> <p>You will still possibly need to do some manual migrations, namely providers.</p> <ul> <li>Any map multibindings need to migrate to use map keys.</li> <li>Any higher order function injection will need to switch to using Metro\u2019s <code>Provider</code> API.</li> <li>Any higher order assisted function injection will need to switch to using <code>@AssistedFactory</code>-annotated factories.</li> <li>If you use <code>@MergeComponent</code> + <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"adoption/#option-3-full-migration_1","title":"Option 3: Full migration","text":"<ul> <li>Any map multibindings need to migrate to use map keys.</li> <li>Any higher order function injection will need to switch to using Metro\u2019s <code>Provider</code> API.</li> <li>Any higher order assisted function injection will need to switch to using <code>@AssistedFactory</code>-annotated factories.</li> <li>Remove the kotlin-inject and kotlin-inject-anvil runtimes.</li> <li>Replace all kotlin-inject/kotlin-inject-anvil annotations with Metro equivalents.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"aggregation/","title":"Aggregation (aka \u2018Anvil\u2019)","text":"<p>Metro supports Anvil-style aggregation in graphs via <code>@ContributesTo</code> and <code>@ContributesBinding</code> annotations. As aggregation is a first-class citizen of Metro\u2019s API, there is no <code>@MergeComponent</code> annotation like in Anvil. Instead, <code>@DependencyGraph</code> defines which contribution scope it supports directly.</p> <pre><code>@DependencyGraph(scope = AppScope::class)\ninterface AppGraph\n</code></pre> <p>When a graph declares a <code>scope</code>, all contributions to that scope are aggregated into the final graph implementation in code gen.</p> <p>If a graph supports multiple scopes, use <code>additionalScopes</code>.</p> <pre><code>@DependencyGraph(\n  AppScope::class,\n  additionalScopes = [LoggedOutScope::class]\n)\ninterface AppGraph\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@DependencyGraph</code> supports excluding contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(\n  scope = AppScope::class,\n  excludes = [RealNetworkProviders::class]\n)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class)\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesto","title":"@ContributesTo","text":"<p>This annotation is used to contribute graph interfaces to the target scope to be merged in at graph-processing time to the final merged graph class as another supertype.</p> <pre><code>@ContributesTo(AppScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesTo(AppScope::class)\n@ContributesTo(LoggedInScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@ContributesBinding</code> (as well as the other <code>@Contributes*</code> annotations) supports replacing other contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class, replaces = [RealNetworkProviders::class])\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesbinding","title":"@ContributesBinding","text":"<p>This annotation is used to contribute injected classes to a target scope as a given bound type.</p> <p>The below example will contribute the <code>CacheImpl</code> class as a <code>Cache</code> type to <code>AppScope</code>.</p> <pre><code>@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For simple cases where there is a single supertype, that type is implicitly used as the bound type. If your bound type is qualified, for the implicit case you can put the qualifier on the class.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For classes with multiple supertypes or advanced cases where you want to bind an ancestor type, you can explicitly define this via <code>binding</code> parameter.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Whoa, is that a function call in an annotation argument? Nope! <code>binding</code> is just a decapitalized class in this case, intentionally designed for readability. It\u2019s an adjective in this context and the functional syntax better conveys that.</p> <p>Note that the bound type is defined as the type argument to <code>@ContributesBinding</code>. This allows for the bound type to be generic and is validated in FIR.</p> <p>Qualifier annotations can also be specified on the <code>binding</code> type parameter and will take precedence over any qualifiers on the class itself.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;@Named(\"cache\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;AnotherType&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Contributions may be <code>object</code> classes. In this event, Metro will automatically provide the object instance in its binding.</p>"},{"location":"aggregation/#implicitly-injected-contributesbinding-types","title":"Implicitly-injected <code>@ContributesBinding</code> types","text":"<p>Up to version <code>0.7.0</code>, Metro has always required you to use <code>@Inject</code> on most <code>@Contributes*</code> annotated types. However, this can feel a bit repetitive and tedious. Starting in <code>0.7.0</code>, there is a new <code>contributesAsInject</code> Gradle DSL option that can be enabled that will treat all <code>@Contributes*</code> annotated types as <code>@Inject</code> by default. You can still use <code>@Inject</code> on classes to be explicit, and if you have multiple constructors you must still use <code>@Inject</code> on the constructor you want to be used.</p> <p>The only exception to this is <code>@ContributesTo</code>, which isn\u2019t applicable to injected types.</p> <p>This is disabled by default to start but will likely become the default in a future release.</p> <pre><code>@ContributesBinding(AppScope::class)\n// @Inject // &lt;-- now implicit!\nclass TacoImpl(...) : Taco\n</code></pre>"},{"location":"aggregation/#contributesintosetcontributesintomap","title":"@ContributesIntoSet/@ContributesIntoMap","text":"<p>To contribute into a multibinding, use the <code>@ContributesIntoSet</code> or <code>@ContributesIntoMap</code> annotations as needed.</p> <pre><code>@ContributesIntoSet(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>Same rules around qualifiers and <code>binding()</code> apply in this scenario</p> <p>To contribute into a Map multibinding, the map key annotation must be specified on the class or <code>binding</code> type argument.</p> <pre><code>// Will be contributed into a Map multibinding with @StringKey(\"Networking\")\n@ContributesIntoMap(AppScope::class)\n@StringKey(\"Networking\")\n@Inject\nclass CacheImpl(...) : Cache\n\n// Or if using binding\n@ContributesIntoMap(\n  scope = AppScope::class,\n  binding = binding&lt;@StringKey(\"Networking\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>This annotation is also repeatable and can be used to contribute to multiple scopes, multiple bound types, and multiple map keys.</p> <p>You can use <code>@IntoMap</code>/<code>@IntoSet</code> to provide into the same container:</p> <pre><code>// Method 1: applying @ContributesIntoMap to bind directly from the implementation class\n@ContributesIntoMap(AppScope::class)\n@StringKey(\"remote\")\n@Inject\nclass RemoteCache(...) : Cache\n\n// Method 2: Declare the class, then provide @IntoMap binding separately via a BindingContainer\nclass LocalCache(...) : Cache\n\n@BindingContainer\n@ContributesTo(AppScope::class)\nobject CacheBindingContainer {\n  @Provides\n  @IntoMap\n  @StringKey(\"local\")\n  fun cache(): Cache = LocalCache(...)\n}\n\n// Accessing the resultant map, containing both implementations:\n@Inject\nclass CompositeCache(private val caches: Map&lt;String, Cache&gt;) {\n  val local: Cache = caches[\"local\"]\n  val remote: Cache = caches[\"remote\"]\n}\n\n// Alternatively, specify Provider in the map type to lazily-initialize the implementations\n@Inject\nclass CompositeCacheAlternate(private val caches: Map&lt;String, Provider&lt;Cache&gt;&gt;) {\n  val local: Cache = caches[\"local\"]()\n  val remote: Provider&lt;Cache&gt; = caches[\"remote\"]\n\n  fun someTimeLater() {\n    remote().doSomethingWithCache()\n  }\n}\n</code></pre> <p>Like <code>@ContributesBinding</code>, enabling the <code>contributesAsInject</code> Gradle DSL option will treat all <code>@ContributesIntoSet</code>/<code>@ContributesIntoMap</code>-annotated types as <code>@Inject</code> by default.</p>"},{"location":"aggregation/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers (see Binding Containers) can also be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"aggregation/#replacing-contributed-binding-containers","title":"Replacing Contributed Binding Containers","text":"<p>Similar to other contribution types, binding containers can replace other contributed binding containers:</p> <pre><code>// In production\n@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n// In tests\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre>"},{"location":"aggregation/#replacing-contributed-bindings","title":"Replacing Contributed Bindings","text":"<p>Binding containers can replace other contributed bindings, too:</p> <pre><code>// In production\n@ContributesBinding(AppScope::class)\n@Inject\nclass HttpClientImpl : HttpClient\n\n// In tests\n@ContributesTo(AppScope::class, replaces = [HttpClientImpl::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre>"},{"location":"aggregation/#excluding-contributed-binding-containers","title":"Excluding Contributed Binding Containers","text":"<p>Graphs can exclude specific contributed binding containers:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface TestAppGraph {\n  // NetworkBindings will not be included\n}\n</code></pre>"},{"location":"aggregation/#implementation-notes","title":"Implementation notes","text":"<p>This leans on Kotlin\u2019s ability to put generic type parameters on annotations. That in turn allows for both generic bound types and to contribute map bindings to multiple map keys.</p> <p>Because it\u2019s a first-party feature, there\u2019s no need for intermediary \u201cmerged\u201d components like kotlin-inject-anvil and anvil-ksp do.</p> <p>Generated contributing interfaces are generated to the <code>metro.hints</code> package and located during graph supertype generation in FIR downstream. Any contributed bindings are implemented as <code>@Binds</code> (\u00b1 IntoSet/IntoMap/etc) annotated properties.</p>"},{"location":"bindings/","title":"Bindings","text":""},{"location":"bindings/#qualifiers","title":"Qualifiers","text":"<p>Like Dagger and KI, Metro supports qualifier annotations to allow disambiguation of types. These are applied at injection and provision sites. A qualifier annotation is any annotation annotated with <code>@Qualifier</code>. For convenience, there is an included <code>@Named</code> qualifier available in Metro\u2019s runtime that can be used too.</p> <p>A \u201ctype key\u201d in Metro is composed of a concrete type and (if any) qualifier annotation attached to it.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val int: Int\n  @Named(\"named\") val namedInt: Int\n\n  @Provides\n  fun provideInt(): Int = 3\n\n  @Provides\n  @Named(\"named\")\n  fun provideNamedInt(): Int = 4\n}\n</code></pre>"},{"location":"bindings/#binds","title":"@Binds","text":"<p>In many cases, a developer may have an implementation type on the graph that they want to expose as just its supertype.</p> <p>Like Dagger, Metro supports this with <code>@Binds</code>.</p> <p>For these cases, an abstract provider can be specified with the following conditions.</p> <ul> <li>It must be abstract</li> <li>It must define one extension receiver that is a subtype of its provided type</li> </ul> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: Message\n\n  // Bind MessageImpl as Message\n  @Binds val MessageImpl.bind: Message\n\n  @Provides\n  fun provideText(): String = \"Hello, world!\"\n}\n\n@Inject\nclass MessageImpl(val text: String) : Message\n</code></pre> <p>If you want to limit access to these from your API, you can make these declarations <code>private</code> and just return <code>this</code>. Note it\u2019s still important to annotate them with <code>@Binds</code> so that the Metro compiler understands its intent! Otherwise, it\u2019s an error to implement these declarations.</p> <p><code>@Binds</code> declarations can also declare multibinding annotations.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val messages: Message\n\n  @Binds @IntoSet val MessageImpl.bind: Message\n}\n</code></pre> <p><code>@Binds</code> declarations may also be declared in binding Containers.</p> <p>Note</p> <p>In theory, you can implement a provider with a getter that replicates this (similar to how kotlin-inject uses <code>@get:Provider</code> + <code>this</code>), but this will be an error in FIR because Metro can generate more efficient code at compile-time if you use <code>@Binds</code>. This is because Metro can avoid calling the function entirely and just use this information at compile-time to optimize the generated code.</p>"},{"location":"bindings/#multibindings","title":"Multibindings","text":"<p>Like Dagger and KI, Metro supports <code>Set</code> and <code>Map</code> multibindings. Multibindings are collections of bindings of a common type. Multibindings are implicitly declared by the existence of providers annotated with <code>@IntoSet</code>, <code>@IntoMap</code>, or <code>@ElementsIntoSet</code>.</p> <pre><code>@DependencyGraph\ninterface SetMultibinding {\n  // contains a set of [1, 2, 3, 4]\n  val ints: Set&lt;Int&gt;\n\n  @Provides @IntoSet fun provideInt1() = 1\n\n  @Provides @IntoSet fun provideInt2() = 2\n\n  @Provides\n  @ElementsIntoSet\n  fun provideInts() = setOf(3, 4)\n}\n</code></pre> <p>Map multibindings use <code>@IntoMap</code> and require a map key annotation. Map keys are any annotation annotated with <code>@MapKey</code>. Metro\u2019s runtime includes a number of common ones like <code>@ClassKey</code> and <code>@StringKey</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  // contains a map of {1:1, 2:2}\n  val ints: Map&lt;Int, Int&gt;\n\n  @Provides\n  @IntoMap\n  @IntKey(1)\n  fun provideInt1() = 1\n\n  @Provides\n  @IntoMap\n  @IntKey(2)\n  fun provideInt2() = 2\n}\n</code></pre> <p>Alternatively, they can be declared with an <code>@Multibinds</code>-annotated accessor property/function in a component. This member will be implemented by the Metro compiler and is useful for scenarios where the multibinding may be empty.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinds(allowEmpty = true)\n  val ints: Map&lt;Int, Int&gt;\n}\n</code></pre> <p>Multibinding collections are immutable at runtime and cannot be defined as mutable at request sites.</p> <p>Map multibindings support injecting map providers, where the value type can be wrapped in <code>Provider</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinds(allowEmpty = true)\n  val ints: Map&lt;Int, Provider&lt;Int&gt;&gt;\n}\n</code></pre> <p>Unlike Dagger, empty multibindings in Metro are a compile error by default. Empty multibindings are allowed but must be opted into via <code>@Multibinds(allowEmpty = true)</code>.</p> Implementation Notes <p>Metro takes inspiration from Guice in handling these in the binding graph. Since they cannot be added directly to the graph as-is (otherwise they would cause duplicate binding errors), a synthetic <code>@MultibindingElement</code> qualifier annotation is generated for them at compile-time to disambiguate them. These are user-invisible but allows them to participate directly in graph validation like any other dependency. Metro then just adds these bindings as dependencies to <code>Binding.Multibinding</code> types.</p>"},{"location":"bindings/#optional-bindings","title":"Optional Bindings","text":"<p>Metro supports optional bindings by leaning on Kotlin\u2019s native support for default parameter values. These are checked at injection sites and are allowed to be missing from the dependency graph when performing a lookup at validation/code-gen time.</p> <p>The below example would, since there is no <code>Int</code> binding provided, provide a message of <code>Count: -1</code>.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(count: Int = -1) = \"Count: $count\"\n}\n</code></pre> <p>To expose accessors for optional bindings, use <code>@OptionalBinding</code> on the accessor. Note that the accessor must declare a default body that Metro will use if the binding is absent.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  @OptionalBinding\n  val message: String\n    get() = \"Absent!\"\n}\n</code></pre> <p>There are a couple of optional configuration for Metro\u2019s optional binding support that can be configured via the <code>optionalBindingBehavior</code> Gradle DSL:</p> <ul> <li><code>DISABLED</code> - Disallows optional bindings entirely.</li> <li><code>REQUIRE_OPTIONAL_BINDING</code> - Requires optional binding parameters to also be annotated with <code>@OptionalBinding</code>. This may be preferable for consistency with accessors and/or explicitness.</li> <li><code>DEFAULT</code> - The default behavior as described above \u2014 accessors must be annotated with <code>@OptionalBinding</code> with default bodies and parameters just use default value expressions.</li> </ul> <p>Dagger supports a similar feature via <code>@BindsOptionalOf</code>, but requires a separate declaration of this optional binding to the graph and works via <code>Optional&lt;T&gt;</code> types.</p> <p>KI supports the same feature.</p>"},{"location":"bindings/#nullability","title":"Nullability","text":"<p>As nullability is a first-class concept in Kotlin, Metro supports it too. Bindings in Metro graphs may be nullable, but it\u2019s important to understand how Metro treats them!</p> <p>In short, Metro will treat nullable types as different type keys than their non-nullable analogues. That is to say, <code>String</code> and <code>String?</code> are treated as distinct types in Metro.</p> <p>Furthermore, a <code>String</code> binding cannot satisfy a <code>String?</code> automatically. You may however <code>@Binds</code> a <code>String</code> to a <code>String?</code> and Metro will treat it as a valid binding.</p> <pre><code>@DependencyGraph(Unit::class)\ninterface ExampleGraph {\n  val int: Int\n  val nullableInt: Int?\n\n  @Provides\n  fun provideInt(): Int = 1\n\n  @Binds\n  val Int.bindAsNullable: Int?\n}\n</code></pre> <p>This pattern can be combined with optional bindings to allow for easy conditional injection, for example with optional bindings across different source sets: <pre><code>// in src/main\n@Inject\nclass ExampleUseCase(\n  val optionalRepository: OptionalRepository? = null\n)\n\ninterface OptionalRepository\n\n// If you want to expose it to your graph\n@ContributesTo(AppScope::class)\ninterface OptionalRepositoryProvider {\n  @OptionalDependency\n  val optionalRepository: OptionalRepository? get() = null\n}\n</code></pre></p> <p>then in the optionally included module: <pre><code>// Dependency of the src/debug source set\n@Inject\n@ContributesBinding(AppScope::class) // Standard binding\n// Add a nullable binding so it can satisfy the nullable injection\n// in the consuming project when present on the classpath\n@ContributesBinding(AppScope::class, binding = binding&lt;OptionalRepository?&gt;())\nclass OptionalRepositoryImpl : OptionalRepository\n</code></pre></p> Implementation Notes <p>While kotlin-inject can support this by simply invoking functions with omitted arguments, Metro has to support this in generated factories.</p> <p>To accomplish this, Metro will slightly modify how generated provider/constructor injection factory classes look compared to Dagger. Since we are working in IR, we can copy the default value expressions from the source function/constructor to the factory\u2019s newInstance and create() functions. This in turn allows calling generated graphs to simply omit absent binding arguments from their creation calls. This is a tried and tested pattern used by other first party plugins, namely kotlinx-serialization.</p> <p>There are a few cases that need to be handled here:</p> <ul> <li>Expressions may reference previous parameters or instance members. To support this, we\u2019ll transform them in IR to point at new parameters in those functions.</li> <li>Expressions may reference private instance members. To support this, Metro factories are generated as nested classes within the source class or graph.<ul> <li>This does depart from how dagger factories work, but if we ever wanted to have some sort of interop for that we could always generate bridging factory classes in the places dagger expects later.</li> </ul> </li> <li>Parameters in <code>create()</code> need to be wrapped in <code>Provider</code> calls. This means that for cases where they back-reference other parameters, those will need to be transformed into <code>invoke()</code> calls on those providers too.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>New: Experimental support for sharding large graphs. For extremely large dependency graphs on the JVM, their generated implementations could exceed the JVM class size limit. To avoid this, Metro now supports sharding within graphs (as needed) to distribute initialization code across multiple inner shard classes. This is currently disabled by default but can be enabled via the <code>enableGraphSharding</code> Gradle DSL property.</li> </ul>"},{"location":"changelog/#082","title":"0.8.2","text":"<p>2025-12-04</p> <ul> <li>Fix: Avoid JDK 21 <code>List.removeFirst()</code> call in the compiler artifact. That said, Metro\u2019s compiler may move to JDK 21+ in the future (note this is separate from the runtime JVM targets).</li> <li>Fix: Fix accidental <code>androidx.test</code> transitive dependency in <code>metrox-viewmodel-compose</code> artifact.</li> </ul>"},{"location":"changelog/#081","title":"0.8.1","text":"<p>2025-12-03</p> <ul> <li>New: Experimental support for Kotlin <code>2.3.20</code> dev builds. See the compatibility docs for tested versions.</li> <li>Fix: Follow chained alias bindings when ref-counting used bindings in property collection.</li> <li>Fix: Fix <code>@ViewModelAssistedFactoryKey</code> KClass key type to use <code>out ViewModel</code> instead.</li> </ul> <p>Special thanks to @ansman and @jisungbin for contributing to this release!</p>"},{"location":"changelog/#080","title":"0.8.0","text":"<p>2025-12-01</p> <ul> <li>New: New <code>dev.zacsweers.metro:metrox-android</code> artifact for Android <code>AppComponentFactory</code> support. See the docs for more information.</li> <li> <p>New: New <code>dev.zacsweers.metro:metrox-viewmodel</code> and <code>metrox-viewmodel-compose</code> artifacts for AndroidX <code>ViewModel</code> support. See the docs (compose docs ) for more information.</p> <ul> <li> <p>Should I use this?</p> </li> <li> <p>Well, that\u2019s up to you! This artifact is mostly for projects coming from heavy use of more vanilla Android architecture components or <code>hiltViewModel()</code> use. Modern Android apps should use higher level architectures like Circuit* (Disclosure: I am one of the authors of Circuit, and I\u2019m a big fan of it!), Voyager, etc. that abstract away <code>ViewModel</code> management.</p> </li> </ul> </li> <li> <p>New: Add <code>generateMetroGraphMetadata</code> Gradle task that writes a merged JSON dump of all binding graphs in the project. This can be chained from the <code>GenerateGraphMetadataTask</code> for further processing.</p> </li> <li>New: Add <code>analyzeMetroGraph</code> Gradle task that performs comprehensive graph analysis including fan-in/fan-out, betweenness centrality, dominator analysis, and longest path detection.</li> <li>New: Add <code>generateMetroGraphHtml</code> Gradle task that generates interactive HTML visualizations of dependency graphs using ECharts. Features include force/circular layouts, filtering by package/scope/synthetic bindings, metrics heatmaps, and longest path highlighting. See the graph analysis docs for more information.</li> <li>New: Add <code>MetroArtifacts</code> Gradle API for accessing Metro reports and graph metadata directories.</li> <li>New: Add <code>supportedHintContributionPlatforms</code> Gradle DSL property to manually override supported hint contribution generation on different platforms. By default this computes default supported platforms based on the platform and Kotlin tooling version.</li> <li>API Change: Rename <code>generateJvmContributionHintsInFir</code> Gradle DSL property to <code>generateContributionHintsInFir</code>. Note this property/mode still doesn\u2019t really work and is highly experimental at the moment.</li> <li>Behavior Change: Add <code>@DelicateMetroGradleApi</code> annotations to relevant Gradle extension APIs.</li> <li>Behavior Change: The <code>generateContributionHints</code> property now computes defaults per platform and per Kotlin compilation as a <code>convention</code> and can be overridden.</li> <li>Behavior Change: All non-final classes with member injections or that extend classes with member injections must now be annotated with <code>@HasMemberInjections</code>. This is enforced with a new diagnostic check.</li> <li>Enhancement: Lazily validate multibindings. Previously, multibindings were validated eagerly even if they were unused in a graph.</li> <li>Enhancement: Report all duplicate bindings errors during graph construction rather than failing at first.</li> <li>Enhancement: Support <code>FirFunctionCall</code> evaluation in annotation arguments during FIR.</li> <li>Enhancement: Order before the Compose compiler on Kotlin 2.3.0+.</li> <li>Enhancement: Only print Metro Gradle version configuration mismatch warnings once rather than per-compilation.</li> <li>Enhancement: Report Metro Gradle configuration issues to Gradle\u2019s <code>Problems</code> API.</li> <li>While this is nice for the IDE integration/Develocity integration, it\u2019s wholly hidden away from CLI users. So, Metro will still print these warnings to console too.</li> <li>Fix: Support member injection of classes that have no member injections but do extend superclasses with member injections.</li> <li>Fix: Catch more <code>IrErrorType</code> error types cases and report context/advice where possible.</li> <li>Fix: Dedupe binding containers contributed to both parent and child graphs.</li> <li>Fix: Fix support for Anvil\u2019s <code>exclude</code> argument in dependency graph annotations when Anvil interop is enabled.</li> <li>Fix: Fix colliding reports destinations in KMP projects by disambiguating with the target path as another subdir indirection.</li> <li>Fix: Fix qualifiers not being propagated to generated <code>MembersInjector</code> classes for multibindings.</li> <li>Fix: Remove misleading \u201cdoesn\u2019t appear to be visible to this compilation\u201d hint, as this hint was misreporting.</li> <li>Fix: Fix not reserving properties multibinding contributors that are behind aliases.</li> <li>Fix: Stub hint function bodies if FIR-generated.</li> <li>Fix: Hide FIR-generated hint functions.</li> <li>Fix: Full support injected Java fields from Dagger-processed Java supertypes.</li> <li>Fix: Use correct type args for empty map provider return types.</li> <li>Fix: Add Dagger\u2019s internal <code>SetFactory</code>, <code>MapFactory</code> and <code>MapProviderFactory</code> to known Dagger ClassIds in <code>Provider</code> interop.</li> <li>Removed: Removed deprecated <code>enableScopedInjectClassHints</code> Gradle DSL property.</li> <li>Removed: Removed deprecated <code>enableStrictValidation</code> Gradle DSL property.</li> <li>Removed: Removed deprecated <code>contributesGraphExtension</code> Gradle DSL property.</li> <li>Removed: Removed deprecated <code>contributesGraphExtensionFactory</code> Gradle DSL property.</li> <li>Removed: Removed deprecated <code>optionalDependencyBehavior</code> Gradle DSL property.</li> <li>Removed: Removed deprecated <code>OptionalDependencyBehavior</code> Gradle plugin class.</li> <li>Removed: Removed deprecated <code>includeAnvil</code> Gradle DSL function.</li> <li>Removed: Removed deprecated <code>ContributesGraphExtension</code> annotation.</li> <li>Removed: Removed deprecated <code>OptionalDependency</code> annotation.</li> </ul> <p>Special thanks to the following contributors for contributing to this release!</p> <ul> <li>@yschimke</li> <li>@jonapoul</li> <li>@kevinguitar</li> <li>@jonamireh</li> <li>@zsmb13</li> <li>@bjdodson</li> <li>@consp1racy</li> </ul>"},{"location":"changelog/#077","title":"0.7.7","text":"<p>2025-11-19</p> <ul> <li>Add <code>MetroCompilerPluginRegistrar.pluginId</code> for forward compatibility with Kotlin <code>2.3.0</code>\u2019s new API.</li> </ul>"},{"location":"changelog/#076","title":"0.7.6","text":"<p>2025-11-17</p> <ul> <li>Fix: Record IC lookups for merged supertypes to graph extensions.</li> <li>Fix: Optimize <code>checkScope()</code> diagnostics in errors by checking if roots are empty first.</li> <li>Fix: Fix diagnostic when an <code>@Multibinds</code>-annotated Map uses an enum as a key.</li> <li>Fix: Fix Dagger interop error messages when validating <code>@Module</code>s with constructor-injected fields to match errors for <code>@BindingContainer</code>s.</li> <li>Fix: Catch <code>IrErrorType</code> error types earlier when generating missing binding hints.</li> <li>Fix: Fix IC edge case when restoring a deleted contributed binding container.</li> <li>Update shaded Okio to <code>3.16.3</code>.</li> <li>Build against Gradle <code>9.2.1</code>.</li> </ul> <p>Special thanks to @jonamireh, @neworld, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#075","title":"0.7.5","text":"<p>2025-11-07</p> <ul> <li>New: Add Guice interop. This is largely focused on Guice\u2019s <code>Provider</code> type, annotations, and existing interop with jakarta.inject annotations. <pre><code>metro {\n  includeGuice()\n}\n</code></pre></li> <li>Enhancement: Improve IR caching layer with supertype caching.</li> <li>Enhancement: Add diagnostic to check for <code>Array</code> properties in map key annotations that unwrap values.</li> <li>Enhancement: Add diagnostic to check multibinds map keys are valid (primitives, strings, <code>KClass</code>, annotation classes, not arrays).</li> <li>Enhancement: Improve multibinding star project checks.</li> <li>Enhancement: Nudge <code>@Binds</code> functions toward <code>private</code> visibility like <code>@Provides</code> functions now that it\u2019s fully supported.</li> <li>Fix: Don\u2019t treat <code>l</code> as an illegal char in name allocating. This was supposed to be <code>;</code>.</li> <li>Fix: Ensure all reserved properties by child graphs get properties in parents. Previously, there were some cases for bindings that were unused in the parent and otherwise did not meet the criteria for having a backing property would get missed in binding property collection.</li> <li>Fix: Fix compiler crash when injecting a target type with star generics.</li> <li>Fix: Fix <code>ClassCastException</code> when accessing a <code>Provider</code> contributed from a <code>dagger.Module</code>.</li> <li>Split <code>javax</code> and <code>jakarta</code> interop APIs into separate artifacts from dagger for reuse.</li> </ul> <p>Special thanks to @jonamireh for contributing to this release!</p>"},{"location":"changelog/#074","title":"0.7.4","text":"<p>2025-11-04</p> <ul> <li>Fix: Support more than 32 parameters to Graph factories.</li> <li>Fix: Support more than 32 accessors in Graphs.</li> <li>Fix: Transform <code>INSTANCE</code> access types for <code>GraphDependency</code> bindings.</li> <li>Fix: Fix ordering of setter member injection parameters when reading injectors across modules.</li> <li>[change] When generating reports, create directory structures matching packages rather than generating all to one top-level dir.</li> </ul> <p>Special thanks to @jonamireh, @kevinguitar, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#073","title":"0.7.3","text":"<p>2025-11-02</p> <ul> <li>New: Support interop with Dagger/Anvil-generated member injector classes.</li> <li>Enhancement: Skip reading members when loading externally compiled member injector classes. Parameters are now computed from their static <code>inject*</code> functions.</li> <li>Enhancement: Improve logic for avoiding reserved keywords or illegal character for names in more platforms.</li> <li>Enhancement: Inline empty multibinding expressions in code gen.</li> <li>Enhancement: Better detect static-ish functions in generated Kotlin factories from Dagger/Anvil interop.</li> <li>Enhancement: Cache members injector binding lookups.</li> <li>Enhancement: Don\u2019t double-lookup members injectors already computed from roots.</li> <li>Enhancement: Support Kotlin <code>2.3.0-Beta2</code>.</li> <li>Enhancement: Test against Kotlin <code>2.2.21</code>.</li> <li>Enhancement: Improve generated graph impl declaration checks.</li> <li>Fix: Work around \u201cLookupSymbols are not yet converted to ProgramSymbols\u201d issue (KT-80412) in incremental compilation by avoiding using <code>$$</code> prefixes in generated class names.</li> <li>Fix: Fix interop support for two layers of <code>Provider</code> interop in map multibindings (i.e. <code>Provider&lt;Map&lt;Key, Provider&lt;Value&gt;&gt;</code>).</li> <li>Deprecate <code>includeAnvil()</code> Gradle DSL function in favor of more specific <code>includeAnvilForDagger()</code> and <code>includeAnvilForKotlinInject()</code> functions.</li> <li>Move interop annotations controls to compiler. For Gradle users, there\u2019s mostly no change (other than the above). For users of any other build system, this makes it a bit easier to reuse the interop annotations logic.</li> <li>[docs] Add compatibility docs: https://zacsweers.github.io/metro/latest/compatibility/. Metro supports a moving range of Kotlin versions, this page captures the tested versions for each release.</li> <li>[docs] Add stability docs: https://zacsweers.github.io/metro/latest/stability/</li> </ul> <p>Special thanks to @jonamireh, @hossain-khan, and @l2hyunwoo for contributing to this release!</p>"},{"location":"changelog/#072","title":"0.7.2","text":"<p>2025-10-22</p> <ul> <li>Fix: Fix eager initialization of some bindings going into multibindings.</li> <li>Fix: Fix injection of <code>Lazy</code>-wrapped multibindings.</li> </ul>"},{"location":"changelog/#071","title":"0.7.1","text":"<p>2025-10-21</p> <p>\ud83d\udea8 This release has a severe bug in multibinding code gen, please use 0.7.2 instead!</p> <ul> <li> <p>New: Add missing dependency hints for missing bindings errors <pre><code>[Metro/MissingBinding] Cannot find an @Inject constructor or @Provides-annotated function/property for: FooImpl\n\n    FooImpl is injected at\n        [AppGraph] Bindings.bind: FooImpl\n    Base is requested at\n        [AppGraph] AppGraph.base\n\n(Hint)\n'FooImpl' doesn't appear to be visible to this compilation. This can happen when a binding references a type from an 'implementation' dependency that isn't exposed to the consuming graph's module.\nPossible fixes:\n- Mark the module containing 'FooImpl' as an 'api' dependency in the module that defines 'Bindings' (which is requesting it).\n- Add the module containing 'FooImpl' as an explicit dependency to the module that defines 'AppGraph'.\n</code></pre></p> </li> <li> <p>Enhancement: Improve code generation around multibinding collection builders and contributors, using more lazy getters in graph code gen.</p> </li> <li>Enhancement: Short-circuit empty map providers to <code>emptyMap()</code>.</li> <li>Enhancement: Support default values for assisted parameter arguments in top-level function injection.</li> <li>Enhancement: Allow using <code>@Contributes*</code> annotations on assisted factories with <code>contributesAsInject</code> enabled.</li> <li>Enhancement: Allow <code>@OptionalBinding</code> annotation to be customizable/replaceable.</li> <li>Change: Deprecate <code>@OptionalDependency</code> in favor of <code>@OptionalBinding</code>. Same behavior, just a slightly more consistent name.</li> <li>Fix: Compute <code>Optional</code> instance lazily when requested as a <code>Provider&lt;Optional&lt;T&gt;&gt;</code> and the underlying optional is not empty. Only applies to <code>@BindsOptionalOf</code> interop.</li> <li>Fix: Don\u2019t generate duplicate <code>init()</code> functions when chunking initializers if graphs already have an explicit <code>init()</code> function.</li> <li>Fix: Fix support for assisted inject with no assisted params.</li> <li>Fix: Detect platform types in just the <code>kotlin</code> package. Previously it missed any that didn\u2019t have multiple package segments.</li> <li>Fix: Align unused context parameter special names on Kotlin 2.3.x.</li> <li>Remove <code>2.3.0-dev-7984</code> compat (superseded by <code>2.3.0-Beta1</code>).</li> </ul> <p>Special thanks to @Lavmee, @kevinguitar, and @jackwilsdon for contributing to this release!</p>"},{"location":"changelog/#070","title":"0.7.0","text":"<p>2025-10-17</p>"},{"location":"changelog/#dynamic-graphs","title":"Dynamic Graphs","text":"<p>Dynamic graphs are a powerful new feature of the Metro compiler that allows for dynamically replacing bindings in a given graph. To use them, you can pass in a vararg set of binding containers to the <code>createDynamicGraph()</code> and <code>createDynamicGraphFactory()</code> intrinsics.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(): String = \"real\"\n}\n\nclass AppTest {\n  val testGraph = createDynamicGraph&lt;AppGraph&gt;(FakeBindings)\n\n  @Test\n  fun test() {\n    assertEquals(\"fake\", testGraph.message)\n  }\n\n  @BindingContainer\n  object FakeBindings {\n    @Provides fun provideMessage(): String = \"fake\"\n  }\n}\n</code></pre> <p>This is particularly useful for tests. See their docs for more information: Dynamic Graphs.</p> <p>This API is experimental and may change in the future, please report any issues you encounter!</p>"},{"location":"changelog/#implicit-inject-behavior-on-most-contributes-annotated-types","title":"Implicit <code>@Inject</code> behavior on (most) <code>@Contributes*</code>-annotated types","text":"<p>Up to this point, Metro has always required you to use <code>@Inject</code> on most <code>@Contributes*</code> annotated types. However, this can feel a bit repetitive and tedious. In this release, there is a new <code>contributesAsInject</code> option that can be enabled that will treat all <code>@Contributes*</code> annotated types as <code>@Inject</code> by default. You can still use <code>@Inject</code> on classes to be explicit, and if you have multiple constructors you must still use <code>@Inject</code> on the constructor you want to be used.</p> <p>The only exception to this is <code>@ContributesTo</code>, which isn\u2019t applicable to injected types.</p> <p>This is disabled by default to start but will likely become the default in a future release.</p> <pre><code>@ContributesBinding(AppScope::class)\n// @Inject // &lt;-- now implicit!\nclass TacoImpl(...) : Taco\n</code></pre>"},{"location":"changelog/#other-changes","title":"Other Changes","text":"<ul> <li>Behavior change: Remove <code>assistedInjectMigrationSeverity</code> DSL. You must now move fully to using <code>@AssistedInject</code> annotations for assisted types.</li> <li>New: Allow exposing assisted-injected classes on a graph with qualifier annotations via <code>@Provides</code> declarations. This means you could, for example, write a provider like so: <pre><code>@Provides @Named(\"qualified\")\nfun provideTaco(factory: Taco.Factory): Taco = factory.create(\"spicy\")\n</code></pre></li> <li>New: Add diagnostic disallowing qualifier annotations directly on <code>@AssistedInject</code>-annotated classes.</li> <li>New: Add <code>wasmWasi</code> targets to Metro\u2019s runtime.</li> <li>New: Add diagnostic to report positional arguments use in custom interop annotations. See the interop docs for more information. This is disabled by default but can be configured via the <code>interopAnnotationsNamedArgSeverity</code> option.</li> <li>New: Support context parameters on top-level injected functions. See the docs for more information.</li> <li>New: Improve diagnostic checks around binding container arguments to annotations and graph creators.</li> <li>New: Add a diagnostic to warn on suspicious injection of unqualified object classes.</li> <li>Enhancement: Add diagnostic for providing a constructor-injected class with a different scope than the class (if the class has a scope).</li> <li>Enhancement: Allow replacing/excluding binding containers by <code>@Origin</code> annotations.</li> <li>Fix: Don\u2019t use interoped annotation arguments at matching indices if their name does not match the requested name.</li> <li>Fix: Trace all member injection dependencies from supertypes in graph reachability computation.</li> <li>Fix: Use compat <code>getContainingClassSymbol()</code> (fixes Kotlin 2.3.0-x compatibility).</li> <li>Fix: Better escape field names to be valid in JVM.</li> <li>Fix: Don\u2019t double-invoke <code>Optional</code> binding fields.</li> <li>Fix: Don\u2019t report duplicate bindings if injectors for both a parent and child class are present on a graph.</li> <li>Fix: Look up correct target class ID for computed member injectors in <code>BindingLookup</code>.</li> <li>Fix: Don\u2019t allow binding containers to be <code>inner</code> classes.</li> <li>Fix: Don\u2019t allow binding containers to be local classes.</li> <li>Fix: Don\u2019t allow binding containers to be anonymous objects.</li> <li>Fix: Fix wrong parent graph name in <code>IncompatiblyScopedBindings</code> hint.</li> <li>Fix: Fix replacements for regular contributed types not getting processed in graph extensions.</li> <li>Fix: Don\u2019t re-process contribution merging for generated graph extension impls during graph node creation.</li> <li>Fix: Don\u2019t reserve provider fields for custom wrapper types like interoped <code>Optional</code> types, avoiding accidental eager initialization in cycles.</li> <li>Change the warning key for redundant provides to more specific <code>REDUNDANT_PROVIDES</code>.</li> </ul> <p>Special thanks to @erawhctim and @CharlieTap for contributing to this release!</p>"},{"location":"changelog/#0610","title":"0.6.10","text":"<p>2025-10-11</p>"},{"location":"changelog/#optional-dependency-behaviors","title":"Optional Dependency Behaviors","text":"<p>Graph accessors can now expose optional dependencies, just use <code>@OptionalDependency</code> on the accessor. Note that the accessor must declare a default body that Metro will use if the dependency is absent.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  @OptionalDependency\n  val message: String\n    get() = \"Absent!\"\n}\n</code></pre> <p>There are a couple of optional configuration for Metro\u2019s optional dependency support that can be configured via the <code>optionalDependencyBehavior</code> Gradle DSL:</p> <ul> <li><code>DISABLED</code> - Disallows optional dependencies entirely.</li> <li><code>REQUIRE_OPTIONAL_DEPENDENCY</code> - Requires optional dependency parameters to also be annotated with <code>@OptionalDependency</code>. This may be preferable for consistency with accessors and/or explicitness.</li> <li><code>DEFAULT</code> - The default behavior as described above \u2014 accessors must be annotated with <code>@OptionalDependency</code> with default bodies and parameters just use default value expressions.</li> </ul>"},{"location":"changelog/#other-changes_1","title":"Other changes","text":"<ul> <li>New: Add interop for Dagger <code>@BindsOptionalOf</code>. Note this is currently only limited to <code>java.util.Optional</code>.</li> <li>Enhancement: Improve error messages for unexpected <code>IrErrorType</code> encounters.</li> <li>Enhancement: Add configurable <code>statementsPerInitFun</code> to option to control the number of statements per init function. Only for advanced/debugging use.</li> <li>Fix: Allow <code>@Includes</code> types themselves (i.e., not their accessors) to be dependencies in generated graphs.</li> <li>Fix: Allow multiple graph extension factory accessors of the same factory type on parent graphs.</li> <li>Fix: Report all missing <code>@Provides</code> body diagnostics rather than returning early.</li> <li>Fix: Allow <code>open</code> members from abstract graph class superclasses to be accessors.</li> <li>Fix: When detecting default function/property getter bodies in graph accessors, check for <code>open</code> modality as well.</li> <li>Fix: Don\u2019t duplicate includes accessor keys across multiple parent context levels.</li> <li>Fix: Fix not respecting ref counting when allocating provider fields for constructor-injected class providers. This should reduce generated graph code size quite a bit.</li> </ul> <p>Special thanks to @ChristianKatzmann for contributing to this release!</p>"},{"location":"changelog/#069","title":"0.6.9","text":"<p>2025-10-07</p> <p>This release introduces new experimental support for multiple compiler and IDE versions. The primary goal of this is to better support running Metro\u2019s FIR extensions across different IntelliJ Kotlin Plugin versions and make IDE support more robust, and general compiler compatibility falls out of that more or less for free. This is experimental and only going to target forward compatibility.</p> <ul> <li>New: Report more IR errors up to a maximum. The default is <code>20</code>, but is configurable via the <code>maxIrErrors</code> Gradle DSL option. If you want to restore the previous \u201cfail-fast\u201d behavior, you can set this value to <code>1</code>.</li> <li>New: Generate specific containing names in Kotlin 2.3.0+ when generating top-level functions for hint gen.</li> <li>Behavior change: Assisted-inject types can only be directly exposed on a graph if qualified.</li> <li>Behavior change: Update the Gradle plugin to target Kotlin 2.0, which requires Gradle <code>8.11</code> or later.</li> <li>Enhancement: Improve compatibility across 2.2.20 and 2.3.0+ releases. This release should be compatible with both!</li> <li>Enhancement: Add diagnostic for directly injecting unqualified assisted-injected classes rather than using their factories.</li> <li>Enhancement: Add diagnostic mixing <code>Provider</code> and <code>Lazy</code> types for <code>Provider&lt;Lazy&lt;T&gt;&gt;</code> injections.</li> <li>Enhancement: Add diagnostics for custom map keys.</li> <li>Enhancement: Fully allow exposing <code>Provider&lt;Lazy&lt;T&gt;&gt;</code> accessor types.</li> <li>Enhancement: Significantly improve duplicate binding error message rendering.</li> <li>Enhancement: Inline internal <code>trace</code> functions to reduce overhead.</li> <li>Enhancement: Don\u2019t always generate fields for <code>MembersInjector</code> bindings.</li> <li>Enhancement: Improve formatting of long cycles in <code>DependencyCycle</code> error messages.</li> <li>Enhancement: Improve formatting of aliases in <code>DependencyCycle</code> error messages. Aliases are now indicated with <code>~~&gt;</code> arrows instead of <code>--&gt;</code>.</li> <li>Enhancement: Improve formatting of member declarations in error messages for better IDE linking (if in the IDE terminal/console output) by using <code>.</code> separators instead of <code>#</code>.</li> <li>Fix: Avoid obscure <code>UnsupportedOperationException</code> failures when reporting missing bindings.</li> <li>Fix: Only generate assisted factories if <code>@AssistedInject</code> annotations are used on the target class.</li> <li>Fix: Remove <code>PsiElement</code> shading workaround when reporting diagnostics.</li> <li>Fix: Treat <code>MembersInjector</code> types as implicitly deferrable in binding graph validation.</li> <li>Fix: Report cycles in form of <code>binding --&gt; dependency</code> rather than the reverse for better readability.</li> </ul> <p>Special thanks to @kevinguitar, @hossain-khan, and @vRallev for contributing to this release!</p>"},{"location":"changelog/#068","title":"0.6.8","text":"<p>2025-09-26</p> <ul> <li>Fix: Preserve original nullability when canonicalizing generic types.</li> </ul>"},{"location":"changelog/#067","title":"0.6.7","text":"<p>2025-09-25</p>"},{"location":"changelog/#new-assistedinject-annotation","title":"New <code>@AssistedInject</code> annotation","text":"<p>Assisted-injected classes must now use <code>@AssistedInject</code> instead of <code>@Inject</code>.</p> <p>This is for multiple reasons:   - It\u2019s more explicit at the source declaration site that this uses assisted injection and cannot be requested directly on the DI graph. This is particularly useful for scenarios where there no assisted parameters but you still want to use assisted injection.   - This will allow adding more granular checks at compile-time to validate use-sites.   - This will allow providing assisted types directly on the graph.   - Will simplify some of Metro\u2019s internal logic.</p> <p>Note that not all internal changes are implemented yet to allow for a migration period. In this release, use of <code>@Inject</code> with <code>@Assisted</code> parameters is a compiler warning and will become an error in the future. This diagnostic is configurable via the <code>assistedInjectMigrationSeverity</code> Gradle DSL option.</p>"},{"location":"changelog/#other-changes_2","title":"Other changes","text":"<ul> <li>New: Support for interop with externally generated Dagger modules.</li> <li>Enhancement: Always check for available assisted factories when reporting <code>InvalidBinding</code> errors about misused assisted injects.</li> <li>Enhancement: Always specifically report mismatched assisted parameter mismatches.</li> <li>Enhancement: Validate <code>Lazy</code> assisted factory injections in more places.</li> <li>Enhancement: Allow private <code>@Binds</code> properties.</li> <li>Enhancement: Better canonicalize flexible mutability from Dagger interop in collections and flexible nullability.</li> <li>Enhancement: Better canonicalize flexible nullability from Dagger interop in generic type arguments.</li> <li>Enhancement: Simplify assisted factory impl class generation by moving it entirely to IR.</li> <li>Enhancement: Allow qualifier narrowing but not widening on graph accessor types. Essentially, you can have a base interface with an unqualified accessor and then override that to add a qualifier in a subtype, but not the other way around.</li> <li>Fix: Register <code>MetroDiagnostics</code> in FIR.</li> <li>Fix: Use correct severity when reporting warnings to <code>MessageCollector</code> from newer IR diagnostics factories.</li> <li>Fix: When transforming FIR override statuses, check all supertypes and not just immediate supertype.</li> <li>Fix: Carry qualifiers over from Dagger inject constructors when interoping with dagger factories.</li> <li>If Dagger runtime interop is enabled, do not run status transformation on <code>@Provides</code> declarations in dagger modules.</li> </ul> <p>Special thanks to @kevinguitar, @ChristianKatzmann, and @hossain-khan for contributing to this release!</p>"},{"location":"changelog/#066","title":"0.6.6","text":"<p>2025-09-11</p> <ul> <li>Enhancement: Optimize annotation lookups in some places in IR.</li> <li>Fix: If a graph declares an overridable declaration that matches one of a contributed supertype, transform it to add the requisite <code>override</code> modifier.<ul> <li>All that is to say, this code now works <pre><code>@ContributesTo(AppScope::class)\ninterface StringRequester {\n  val string: String\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val string: String // &lt;-- previously failed to compile due to missing override\n}\n</code></pre></li> </ul> </li> <li>Update to Kotlin <code>2.2.20</code>. This release requires <code>2.2.20</code> or later. See the compatibility docs.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#065","title":"0.6.5","text":"<p>2025-09-11</p> <ul> <li>New: Add <code>@Origin</code> annotation for custom code generators to link origin classes. See the docs.</li> <li>Fix: Fix wrong <code>IrType</code> for default value expressions wrapped in <code>Provider</code>.</li> </ul> <p>Special thanks to @ChristianKatzmann, @KevinGuitar, and @hossain-khan for contributing to this release!</p>"},{"location":"changelog/#064","title":"0.6.4","text":"<p>2025-09-01</p> <ul> <li>Enhancement: Transform and collect contribution data in a single pass during IR.</li> <li>Fix: Ensure contributed binding containers\u2019 included containers are available in root dependency graphs.</li> <li>Fix: Make <code>@Includes</code> parameter keys available to extensions.</li> <li>Fix: Fix an edge case where an included binding container that\u2019s transitively included by another container is seen to have zero bindings.</li> <li>Fix: Report diagnostic errors to check that binding containers don\u2019t extend other binding containers.</li> <li>Fix: Report diagnostic errors if accessors or injectors have conflicting qualifiers in overridden functions.</li> <li>Fix: Report diagnostic errors if an injector function does not return <code>Unit</code>.</li> </ul> <p>Special thanks to @joelwilcox, @vRallev, @kevinguitar, and @erawhctim for contributing to this release!</p>"},{"location":"changelog/#063","title":"0.6.3","text":"<p>2025-08-23</p> <ul> <li>Enhancement: Allow <code>@Includes</code> parameters that are binding containers to transitively include other binding containers.</li> <li>Fix: Ensure provider fields for graph instances when needed by extensions.</li> </ul> <p>Special thanks to @hossain-khan, @vRallev, and @erawhctim for contributing to this release!</p>"},{"location":"changelog/#062","title":"0.6.2","text":"<p>2025-08-22</p> <ul> <li>Enhancement: Add diagnostic for contributed binding containers with no (visible) no-arg constructor.</li> <li>Enhancement: Add hint for missing bindings if the binding appears to be contributed by an <code>internal</code> type in another, non-friend module.</li> <li>Fix: Don\u2019t allocate new fields for deferred bindings reserved by extension graphs.</li> <li>Fix: Allow graph extensions to expose their own factories if inherited from parents.</li> </ul> <p>Special thanks to @KevinGuitar, @hossain-khan and @ChrisBanes for contributing to this release!</p>"},{"location":"changelog/#061","title":"0.6.1","text":"<p>2025-08-20</p> <ul> <li>New: Add a diagnostic to report parent keys used by graph extensions <code>parent-keys-used-*.txt</code>.</li> <li>Enhancement: Graph extensions are now generated as <code>inner</code> classes, reducing much of the necessary generated code in parent graphs and allowing them to access parent binding fields directly.</li> <li>Enhancement: Allow graph extensions to depend on other graph extensions within the context of their parent graph.</li> <li>Enhancement: Add a diagnostic for graph factories with vararg parameters.</li> <li>Enhancement: Allow graph extension factories to participate in the binding graph, which then allows injecting or binding them like any other dependency.</li> <li>Enhancement: Improve error message location accuracy for missing bindings when reporting from a <code>@Binds</code> declaration.</li> <li>Fix: Don\u2019t override graph extension factories\u2019 default functions.</li> <li>Fix: Fix Kotlin internal error overriding Metro error when there\u2019s a missing factory for a Java <code>@Inject</code> class.</li> <li>[Docs] The project website is now versioned. This means you can read the documentation at different versions:</li> <li>Latest release: https://zacsweers.github.io/metro/latest/</li> <li>Snapshots (example): https://zacsweers.github.io/metro/0.7.0-SNAPSHOT/</li> <li>Past release (example): https://zacsweers.github.io/metro/0.6.0/</li> <li>Deprecate the <code>enableStrictValidation</code> Gradle property in favor of <code>enableFullBindingGraphValidation</code>, which aligns with Dagger\u2019s (better) name for the same functionality.</li> <li>Update Wire to <code>5.3.11</code>.</li> </ul> <p>Special thanks to @hossain-khan and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#060","title":"0.6.0","text":"<p>2025-08-15</p>"},{"location":"changelog/#graph-extensions-are-no-longer-detached","title":"Graph extensions are no longer detached.","text":"<p>TL;DR: Metro graph extensions are now wired similar to Dagger subcomponents and use a new <code>@GraphExtension</code> annotation. <code>@Extends</code> and <code>isExtendable</code> are now deleted, <code>@ContributesGraphExtension</code> and <code>enableScopedInjectClassHints()</code> are deprecated.</p> <p>Up to this point, Metro\u2019s graph extensions have been detached. This meant that extensions could simply depend on a parent graph via <code>@Extends</code> and parent graphs had to mark themselves as extendable via <code>isExtendable = true</code>. This approach mirrored kotlin-inject\u2019s approach and was convenient in its flexibility. However, it\u2019s proven too problematic in practice for a few reasons:</p> <ol> <li>Parent graphs have to generate a bunch of extra code for extensions. Namely, scoped providers and any instances of containers/parents they are holding on to need accessors. It also generates extra metadata (metro serializes its own metadata to its types) for separate graphs to read.</li> <li>Because of the above, parent graphs had to opt-in to extension via <code>isExtendable = true</code>.</li> <li>Up to this point, parent graphs always held scoped providers for all <code>@Provides</code> bindings in it or containers, even if they do not use them.</li> <li>Similar to #3, we\u2019ve had to add support for automatic discovery of scoped constructor-injected classes (via <code>enableScopedInjectClassHints()</code>) to ensure they are also held at the appropriate scope.</li> <li>This has ended up causing a lot of headaches because eager validation complicates these in scenarios where you have multiple graphs that may not actually use that class anywhere (and thus not provide some of its dependencies)</li> <li>Because every graph must expose every available binding to unknown extensions, every graph in a chain is often bloated with bindings it doesn\u2019t use.</li> </ol> <p>Metro could optimize the <code>@ContributesGraphExtension</code> cases where Metro\u2019s compiler has a view of the entire graph chain, but that would frankly leave Metro with a lot of edge cases to deal with and users with needing to know about two different ways to extend graphs. We opted against that, and instead are now going to process graph extensions in a similar way to Dagger\u2019s subcomponents.</p> <p>This will allow Metro to</p> <ol> <li>Fully optimize the whole graph chain.</li> <li>Automatically scope bindings in parents (no need to expose accessors for scoped bindings unused in parents).</li> <li>Only generate exactly the bindings that are used in each graph with lazy validation of bindings.</li> </ol>"},{"location":"changelog/#graphextension","title":"<code>@GraphExtension</code>","text":"<p><code>@GraphExtension</code> is a new annotation to denote a graph that is an extension. This is analogous to Dagger\u2019s <code>@Subcomponent</code> and dagger interop treats it as such.</p> <p>To connect an extension to a parent graph, you can do one of multiple ways:</p> <ul> <li>Declare an accessor on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraph: LoggedInGraph\n}\n</code></pre> <ul> <li>(If the extension has a creator) declare the creator on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraphFactory: LoggedInGraph.Factory\n}\n</code></pre> <ul> <li>(If the extension has a creator) make the parent graph implement the creator.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph : LoggedInGraph.Factory\n</code></pre> <ul> <li>Contribute the factory to the parent graph via <code>@ContributesTo</code>.</li> </ul> <pre><code>@GraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n  @ContributesTo(AppScope::class)\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"changelog/#migration","title":"Migration","text":"<p>The following APIs have been removed or deprecated:</p> <ul> <li><code>@Extends</code>. Migrate to <code>@GraphExtension</code>, remove this parameter, and expose the factory in the parent graph API as documented above.</li> <li><code>isExtendable</code> is removed from <code>@DependencyGraph</code> and <code>@ContributesGraphExtension</code>.</li> <li><code>@ContributesGraphExtension</code> is now deprecated and treated like <code>@GraphExtension</code>.</li> <li><code>@ContributesGraphExtension.Factory</code> is deprecated with error severity and requires migration to the new <code>@ContributesTo</code> pattern.</li> <li><code>enableScopedInjectClassHints()</code> is now deprecated and does nothing. It will be removed in the future.</li> <li>Graph extensions may no longer have multiple direct parents.</li> </ul> <p>To create graph extensions, you now must do so via a parent graph (using one of the above connecting mechanisms).</p>"},{"location":"changelog/#other-changes_3","title":"Other changes","text":"<ul> <li>Breaking change: Rename <code>custom-graph</code> compiler option to <code>custom-dependency-graph</code>.</li> <li>Breaking change: Rename <code>custom-dependency-graph-factory</code> compiler option to <code>custom-dependency-graph-factory</code>.</li> <li>Breaking change: Rename <code>MetroPluginExtension.graph</code> gradle extension property to <code>MetroPluginExtension.dependencyGraph</code>.</li> <li>Breaking change: Rename <code>MetroPluginExtension.graphFactory</code> gradle extension property to <code>MetroPluginExtension.dependencyGraphFactory</code>.</li> <li>Behavior change: <code>@Provides</code> and <code>@Binds</code> bindings are now only validated if they are used by the owning graph. Previously, they were always validated.<ul> <li>If you want to keep the previous behavior, you can enable the <code>enableStrictValidation()</code> option.</li> </ul> </li> <li>Behavior change: <code>chunkFieldInits()</code> is now enabled by default.</li> <li>Behavior change: When adding bindings from extended parent graphs, ignore any that are provided directly in the child graph. Previously, Metro only ignored the binding if the binding was itself a graph type.</li> <li>New: Add diagnostic reports for (valid) cycles. This means if you have a cycle in your graph and enable a <code>reportsDestination</code>, Metro will generate files with a list of all the keys in that cycle.</li> <li>Enhancement: In tracing logs, include the graph name in the \u201cTransform dependency graph\u201d sections.</li> <li>Enhancement: Allow contributing annotations on assisted-injected classes.</li> <li>Enhancement: Improve dagger interop with <code>dagger.Lazy</code> types by allowing <code>Provider</code> subtypes to be wrapped too.</li> <li>Enhancement: Support <code>rank</code> interop on Anvil annotations in contributed graph extensions.</li> <li>Enhancement: Support <code>ignoreQualifier</code> interop on Anvil annotations in contributed graph extensions.</li> <li>Enhancement: Only process contributions to the consuming graph\u2019s scopes when processing <code>rank</code> replacements in FIR.</li> <li>Enhancement: Improve error message for invalid assisted inject bindings to injected target.</li> <li>Enhancement: Report similar bindings in missing binding errors where the similar binding doesn\u2019t have a qualifier but the requested binding does. Previously we only reported if the similar binding had a qualifier and the requested binding didn\u2019t.</li> <li>Fix: Don\u2019t link expect/actual declarations if they\u2019re in the same file.</li> <li>Fix: Don\u2019t copy map keys over into generated <code>@Binds</code> contributions unless it\u2019s an <code>@IntoMap</code> binding.</li> <li>Fix: Fall back to annotation sources if needed when reporting errors with bound types in FIR.</li> <li>Fix: Use <code>MapProviderFactory.builder().build()</code> for Dagger interop on <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> types as there is no <code>MapProviderFactory.empty()</code>.</li> <li>Fix: Don\u2019t assume <code>@ContributesGraphExtension</code> to have aggregation scopes during graph generation.</li> <li>Fix: When extending graphs, ignore bindings of the same type as the inheriting graph.</li> <li>Fix: Propagate parent graph empty <code>@Multibinds</code> declarations to extensions.</li> <li>Fix: Propagate managed binding containers to extension graphs.</li> <li>Fix: Propagate transitively included binding containers contributed to contributed graphs (sorry, word soup).</li> <li>Fix: Make generated multibinding element IDs stable across compilations.</li> <li>Fix: Handle location-less declarations when reporting invalid assisted inject bindings.</li> <li>Fix: Don\u2019t chunk parent graph validation statements as these must be in the original constructor body.</li> <li>Fix: Fix wrong receiver context for chunked field initializers.</li> <li>Fix: Fix support for generic private injected constructors.</li> <li>[internal change] Simplify metadata and just use accessor annotations.</li> <li>[internal change] Graph extension impls are now generated as nested classes within the generated metro graph that they are contributed to.</li> <li>Update to Kotlin <code>2.2.10</code>.</li> </ul> <p>Special thanks to @hossain-khan, @Egorand, @kevinguitar, @jonapoul, and @martinbonnin for contributing to this release!</p>"},{"location":"changelog/#055","title":"0.5.5","text":"<p>2025-08-02</p> <ul> <li>Fix: Fix Wire shading in native targets.</li> </ul>"},{"location":"changelog/#054","title":"0.5.4","text":"<p>2025-08-01</p> <ul> <li>Enhancement: Support <code>excludes</code>, <code>bindingContainers</code>, and <code>additionalScopes</code> in <code>@ContributesGraphExtension</code>.</li> <li>Enhancement: Allow binding containers and regular contributed classes to replace each other in contribution merging.</li> <li>Enhancement: Allow <code>@ElementsIntoSet</code> on properties.</li> <li>Enhancement: Don\u2019t run FIR extensions on Java sources.</li> <li>Fix: Report incompatible scopes in nested contributed graphs to <code>MessageCollector</code> until Kotlin 2.2.20.</li> <li>Fix: Report binding issues from externally contributed graphs to <code>MessageCollector</code> until Kotlin 2.2.20.</li> <li>Fix: Preserve nullability when remapping type parameters.</li> <li>Fix: Don\u2019t double-add <code>@ContributesTo</code> contributions while merging contributed graphs.</li> <li>Fix: Check <code>rawStatus</code> for overrides when merging contributed supertypes.</li> <li>Fix: Correctly extract the element type when creating implicit <code>Set</code> multibindings from <code>@ElementsIntoSet</code> contributors.</li> <li>Fix: Check <code>additionalScopes</code> when merging binding containers too.</li> <li>Fix: Don\u2019t fail if multiple contributing annotations on binding containers match the target scope when aggregating them.</li> <li>Fix: Dedupe binding containers during graph node generation.</li> <li>Fix: Add a checker for <code>@Provides</code> constructor parameters in binding containers.</li> <li>Fix: Fix reading repeated external contributed annotations.</li> <li>Fix: Filter by matching scopes when merging contributed types with repeated annotations.</li> </ul> <p>Special thanks to @hossain-khan, @gabrielittner, @kevinguitar, @JoelWilcox, and @martinbonnin for contributing to this release!</p>"},{"location":"changelog/#053","title":"0.5.3","text":"<p>2025-07-28</p> <ul> <li>Behavior change: The <code>enableScopedInjectClassHints</code> option is no longer enabled by default. This option is tricky to get right and will be iterated on further in #764.</li> <li>Enhancement: Generate synthetic <code>$$BindsMirror</code> classes to\u2026<ul> <li>support full IC compatibility with changing annotations and return types on <code>@Binds</code> and <code>@Multibinds</code> declarations</li> <li>allow these declarations to be <code>private</code></li> </ul> </li> <li>Enhancement: Allow <code>@Binds</code> and <code>@Multibinds</code> functions to be private.</li> <li>Enhancement: Allow \u201cstatic graphs\u201d via companions implementing the graph interface itself.</li> <li>Enhancement: Allow graphs to aggregate <code>internal</code> contributions from other compilations IFF those compilations are marked as friend paths. This mainly allows for test graphs to consume contributions from their corresponding main source sets.</li> <li>Enhancement: Allow <code>internal</code> graphs to extend <code>internal</code> contributed interfaces from other compilations IFF those compilations are marked as friend paths.</li> <li>Fix: Sort soft edges before hard edges within (valid) cycles. Previously we would just apply a standard topological sort here, but in this scenario we want to add extra weight to ready-up nodes that depend directly on the deferred type being used to break the cycle first.</li> <li>Fix: When recording IC lookups of overridable declarations, only record the original declaration and not fake overrides.</li> <li>Fix: Record IC lookups to <code>@Multibinds</code> declarations.</li> <li>Fix: Write <code>@Multibinds</code> information to metro metadata.</li> <li>Fix: Always write metro metadata to <code>@BindingContainer</code> classes, even if empty.</li> <li>Fix: When <code>@Includes</code>-ing other graphs, link against the original interface accessor rather than the generated <code>$$MetroGraph</code> accessor.</li> <li>Fix: Disambiguate contributed nullable bindings from non-nullable bindings.</li> <li>Fix: When computing <code>@Includes</code> graph dependencies from accessors, only consider directly included graphs and not transitively included graphs.</li> <li>Fix: Expose <code>@Includes</code> graph dependencies as synthetic <code>_metroAccessor</code> types for extended graphs rather than exposing the included graph directly.</li> <li>Fix: Prohibit calling <code>.asContribution()</code> on <code>@ContributesGraphExtension</code>-annotated types. <code>@ContributesGraphExtension</code>-annotated types cannot be validated at compile-time with this function as their generated class is definitionally contextual and the compiler cannot infer that from callsites of this function alone.</li> <li>Fix: Only process <code>@DependencyGraph</code> types in FIR supertype generation. Contributed graph extension supertypes are merged only in IR.</li> <li>Fix: Generate <code>$$MetroContribution</code> binds functions before aggregating contributions.</li> <li>Fix: Don\u2019t short-circuit class visiting in contribution visiting in IR.</li> <li>Fix: Propagate property annotations for <code>@Provides</code>-properties, previously only the accessor function annotations were being included.</li> <li>Fix: Propagate class annotations for <code>@Inject</code>-annotated constructors to factory class mirror functions, previously only the constructor\u2019s annotations were being included.</li> <li>Fix: Fix dispatch receiver for <code>DelegateFactory</code> fields when <code>chunkFieldInits</code> is enabled.</li> <li>Fix: Fix compilation error for members-injected classes with no direct, but only inherited <code>@Inject</code> attributes.</li> <li>Fix: Always look up member injectors of ancestor classes of classes member-injected by graphs (sorry, word soup I know).</li> <li>Fix: Ensure <code>$$MetroContribution</code> interfaces are not generated for binding containers by ensuring binding container annotations are readable during their generation.</li> <li>Change to <code>UnsupportedOperationException</code> for compiler intrinsic stubs, matching what the stdlib does.</li> <li>Add a <code>ViewModel</code> assisted injection example to <code>compose-navigation-app</code> sample.</li> <li>Small improvements to the doc site (404 page, favicon, etc.)</li> </ul> <p>Special thanks to @hossain-khan, @bnorm, @yschimke, @kevinguitar, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#052","title":"0.5.2","text":"<p>2025-07-21</p> <ul> <li>Enhancement: De-dupe contributions before processing in contributed graphs.</li> <li>Fix: Don\u2019t extend contributed binding container classes in generated contributed graphs.</li> <li>Small doc fixes.</li> </ul> <p>Special thanks to @bnorm and @alexvanyo for contributing to this release!</p>"},{"location":"changelog/#051","title":"0.5.1","text":"<p>2025-07-18</p> <ul> <li>Breaking change: Rename the <code>generateHintProperties</code> Gradle DSL property to <code>generateContributionHints</code>.</li> <li>Enhancement: Chunk field initializers and constructor statements across multiple init functions to avoid <code>MethodTooLargeException</code> in large graphs. This is currently experimental and gated behind the <code>chunkFieldInits()</code> Gradle DSL.</li> <li>Enhancement: Mark generated factories and member injectors\u2019 constructors as <code>private</code>, matching the same change in Dagger 2.57.</li> <li>Enhancement: Add a new Metro option <code>warnOnInjectAnnotationPlacement</code> to disable suggestion to lift @Inject to class when there is only one constructor, the warning applies to constructors with params too.</li> <li>Fix: Fix <code>@Contributes*.replaces</code> not working if the contributed type is in the same compilation but a different file.</li> <li>Fix: Fix generated <code>MembersInjector.create()</code> return types\u2019 generic argument to use the target class.</li> <li>Fix: Don\u2019t generated nested MetroContribution classes for binding containers.</li> <li>Fix: Fix contributing binding containers across compilations.</li> </ul> <p>Special thanks to @kevinguitar and @ChristianKatzmann for contributing to this release!</p>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>2025-07-14</p> <ul> <li>New: Experimental support for \u201cbinding containers\u201d via <code>@BindingContainer</code>. See their docs for more details.</li> <li>New: Add <code>keys-scopedProviderFields-*.txt</code> and <code>keys-providerFields-*.txt</code> reports to see generated field reports for graphs.</li> <li>Enhancement: Remove <code>Any</code> constraint from <code>binding&lt;T&gt;()</code>, allowing bindings to satisfy nullable variants.</li> <li>Enhancement: Add diagnostic to check for scoped <code>@Binds</code> declarations. These are simple pipes and should not have scope annotations.</li> <li>Enhancement: Move graph dependency cycle checks to earlier in validation.</li> <li>Enhancement: When using Dagger interop, default <code>allowEmpty</code> to true when using Dagger\u2019s <code>@Multibinds</code> annotation.</li> <li>Enhancement: Make Dagger interop providers/lazy instances a <code>dagger.internal.Provider</code> internally for better compatibility with Dagger internals. Some dagger-generated code assumes this type at runtime.</li> <li>Enhancement: Support javax/jakarta <code>Provider</code> types as multibinding Map value types when Dagger interop is enabled.</li> <li>Enhancement: Completely skip processing local and enum classes as they\u2019re irrelevant to Metro\u2019s compiler.</li> <li>Enhancement: When reporting <code>@Binds</code> declarations in binding stacks, report the original declaration rather than inherited fake overrides.</li> <li>Enhancement: Add interop support for kotlin-inject\u2019s <code>@AssistedFactory</code> annotations.</li> <li>Enhancement: Add diagnostic to check for graph classes directly extending other graph classes. You should use <code>@Extends</code>.</li> <li>Enhancement: Add diagnostic to check for <code>@Assisted</code> parameters in provides functions.</li> <li>Enhancement: Add diagnostic to check duplicate <code>@Provides</code> declaration names in the same class.</li> <li>Fix: Within (valid) cycles, topographically sort bindings within the cycle. Previously these would fall back to a deterministic-but-wrong alphabetical sort.</li> <li>Fix: Handle enum entry arguments to qualifier, scope, and map key annotations.</li> <li>Fix: Report the original location of declarations in fake overrides in error reporting.</li> <li>Fix: Handle default values on provides parameters with absent bindings during graph population.</li> <li>Fix: Don\u2019t try to read private accessors of <code>@Includes</code> parameters.</li> <li>Fix: Don\u2019t quietly stub accessors for missing <code>Binding.Provided</code> bindings.</li> <li>Fix: Check constructor-annotated injections when discovering scoped classes in parent graphs.</li> <li>Fix: Fix <code>BaseDoubleCheck.isInitialized()</code>.</li> <li>Fix: Gracefully fall back to <code>MessageCollector</code> for graph seal and contributed graph errors on sourceless declarations.</li> <li>Fix: Fix supporting overloads of binds functions from parent graphs or external supertypes.</li> <li>Fix: Fix generating binding functions with names that contain dashes.</li> <li>Fix: Treat interop\u2019d Dagger/Anvil/KI components as implicitly extendable.</li> <li>Fix: Record lookups of <code>@Binds</code> declarations for IC.</li> <li>Fix: Record lookups of generated class factories and their constructor signatures for IC.</li> </ul> <p>Special thanks to @kevinguitar, @gabrielittner, @chrisbanes, @yschimke, and @ajarl for contributing to this release!</p>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>2025-06-23</p> <ul> <li>New: Injected constructors may now be private. This can be useful for scenarios where you want <code>@Inject</code>-annotated constructors to only be invokable by Metro\u2019s generated code.</li> <li>New: If reporting is enabled, write unused bindings diagnostics to <code>keys-unused-*.txt</code>.</li> <li>New: Support for generic assisted injection.</li> <li>New: Support for generic member injection.</li> <li>New: Add diagnostic to prohibit type parameters on injected member functions.</li> <li>Enhancement: Enable child graphs to depend on parent-scoped dependencies that are unused and not referenced in the parent scope. This involves generating hints for scoped <code>@Inject</code> classes and is gated on a new Metro option <code>enableScopedInjectClassHints</code>, which is enabled by default.</li> <li>Enhancement: Check for context parameters in top-level function injection checker.</li> <li>Enhancement: Store member injection info in metro metadata to slightly optimize member injection code gen.</li> <li>Enhancement: Avoid writing providers fields in graphs for unused bindings.</li> <li>Enhancement: Improve missing binding trace originating from root member injectors.</li> <li>Fix: Fix support for generic injected constructor parameters.</li> <li>Fix: Fix support for repeated contributes annotations by moving contribution binding function generation to IR.</li> <li>Fix: Ensure scope/qualifier annotation changes on constructor-injected classes dirty consuming graphs in incremental compilation.</li> <li>Fix: Report member injection dependencies when looking up constructor-injected classes during graph population.</li> <li>Fix: Disable IR hint generation on JS targets too, as these now have the same limitation as native/WASM targets in Kotlin 2.2. Pending upstream support for generating top-level FIR declarations in KT-75865.</li> <li>Fix: Ensure private provider function annotations are propagated across compilation boundaries.</li> <li>Fix: Substitute copied FIR type parameter symbols with symbols from their target functions.</li> <li>Fix: Improved support for generic member injection.</li> <li>Fix: Propagate qualifiers on graph member injector functions.</li> <li>Fix: Fix support for requesting <code>MembersInjector</code> types.</li> <li>[internal] Report IR errors through <code>IrDiagnosticReporter</code>.</li> <li>[internal] Significantly refactor + simplify IR parameter handling.</li> <li>Fix publishing Apple native targets in snapshots.</li> <li>Update to Kotlin <code>2.2.0</code>.</li> <li>Update Gradle plugin to target Kotlin language version to <code>1.9</code> (requires Gradle 8.3+).</li> </ul> <p>Special thanks to @kevinguitar, @gabrielittner, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#038","title":"0.3.8","text":"<p>2025-06-16</p> <ul> <li>Enhancement: Disambiguate <code>MetroContribution</code> class names based on scope to better support IC when changing scopes.</li> <li>Enhancement: Minimize deferred types when breaking cycles.</li> <li>Fix: Disallow injection of <code>Lazy&lt;T&gt;</code> where <code>T</code> is an <code>@AssistedFactory</code>-annotated class.</li> <li>Fix: Don\u2019t short-circuit assisted injection validation if only an accessor exists.</li> <li>Fix: Allow cycles of assisted factories to their target classes.</li> <li>Update shaded okio to <code>3.13.0</code>.</li> <li>Update atomicfu to <code>0.28.0</code>.</li> </ul> <p>Special thanks to @kevinguitar, @bnorm, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#037","title":"0.3.7","text":"<p>2025-06-08</p> <ul> <li>Fix: Record lookups of generated static member inject functions for IC.</li> <li>Fix: Dedupe merged overrides of <code>@Includes</code> accessors.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#036","title":"0.3.6","text":"<p>2025-06-06</p> <ul> <li>New: Add new <code>Provider.map</code>, <code>Provider.flatMap</code>, <code>Provider.zip</code>, and <code>Provider.memoize</code> utility APIs.</li> <li>Enhancement: Improve graph validation performance by avoiding unnecessary intermediate sorts (again).</li> <li>Enhancement: Fail eagerly with a clear error message if <code>languageVersion</code> is too old.</li> <li>Enhancement: Validate improperly depending on assisted-injected classes directly at compile-time.</li> <li>Fix: Support constructing nested function return types for provider functions.</li> <li>Fix: Propagate <code>@Include</code> bindings from parent graphs to extension graphs.</li> <li>Fix: Reparent copied lambda default values in IR.</li> <li>[internal] Make internal renderings of <code>IrType</code> more deterministic.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#035","title":"0.3.5","text":"<p>2025-05-31</p> <ul> <li>New: Implement top-level function injection checkers.</li> <li>Change: Disallow top-level function injections to be scoped.</li> <li>Fix: Support type parameters with <code>where</code> bounds.</li> <li>Fix: Support injected class type parameters with any bounds.</li> <li>Fix: Support generic graph factory interfaces.</li> <li>Fix: In the presence of multiple contributing annotations to the same scope, ensure only hint function/file is generated.</li> <li>Fix: Improve shading to avoid packaging in stdlib and other dependency classes.</li> <li>Fix: Revert #483 as it broke some cases we haven\u2019t been able to debug yet.</li> </ul> <p>Special thanks to @gabrielittner and @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#034","title":"0.3.4","text":"<p>2025-05-27</p> <ul> <li>Enhancement: Use a simple numbered (but deterministic) naming for contributed graph classes to avoid long class names.</li> <li>Enhancement: Improve graph validation performance by avoiding unnecessary intermediate sorts.</li> <li>Enhancement: Move binding validation into graph validation step.</li> <li>Enhancement: Avoid unnecessary BFS graph walk in provider field collection.</li> <li>Fix: Fix provider field populating missing types that previously seen types dependent on.</li> </ul> <p>Special thanks to @ChristianKatzmann and @madisp for contributing to this release!</p>"},{"location":"changelog/#033","title":"0.3.3","text":"<p>2025-05-26</p> <ul> <li>Enhancement: Don\u2019t unnecessarily wrap <code>Provider</code> graph accessors.</li> <li>Enhancement: Allow multiple contributed graphs to the same parent graph.</li> <li>Fix: Don\u2019t unnecessarily recompute bindings for roots when populating graphs.</li> <li>Fix: Better handle generic assisted factory interfaces.</li> <li>Fix: Use fully qualified names when generating hint files to avoid collisions.</li> <li>Fix: Support provides functions with capitalized names.</li> <li>Fix: Prohibit consuming <code>Provider&lt;Lazy&lt;...&gt;&gt;</code> graph accessors.</li> <li>[internal] Migrate to new IR <code>parameters</code>/<code>arguments</code>/<code>typeArguments</code> compiler APIs.</li> </ul> <p>Special thanks to @gabrielittner for contributing to this release!</p>"},{"location":"changelog/#032","title":"0.3.2","text":"<p>2025-05-15</p> <ul> <li>Enhancement: Optimize supertype lookups in IR.</li> <li>Fix: Fix generic members inherited from generic supertypes of contributed graphs.</li> <li>Fix: Fix <code>@ContributedGraphExtension</code> that extends the same interface as the parent causes a duplicate binding error.</li> <li>Fix: Fix contributed binding replacements not being respected in contributed graphs.</li> <li>Fix: Fix contributed providers not being visible to N+2+ descendant graphs.</li> <li>Fix: Collect bindings from member injectors as well as exposed accessors when determining scoped provider fields.</li> <li>Fix: Fix a few <code>-Xverify-ir</code> and <code>-Xverify-ir-visibility</code> issues + run all tests with these enabled now.</li> </ul> <p>Special thanks to @bnorm, @gabrielittner, @kevinguitar, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#031","title":"0.3.1","text":"<p>2025-05-13</p> <ul> <li>Enhancement: Rewrite graph resolution using topological sorting to vastly improve performance and simplify generation.</li> <li>Enhancement: Return early once an externally-compiled dependency graph is found.</li> <li>Enhancement: Simplify multibinding contributor handling in graph resolution by generating synthetic qualifiers for each of them. This allows them to participate in standard graph resolution.</li> <li>Enhancement: When there are multiple empty <code>@Multibinds</code> errors, report them all at once.</li> <li>Enhancement: Avoid unnecessary <code>StringBuilder</code> allocations.</li> <li>Fix: Don\u2019t transform <code>@Provides</code> function\u2019s to be private if its visibility is already explicitly defined.</li> <li>Fix: Fix a comparator infinite loop vector.</li> <li>Fix: Fix <code>@ElementsIntoSet</code> multibinding contributions triggering a dependency cycle in some situations.</li> <li>Fix: Fix assertion error for generated multibinding name hint when using both @Multibinds and @ElementsIntoSet for the same multibinding.</li> <li>Fix: Fix contributed graph extensions not inheriting empty declared multibindings.</li> <li>Fix: Ensure we report the <code>@Multibinds</code> declaration location in errors if one is available.</li> <li>Fix: Dedupe overrides by all parameters not just value parameters.</li> <li>Fix: Dedupe overrides by signature rather than name when generating contributed graphs.</li> <li>Fix: Fix accidentally adding contributed graphs as child elements of parent graphs twice.</li> <li>Fix: Fix not deep copying <code>extensionReceiverParameter</code> when implementing fake overrides in contributed graphs.</li> <li>Fix: Report fully qualified qualifier renderings in diagnostics.</li> <li>Fix: Don\u2019t generate provider fields for multibinding elements unnecessarily.</li> <li>When debug logging + reports dir is enabled, output a <code>logTrace.txt</code> to the reports dir for tracing data.</li> <li>Update to Kotlin <code>2.1.21</code>.</li> </ul> <p>Special thanks to @asapha, @gabrielittner, @jzbrooks, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>2025-05-05</p> <ul> <li>New: Add support for <code>@ContributesGraphExtension</code>! See the docs for more info.</li> <li>New: Add a <code>asContribution()</code> compiler intrinsic to upcast graphs to expected contribution types. For example: <code>val contributedInterface = appGraph.asContribution&lt;ContributedInterface&gt;()</code>. This is validated at compile-time.</li> <li>New: Automatically transform <code>@Provides</code> functions to be <code>private</code>. This is enabled by defaults and supersedes the <code>publicProviderSeverity</code> when enabled, and can be disabled via the Gradle extension or <code>transform-providers-to-private</code> compiler option. Note that properties and providers with any annotations with <code>KClass</code> arguments are not supported yet pending upstream kotlinc changes.</li> <li>Enhancement: Rewrite the internal <code>BindingGraph</code> implementation to be more performant, accurate, and testable.</li> <li>Enhancement: Add diagnostic to check that graph factories don\u2019t provide their target graphs as parameters.</li> <li>Enhancement: Add diagnostic to check that a primary scope is defined if any additionalScopes are also defined on a graph annotation.</li> <li>Enhancement: Add diagnostic to validate that contributed types do not have narrower visibility that aggregating graphs. i.e. detect if you accidentally try to contribute an <code>internal</code> type to a <code>public</code> graph.</li> <li>Enhancement: Optimize supertype lookups when building binding classes by avoiding previously visited classes.</li> <li>Enhancement: Don\u2019t generate hints for contributed types with non-public API visibility.</li> <li>Enhancement: When reporting duplicate binding errors where one of the bindings is contributed, report the contributing class in the error message.</li> <li>Enhancement: When reporting scope incompatibility, check any extended parents match the scope and suggest a workaround in the error diagnostic.</li> <li>Enhancement: Allow AssistedFactory methods to be protected.</li> <li>Fix: Fix incremental compilation when a parent graph or supertype modifies/removes a provider.</li> <li>Fix: Fix rank processing error when the outranked binding is contributed using Metro\u2019s ContributesBinding annotation.</li> <li>Fix: Fix <code>@Provides</code> graph parameters not getting passed on to extended child graphs.</li> <li>Fix: Fix qualifiers on bindings not getting seen by extended child graphs.</li> <li>Fix: Fix qualifiers getting ignored on accessors from <code>@Includes</code> dependencies.</li> <li>Fix: Fix transitive scoped dependencies not always getting initialized first in graph provider fields.</li> <li>Fix: Fix injected <code>lateinit var</code> properties being treated as if they have default values.</li> <li>Fix: Alias bindings not always having their backing type visited during graph validation.</li> <li>Fix: Fix race condition in generating parent graphs first even if child graph is encountered first in processing.</li> <li>Fix: Fallback <code>AssistedInjectChecker</code> error report to the declaration source.</li> <li>Fix: Fix missing parent supertype bindings in graph extensions.</li> <li>Change: <code>InstanceFactory</code> is no longer a value class. This wasn\u2019t going to offer much value in practice.</li> <li>Change: Change debug reports dir to be per-compilation rather than per-platform.</li> </ul> <p>Special thanks to @gabrielittner, @kevinguitar, @JoelWilcox, and @japplin for contributing to this release!</p>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>2025-04-21</p> <ul> <li>New: Nullable bindings are now allowed! See the nullability docs for more info.</li> <li>Enhancement: Add diagnostics for multibindings with star projections.</li> <li>Enhancement: Add diagnostic for map multibindings with nullable keys.</li> <li>Fix: Ensure assisted factories\u2019 target bindings\u2019 parameters are processed in MetroGraph creation. Previously, these weren\u2019t processed and could result in scoped bindings not being cached.</li> <li>Fix: Fix duplicate field accessors generated for graph supertypes.</li> <li>Add compose navigation sample.</li> </ul> <p>Special thanks to @bnorm and @yschimke for contributing to this release!</p>"},{"location":"changelog/#013","title":"0.1.3","text":"<p>2025-04-18</p> <ul> <li>Change: Multibindings may not be empty by default. To allow an empty multibinding, <code>@Multibinds(allowEmpty = true)</code> must be explicitly declared now.</li> <li>New: Write graph metadata to reports (if enabled).</li> <li>New: Support configuring debug and reports globally via <code>metro.debug</code> and <code>metro.reportsDestination</code> Gradle properties (respectively).</li> <li>Enhancement: Change how aggregation hints are generated to improve incremental compilation. Externally contributed hints are now looked up lazily per-scope instead of all at once.</li> <li>Enhancement: Optimize empty map multibindings to reuse a singleton instance.</li> <li>Enhancement: Report error diagnostic if Dagger\u2019s <code>@Reusable</code> is used on a provider or injected class.</li> <li>Enhancement: Tweak diagnostic error strings for members so that IDE terminals auto-link them better. i.e., instead of printing <code>example.AppGraph.provideString</code>, Metro will print <code>example.AppGraph#provideString</code> instead.</li> <li>Enhancement: Support repeatable @ContributesBinding annotations with different scopes.</li> <li>Fix: Fix incremental compilation when <code>@Includes</code>-annotated graph parameters change accessor signatures.</li> <li>Fix: Don\u2019t allow graph extensions to use the same scope as any extended ancestor graphs.</li> <li>Fix: Don\u2019t allow multiple ancestor graphs of graph extensions to use the same scope.</li> <li>Fix: Handle scenarios where the compose-compiler plugin runs before Metro\u2019s when generating wrapper classes for top-level <code>@Composable</code> functions.</li> <li>Fix: Fix an edge case in graph extensions where child graphs would miss a provided scoped binding in a parent graph that was also exposed as an accessor.</li> <li>Fix: Fix Dagger interop issue when calling Javax/Jakarta/Dagger providers from Metro factories.</li> <li>Fix: Fix Dagger interop issue when calling <code>dagger.Lazy</code> from Metro factories.</li> <li>Fix: Preserve the original <code>Provider</code> or <code>Lazy</code> type used in injected types when generating factory creators.</li> <li>Temporarily disable hint generation in WASM targets to avoid file count mismatches until KT-75865.</li> <li>Add an Android sample: https://github.com/ZacSweers/metro/tree/main/samples/android-app</li> <li>Add a multiplatform Circuit sample: https://github.com/ZacSweers/metro/tree/main/samples/circuit-app</li> <li>Add samples docs: https://zacsweers.github.io/metro/samples</li> <li>Add FAQ docs: https://zacsweers.github.io/metro/faq</li> </ul> <p>Special thanks to @JoelWilcox, @bnorm, and @japplin for contributing to this release!</p>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>2025-04-08</p> <ul> <li>Enhancement: Implement <code>createGraph</code> and <code>createGraphFactory</code> FIR checkers for better error diagnostics on erroneous type arguments.</li> <li>Enhancement: Add <code>ContributesBinding.rank</code> interop support with Anvil.</li> <li>Enhancement: Check Kotlin version compatibility. Use the <code>metro.version.check=false</code> Gradle property to disable these warnings if you\u2019re feeling adventurous.</li> <li>Fix: Fix class-private qualifiers on multibinding contributions in other modules not being recognized in downstream graphs.</li> <li>Fix: Fix member injectors not getting properly visited in graph validation.</li> <li>Fix: Fix a bug where <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> multibindings weren\u2019t always unwrapped correctly.</li> <li>Fix: Fix <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> type keys not correctly interpreting the underlying type key as <code>Map&lt;Key, Value&gt;</code>.</li> <li>Change: Change <code>InstanceFactory</code> to a value class.</li> <li>Change: Make <code>providerOf</code> use <code>InstanceFactory</code> under the hood.</li> </ul> <p>Special thanks to @JoelWilcox, @bnorm, @japplin, @kevinguitar, and @erawhctim for contributing to this release!</p>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>2025-04-03</p> <p>Initial release!</p> <p>See the announcement blog post: https://www.zacsweers.dev/introducing-metro/</p>"},{"location":"code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> <li>Respecting maintainers\u2019 time and not asking for ETAs</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others\u2019 private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code-of-conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pandanomic@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code-of-conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code-of-conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code-of-conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code-of-conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code-of-conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla\u2019s code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"compatibility/","title":"Kotlin Compatibility","text":"<p>The Kotlin compiler plugin API is not a stable API, so not every version of Metro will work with every version of the Kotlin compiler.</p> <p>Starting with Metro <code>0.6.9</code>, Metro tries to support forward compatibility on a best-effort basis. Usually, it\u2019s <code>N+.2</code> (so a Metro version built against Kotlin <code>2.3.0</code> will try to support up to <code>2.3.20</code>.</p> Kotlin version Metro versions (inclusive) Notes 2.3.20-dev-5437 0.8.1 - 2.3.0-RC 0.6.9, 0.6.11 - Reporting doesn\u2019t work until <code>0.7.3</code> 2.3.0-Beta2 0.6.9, 0.6.11 - Reporting doesn\u2019t work until <code>0.7.3</code> 2.3.0-Beta1 0.6.9, 0.6.11 - 2.2.21 0.6.6 - 2.2.20 0.6.6 - 2.2.10 0.4.0 - 0.6.5 2.2.0 0.4.0 - 0.6.5 2.1.21 0.3.1 - 0.3.8 2.1.20 0.1.2 - 0.3.0 <p>Some releases may introduce prohibitively difficult breaking changes that require companion release, so check Metro\u2019s open PRs for one targeting that Kotlin version for details. There is a tested versions table at the bottom of this page that is updated with each Metro release.</p>"},{"location":"compatibility/#tested-versions","title":"Tested Versions","text":"<p>The following Kotlin versions are tested via CI:</p> Kotlin Version 2.3.20-dev-5437 2.3.0-RC2 2.3.0-RC 2.3.0-Beta2 2.3.0-Beta1 2.2.21 2.2.20 <p>Note</p> <p>Versions without dedicated compiler-compat modules will use the nearest available implementation below that version. See <code>compiler-compat/version-aliases.txt</code> for the full list.</p>"},{"location":"compatibility/#what-about-metros-stability","title":"What about Metro\u2019s stability?","text":"<p>See the stability docs.</p>"},{"location":"contributing/","title":"Contributing to Metro","text":"<p>Metro welcomes contributions! Small contributions like documentation improvements, small obvious fixes, etc are always good and don\u2019t need prior discussion. I liberally leave TODO comments in code that don\u2019t quite meet the standard of an issue but are still things worth improving :). For larger functionality changes or features, please raise a discussion or issue first before starting work.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Local development with Metro is fairly straightforward. You should be able to clone the repo and open it in IntelliJ as a standard Gradle project.</p> <p>If you get an issue with the Android gradle plugin version being too new, you can follow the instructions here.</p> <p>Note: This project uses a specific JDK (see the <code>jdk</code> version in <code>libs.versions.toml</code>). If you don\u2019t have that JDK installed, you can likely change it to whatever JDK suits your needs as long as it\u2019s compatible with the <code>jvmTarget</code> version defined in <code>libs.versions.toml</code>.</p> <p>There are a few primary subprojects to consider.</p> <ol> <li><code>:compiler</code> \u2014 Metro\u2019s compiler plugin implementation lives. This includes compiler-supported interop features too.</li> <li><code>:compiler-tests</code> \u2014 Compiler tests using JetBrains\u2019 official compiler testing infrastructure.</li> <li><code>:gradle-plugin</code> \u2014 Metro\u2019s companion Gradle plugin implementation. Mostly just an extension API and compiler plugin wiring with KGP.<ul> <li>This is also where incremental compilation integration tests live!</li> </ul> </li> <li><code>:runtime</code> \u2014 Metro\u2019s core multiplatform runtime API. This is mostly annotations plus some small runtime APIs.</li> <li><code>:interop-dagger</code> \u2014 An ancillary set of JVM-only Dagger-specific runtime APIs for interop with Dagger.</li> <li><code>samples/</code> \u2014 A separate gradle project that contains several sample projects. This includes the core artifacts as an included build. You can add this project in IntelliJ as another Gradle project to support developing both. There are also some integration tests in here.</li> <li><code>:integration-tests</code> \u2014 self-explanatory.</li> <li><code>:multi-module-test</code> \u2014 A multi-module integration test.</li> </ol> <p>There is a useful <code>./metrow</code> helper CLI that can perform a few common commands across the various subprojects.</p> <p>Tip</p> <p>Before submitting a PR, it is useful to run <code>regen</code> and <code>check</code>.</p> <ul> <li><code>./metrow format</code> \u2014 Runs all code formatters.</li> <li><code>./metrow regen</code> \u2014 Regenerates <code>.api</code> files and runs all code formatters.</li> <li><code>./metrow check</code> \u2014 Runs checks across all included Gradle projects (including samples and the Gradle plugin).</li> <li><code>./metrow publish --local --version x.y.z</code> \u2014 Publishes to maven local with the specified <code>x.y.z</code> version (replace this with whatever you want, like <code>1.0.0-LOCAL01</code>.)</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Tests are spread across a few areas.</p> <ul> <li><code>compiler-tests/</code> \u2014 New compiler tests using JetBrains\u2019 official compiler testing infrastructure. If possible, write new compiler tests in here! See this PR for more details on how they work.</li> <li><code>compiler/src/test/</code> \u2014 Core compiler tests. These should be focused primarily on error testing but can also perform limited functional testing. Note that while many tests are here, new tests should ideally use <code>compiler-tests</code>.</li> <li><code>gradle-plugin/src/functionalTest</code> \u2014 Integration gradle tests, primarily focused on exercising different incremental compilation scenarios.</li> <li><code>samples/</code> \u2014 Some samples have tests! This is useful to assert that these samples work as expected.<ul> <li><code>integration-tests/</code> \u2014 Integration tests. These should only be functional in nature and not test error cases (error cases won\u2019t compile!). Note that new integration tests should usually be written in <code>compiler-tests</code>. Some scenarios, such as multi-compilation tests across Gradle, may make more sense to write here.</li> </ul> </li> </ul> <p>To publish to a local maven repo, run this:</p> <pre><code>./metrow publish --local --version 1.0.0-LOCAL01 # whatever version you want\n</code></pre>"},{"location":"contributing/#compiler-plugin-design","title":"Compiler Plugin Design","text":"<p>The compiler plugin is implemented primarily in two parts.</p>"},{"location":"contributing/#1-fir","title":"1. FIR","text":"<p>The FIR frontend generates declarations, generates supertypes, and performs diagnostic checks for Metro types. Any class or callable declaration generated by Metro should be done here as this is required for them to be visible in Kotlin metadata later.</p> <p>Generators go in the <code>dev.zacsweers.metro.compiler.fir.generators</code> package.</p> <p>Checkers go in the <code>dev.zacsweers.metro.compiler.fir.checkers</code> package.</p> <p>New checker contributions are generally welcome. New generators almost always warrant prior discussion first!</p>"},{"location":"contributing/#2-ir","title":"2. IR","text":"<p>The IR backend performs two main functions:</p> <ol> <li>Implements declarations generated in FIR. This includes generated graphs, factories, member injectors, etc.</li> <li>Performs dependency graph construction and validation. This is primarily spread across <code>DependencyGraphTransformer</code>, <code>BindingGraph</code>, and <code>Binding</code>.</li> </ol> <p>Most of this is implemented as transformers in the <code>dev.zacsweers.metro.compiler.ir.transformers</code> package. Note that all transformers are run from the <code>DependencyGraphTransformer</code>, which is the only true <code>IrTransformer</code> of the bunch and just delegates out to the other transformers as needed.</p> <p>Aggregation hint properties are also implemented in IR as a workaround to support incremental compilation. See <code>ContributionHintIrTransformer</code> for more details.</p>"},{"location":"contributing/#typekey-and-contextualtypekey","title":"<code>TypeKey</code> and <code>ContextualTypeKey</code>","text":"<p><code>TypeKey</code> and <code>ContextualTypeKey</code> (and their FIR counterparts) deserve special mention. Most of the compiler\u2019s dependency graph analysis thinks in terms of these two types.</p> <p>A <code>TypeKey</code> is the canonical representations of specific binding, composed of a type and optional qualifier.</p> <p>A <code>ContextualTypeKey</code> can be thought up as a <code>TypeKey</code> with context of how it\u2019s used. This is useful for a few reasons:</p> <ul> <li>Allows Metro\u2019s compiler plugin to generate code accordingly for how the given <code>TypeKey</code> is used at runtime, for example wrapping in <code>Provider</code>, <code>Lazy</code>, etc.</li> <li>Allows dependency graph resolution to understand if the type is deferrable, which is useful in breaking dependency cycles.</li> </ul>"},{"location":"contributing/#misc-notes","title":"Misc Notes","text":"<ul> <li>IR code should cache eagerly.</li> <li>FIR code should cache carefully (remember it runs in the IDE!).</li> <li>FIR code should be defensive. It may run continuously in the IDE and not all information may be available to the compiler as the user has written it. If you\u2019ve ever written a custom lint check, your methodology should be similar.</li> <li>Inversely, IR code should be offensive. Assert expectations with clear error messages, report errors with useful error messages.</li> <li>FIR-generated declaration should use descriptive keys to declarations that can be referenced later in FIR and IR (as <code>origins</code>). See <code>Keys.kt</code> for FIR declarations and <code>Origins.kt</code> for their IR analogs.</li> </ul>"},{"location":"debugging/","title":"Debugging","text":"<p>One major downside to generating IR directly is that developers cannot step into generated source code with the debugger. This is an accepted trade-off with Metro (or any other compiler plugin).</p> <p>Metro does offer a <code>debug</code> option in its plugin options/Gradle extension that will print verbose Kotlin pseudocode for all generated IR classes. This can be further tuned to print just certain classes.</p> <pre><code>metro {\n  debug.set(true)\n}\n</code></pre> <p>In the future, we could possibly explore including information in IR to synthesize call stack information similar to coroutines, but will save that for if/when it\u2019s asked for.</p>"},{"location":"debugging/#reports","title":"Reports","text":"<p>Similar to Compose, Metro supports a <code>reportsDestination</code> property in its Gradle DSL and can output various graph reports to this destination if specified. This is very much a WIP, feedback is welcome!</p> <p>Warning</p> <p>You should not leave this enabled by default as it can be quite verbose and potentially expensive. This property also does not participate in task inputs, so you may need to recompile with <code>--rerun</code> to force recompilation after adding this flag.</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre> <p>Warning</p> <p>The Kotlin Gradle Plugin does not include file inputs like <code>reportsDestination</code> as build inputs, so you may need to compile with <code>--rerun</code> to force recompilation after adding this flag.</p>"},{"location":"debugging/#graph-analysis-visualization","title":"Graph Analysis &amp; Visualization","text":"<p>Metro provides Gradle tasks for generating interactive HTML visualizations of your dependency graphs. See Graph Analysis for full documentation on:</p> <ul> <li>Generating and viewing interactive graph visualizations</li> <li>Understanding node shapes, colors, and edge types</li> <li>Using filters and analysis tools</li> <li>Identifying potential issues in your dependency structure</li> </ul>"},{"location":"debugging/#decompiled-bytecode","title":"Decompiled Bytecode","text":"<p>Compiled java class files of Metro-generated types are fairly friendly to the IntelliJ \u201cdecompile to Java\u201d action. Simply open the class file in the IDE (usually seen as a Kotlin bytecode class) then run the \u201cdecompile to Java\u201d action. For JVM projects they are under <code>build/classes</code>. For Android projects, it\u2019s <code>build/tmp/kotlin-classes</code>.</p>"},{"location":"dependency-graphs/","title":"Dependency Graphs","text":"<p>The primary entry points in Metro are dependency graphs. These are interfaces annotated with <code>@DependencyGraph</code> and created with <code>@DependencyGraph.Factory</code> interfaces. Graphs expose types from the object graph via accessor properties or functions.</p> <p>Tip</p> <p>These are synonymous with components and <code>@Component</code>/<code>@Component.Factory</code> in Dagger and kotlin-inject.</p> <p>Tip</p> <p>\u201cAccessors\u201d in Metro are synonymous with Dagger\u2019s provision methods.</p> <p>Accessors and member injections act as roots, from which the dependency graph is resolved. Dependencies can be provided via conventional <code>@Provides</code> functions in graphs or their supertypes, constructor-injected classes, or accessed from graph dependencies.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides\n  fun provideMessage(): String = \"Hello, world!\"\n}\n</code></pre> <p>Note the <code>@Provides</code> function must define an explicit return type.</p> <p>Simple graphs like this can be created via the <code>createGraph()</code> intrinsic.</p> <pre><code>val graph = createGraph&lt;AppGraph&gt;()\n</code></pre> <p>Graphs are relatively cheap and should be used freely.</p>"},{"location":"dependency-graphs/#inputs","title":"Inputs","text":"<p>Runtime inputs can be provided via a <code>@DependencyGraph.Factory</code> interface that returns the target graph. These parameters must be annotated with either <code>@Provides</code> or <code>@Includes</code>.</p>"},{"location":"dependency-graphs/#provides","title":"Provides","text":"<p>The simplest input is an instance parameter annotated with <code>@Provides</code>. This provides this instance as an available binding on the graph.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n</code></pre> <p>Provided parameters may be any type.</p> <p>Tip</p> <p>This is analogous to Dagger\u2019s <code>@BindsInstance</code>.</p>"},{"location":"dependency-graphs/#includes","title":"Includes","text":"<p><code>@Includes</code>-annotated parameters are treated as containers of available bindings. Metro will treat accessors of these types as usable dependencies.</p> <p>They are commonly other graph types whose\u2019 dependencies you want to consume via explicit API.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageGraph: MessageGraph): AppGraph\n  }\n\n  @DependencyGraph interface MessageGraph {\n    val message: String\n\n    @Provides fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre> <p><code>@Includes</code> instance dependencies do not need to be other graphs though! They can be any regular class type. They cannot be enums or annotation classes.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageProvider: MessageProvider): AppGraph\n  }\n\n  interface MessageProvider {\n    val message: String\n  }\n}\n</code></pre> <p>Warning</p> <p>Includes parameters cannot be injected from the graph.</p> <p>Binding Containers are a special type of <code>@Includes</code> type, see more in its section below.</p>"},{"location":"dependency-graphs/#creating-factories","title":"Creating factories","text":"<p>Graph factories can be created with the <code>createGraphFactory()</code> intrinsic.</p> <pre><code>val messageGraph =\n  createGraphFactory&lt;AppGraph.Factory&gt;()\n    .create(\"Hello, world!\")\n</code></pre>"},{"location":"dependency-graphs/#scoping","title":"Scoping","text":"<p>See Scopes for more details on scopes!</p> <p>Graphs may declare a <code>scope</code> (and optionally <code>additionalScopes</code> if there are more). Each of these declared scopes act as an implicit <code>@SingleIn</code> representation of that scope for aggregation.</p> <p>For example: <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre></p> <p>Is functionally equivalent to writing the below.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#graph-extensions","title":"Graph Extensions","text":"<p>Dependency graphs can be extended via graph extensions. As the name implies, graph extensions extend a parent graph they are declared for and contain a superset of bindings that includes both the parent graph(s) as well as their own. These are similar in functionality to Dagger\u2019s Subcomponents.</p> <p>Graph extensions must be either an interface or an abstract class and are annotated with <code>@GraphExtension</code>. They are created via <code>@GraphExtension.Factory</code> types.</p> <p>Metro\u2019s compiler plugin will build, validate, and implement this graph at compile-time when the parent graph is generated. This means that graph extensions are not available until the parent graph is generated.</p> <p>Graph extensions can be chained and implicitly inherit their parents\u2019 scopes.</p>"},{"location":"dependency-graphs/#creating-graph-extensions","title":"Creating Graph Extensions","text":"<p>You cannot create a graph extension independent of its parent graph, you may only access it via accessor on the parent graph. You can declare this in multiple ways:</p> <ul> <li>Declare an accessor on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraph: LoggedInGraph\n}\n</code></pre> <ul> <li>(If the extension has a creator) declare the creator on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraphFactory: LoggedInGraph.Factory\n}\n</code></pre> <ul> <li>(If the extension has a creator) make the parent graph implement the creator.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph : LoggedInGraph.Factory\n</code></pre> <ul> <li>Contribute the factory to the parent graph via @ContributesTo. More on this below.</li> </ul> <pre><code>@GraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n  @ContributesTo(AppScope::class)\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#scoping_1","title":"Scoping","text":"<p>See Scopes for more details on scopes!</p> <p>Like DependencyGraph, graph extensions may declare a <code>scope</code> (and optionally <code>additionalScopes</code> if there are more). Each of these declared scopes act as an implicit <code>@SingleIn</code> representation of that scope. For example:</p> <pre><code>@GraphExtension(AppScope::class)\ninterface AppGraph\n</code></pre> <p>Is functionally equivalent to writing the below.</p> <pre><code>@SingleIn(AppScope::class)\n@GraphExtension(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#providers","title":"Providers","text":"<p>Like DependencyGraph, graph extensions may declare providers via <code>@Provides</code> and <code>@Binds</code> to provide dependencies into the graph.</p> <p>Creators can provide instance dependencies and other graphs as dependencies.</p> <pre><code>@GraphExtension\ninterface AppGraph {\n  val httpClient: HttpClient\n\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n</code></pre>"},{"location":"dependency-graphs/#creators","title":"Creators","text":"<p>See DependencyGraph\u2019s section on creators.</p>"},{"location":"dependency-graphs/#aggregation","title":"Aggregation","text":"<p>See DependencyGraph\u2019s section on aggregation.</p>"},{"location":"dependency-graphs/#contributed-graph-extensions","title":"Contributed Graph Extensions","text":"<p>Graph extensions may be contributed to a parent graph and its contribution merging will be deferred until the parent graph is generated.</p>"},{"location":"dependency-graphs/#the-problem","title":"The Problem","text":"<p>Imagine this module dependency tree:</p> <pre><code>        :app\n      /     \\\n     v       v\n  :login   :user-data\n</code></pre> <p><code>:app</code> defines the main dependency graph with <code>@DependencyGraph</code>. The <code>:login</code> module defines a graph extension for authenticated user flows, and <code>:user-data</code> provides some core functionality like <code>UserRepository</code>.</p> <p>If <code>:login</code> defines its own graph directly with <code>@DependencyGraph</code>, it won\u2019t see contributions from <code>:user-data</code> unless <code>:login</code> depends on it directly.</p>"},{"location":"dependency-graphs/#the-solution","title":"The Solution","text":"<p>Instead, <code>:login</code> can use <code>@GraphExtension(LoggedInScope::class)</code> + <code>@ContributesTo</code> on its associated factory to say: \u201cI want to contribute a new graph extension to a future <code>AppScope</code> parent graph.\u201d</p> <p>The graph extension will then be generated in <code>:app</code>, which already depends on both <code>:login</code> and <code>:user-data</code>. Now <code>UserRepository</code> can be injected in <code>LoggedInGraph</code>.</p> <pre><code>@GraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n\n  val userRepository: UserRepository\n\n  @ContributesTo(AppScope::class)\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n</code></pre> <p>In the <code>:app</code> module:</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre> <p>The generated code will modify <code>AppGraph</code> to implement <code>LoggedInGraph.Factory</code> and implement <code>createLoggedInGraph()</code> using a generated final <code>LoggedInGraphImpl</code> class that includes all contributed bindings, including <code>UserRepository</code> from <code>:user-data</code>.</p> <pre><code>interface AppGraph\n// modifications generated during compile-time\n  interface AppGraph : LoggedInGraph.Factory {\n\n  override fun createLoggedInGraph(): LoggedInGraph {\n    return LoggedInGraphImpl(this)\n  }\n\n  // Generated in IR\n  class $$MetroGraph : AppGraph {\n    class LoggedInGraphImpl(appGraph: $$MetroGraph) : LoggedInGraph {\n      // ...\n    }\n  }\n}\n</code></pre> <p>Finally, you can obtain a <code>LoggedInGraph</code> instance from <code>AppGraph</code> since it now implements <code>LoggedInGraph.Factory</code>:</p> <pre><code>// Using the asContribution() intrinsic\nval loggedInGraph = appGraph.asContribution&lt;LoggedInGraph.Factory&gt;().createLoggedInGraph()\n\n// Or if you have IDE support enabled\nval loggedInGraph = appGraph.createLoggedInGraph()\n</code></pre>"},{"location":"dependency-graphs/#graph-arguments","title":"Graph arguments","text":"<p>You can pass arguments to the graph via the factory:</p> <pre><code>@ContributesTo(AppScope::class)\n@GraphExtension.Factory\ninterface Factory {\n  fun create(@Provides userId: String): LoggedInGraph\n}\n</code></pre> <p>This maps to:</p> <pre><code>// Generated in IR\n@DependencyGraph(LoggedInScope::class)\nclass LoggedInGraphImpl(\n  parent: AppGraph,\n  @Provides userId: String\n): LoggedInGraph {\n  // ...\n}\n</code></pre> <p>In <code>AppGraph</code>, the generated factory method looks like:</p> <pre><code>// Generated in IR\noverride fun create(userId: String): LoggedInGraph {\n  return LoggedInGraphImpl(this, userId)\n}\n</code></pre> <p>Warning</p> <p>Abstract factory classes cannot be used as graph contributions.</p> <p>Contributed graphs may also be chained.</p>"},{"location":"dependency-graphs/#binding-containers","title":"Binding Containers","text":"<p>Binding containers are classes, objects, or interfaces annotated with <code>@BindingContainer</code> that contain binding declarations (<code>@Provides</code> or <code>@Binds</code>) but are not themselves complete dependency graphs. They\u2019re analogous to Dagger\u2019s <code>@Module</code> annotation and can be used in cases where defining bindings in an (extended) interface is unwieldy or not helpful.</p> <p>Unlike graphs and other <code>@Includes</code> types, their public accessors are not read. Only <code>@Binds</code> and <code>@Provides</code> declarations are read.</p> <p>Tip</p> <p>Binding containers can be seen as partial graphs and are intended to be reusable, composable units that are included in a complete graph.</p>"},{"location":"dependency-graphs/#including-via-includes-parameters","title":"Including via <code>@Includes</code> Parameters","text":"<p>The most flexible way to include binding containers is via <code>@Includes</code>-annotated parameters on graph factories.</p> <pre><code>@BindingContainer\nclass NetworkBindings(private val baseUrl: String) {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(baseUrl)\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val httpClient: HttpClient\n\n  @DependencyGraph.Factory\n  interface Factory {\n    fun create(@Includes networkBindings: NetworkBindings): AppGraph\n  }\n}\n</code></pre> <p>This allows you to bring any instance to the graph with its own internal logic.</p>"},{"location":"dependency-graphs/#including-via-dependencygraphbindingcontainers","title":"Including via <code>@DependencyGraph.bindingContainers</code>","text":"<p>For simple binding containers, you can declare them directly in the graph annotation:</p> <pre><code>@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>This method works for:</p> <ul> <li><code>object</code> classes</li> <li><code>interface</code> or <code>abstract class</code> types with only <code>@Binds</code> providers or companion object <code>@Provides</code> providers</li> <li>Simple classes with a public, no-arg constructor</li> </ul>"},{"location":"dependency-graphs/#chaining-binding-containers","title":"Chaining Binding Containers","text":"<p>Binding containers can include other binding containers using the <code>includes</code> parameter:</p> <pre><code>@BindingContainer\nobject CacheBindings {\n  @Provides fun provideHttpCache(): Cache = Cache()\n}\n\n@BindingContainer(includes = [CacheBindings::class])\nobject NetworkBindings {\n  @Provides fun provideHttpClient(cache: Cache): HttpClient = HttpClient(cache)\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>The transitive closure of all included binding containers will be included in the final consuming graph.</p>"},{"location":"dependency-graphs/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers can be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>They can also replace other contributed binding containers:</p> <pre><code>// In a test variant\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre> <p>Graphs may exclude contributed containers:</p> <pre><code>@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"dependency-graphs/#notes","title":"Notes","text":"<ul> <li>Companion objects, annotation classes, and enum classes/entries cannot be annotated with <code>@BindingContainer</code>.</li> <li>Provides within a binding container\u2019s companion object are automatically included.</li> <li>Enclosing classes of <code>@Binds</code> or <code>@Provides</code> providers don\u2019t need to be annotated with <code>@BindingContainer</code> for Metro to process them - the annotation is primarily for reference to <code>@DependencyGraph.Factory</code> and the ability to use <code>includes</code>.</li> <li>Binding containers may also be contributed.</li> <li>See #172 for more details.</li> </ul>"},{"location":"dependency-graphs/#dynamic-graphs","title":"Dynamic Graphs","text":"<p>Dynamic graphs are a powerful feature of the Metro compiler that allow for dynamically replacing bindings in a given graph. To use them, you can pass in a vararg set of binding containers to the <code>createDynamicGraph()</code> and <code>createDynamicGraphFactory()</code> intrinsics.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(): String = \"real\"\n}\n\nclass AppTest {\n  val testGraph = createDynamicGraph&lt;AppGraph&gt;(FakeBindings)\n\n  @Test\n  fun test() {\n    assertEquals(\"fake\", testGraph.message)\n  }\n\n  @BindingContainer\n  object FakeBindings {\n    @Provides fun provideMessage(): String = \"fake\"\n  }\n}\n</code></pre> <p>The compiler will dynamically generate a hidden graph impl within the enclosing class or file that is unique to the combination of input [containers] and target type [T].</p> <p>Constraints</p> <ul> <li>All containers must be instances (or objects) of binding containers.</li> <li>It\u2019s an error to pass no containers.</li> <li>All containers must be non-local, canonical classes. i.e., they must be something with a name!</li> <li>This overload may be called in a member function body, top-level function body, or property   initializer.</li> <li>The target [T] graph must be annotated with <code>@DependencyGraph</code> and must be a   valid graph on its own.</li> </ul> Implementation Notes <ul> <li>The bulk of this implementation is in <code>IrDynamicGraphGenerator</code>.</li> <li>The generated graph impl is a private nested (static) class of the enclosing class or file.</li> <li>This doesn\u2019t swap bindings in a real graph or use a real graph at all, instead tracking available dynamic bindings and preferring them when constructing a graph in <code>BindingGraphGenerator</code>.</li> </ul>"},{"location":"dependency-graphs/#general-implementation-notes","title":"General Implementation Notes","text":"<p>Dependency graph code gen is designed to largely match how Dagger components are generated.</p> <ul> <li>Internal graph validation uses Tarjan\u2019s algorithm + topological sort implementation.</li> <li>This runs in O(V+E) time</li> <li>The returned ordered list of bindings can be used to determine provider field generation order.</li> <li>Any binding whose order depends on one later in the returned order implicitly requires use of <code>DelegateFactory</code>.</li> <li>Dependencies are traversed from public accessors and <code>inject()</code> functions.</li> <li>Metro generates Provider Factory classes for each provider. These should be generated at the same time that the provider is compiled so that their factory classes. This is for two primary purposes:<ul> <li>They can be reused to avoid code duplication</li> <li>Metro can copy default values for provider values over to the generated factory to support optional dependencies. Since default values may refer to private references, we must generate these factories as nested classes.</li> </ul> </li> <li>Metro generates a graph impl class that holds all aggregated bindings and manages scoping.</li> <li>Scoped bindings are stored in provider fields backed by <code>DoubleCheck</code>.</li> <li>Reused unscoped providers instances are stored in reusable fields.</li> <li><code>@Provides</code> factory parameters are stored in a field backed by <code>InstanceFactory</code>.</li> <li>Multibindings create new collection instances every time.</li> <li>Multibinding providers are not accessible as standalone bindings.</li> <li>Graph extensions are implemented via a combination of things<ul> <li>Custom <code>MetroMetadata</code> is generated and serialized into Kotlin\u2019s <code>Metadata</code> annotations.</li> <li>Extendable parent graphs opt-in to generating this metadata. They write information about their available provider and instance fields, binds callable IDs, parent graphs, and provides callable IDs.</li> <li>Extendable parent graphs generate <code>_metroAccessor</code>-suffixed <code>internal</code> functions that expose instance fields and provider fields.</li> <li>Child graphs read this metadata and look up the relevant callable symbols, then incorporating these when building its own binding graph.</li> </ul> </li> </ul>"},{"location":"dependency-graphs/#optimizations","title":"Optimizations","text":"<p>Metro applies several optimizations to generated graph code to reduce class size and improve runtime performance.</p>"},{"location":"dependency-graphs/#dead-binding-elimination","title":"Dead binding elimination","text":"<p>By default, Metro removes bindings that are not reachable from any accessor or member injector function. This reduces the size of generated code and avoids unnecessary initialization work.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val httpClient: HttpClient  // This is a root - it's reachable\n\n  fun inject(memberInjectedClass: MemberInjectedClass) // This is also a root\n\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n\n  // This binding is NOT reachable from any accessor, so it will be eliminated\n  @Provides fun provideUnusedService(): UnusedService = UnusedService()\n}\n</code></pre> <p>This can be disabled via <code>metro.shrinkUnusedBindings=false</code> if you need all declared bindings to be generated (e.g., for debugging).</p>"},{"location":"dependency-graphs/#property-collection","title":"Property collection","text":"<p>Not all bindings need dedicated provider fields. Metro analyzes the binding graph to determine which bindings require properties and what kind:</p> <p>Scoping: Scoped bindings (e.g. <code>@SingleIn</code>) always get a field backed by <code>DoubleCheck</code> to ensure lazy, thread-safe instantiation that is a singleton within the enclosing graph.</p> <p>Reference counting: Unscoped bindings used only once are inlined at their call site. Bindings used two or more times get a reusable provider field to avoid duplicate instantiation logic.</p> <p>Alias resolution: When counting references, Metro follows <code>@Binds</code> alias chains to the final implementation. If <code>Api</code> binds to <code>ApiImpl</code>, references to <code>Api</code> count toward <code>ApiImpl</code>\u2019s ref count.</p> <p>Multibinding source accessors: Bindings contributed to multibindings (<code>@IntoSet</code>, <code>@IntoMap</code>) that have dependencies are extracted into getter properties. This avoids duplicating dependency resolution code at each multibinding collection site and avoids risking <code>MethodTooLargeException</code> issues at compile-time.</p>"},{"location":"dependency-graphs/#chunking","title":"Chunking","text":"<p>JVM methods have a size limit. For graphs with many bindings, the constructor initialization code can exceed this limit. To avoid this, Metro splits initialization into multiple private <code>init</code> functions if necessary, each handling a subset of bindings.</p> <pre><code>// Generated structure for a large graph:\nclass AppGraph$Impl : AppGraph {\n  private val provider1: Provider&lt;...&gt;\n  private val provider2: Provider&lt;...&gt;\n  // ... hundreds more ...\n\n  init {\n    init1()\n    init2()\n    // ...\n  }\n\n  private fun init1() {\n    provider1 = ...\n    provider2 = ...\n    // ... up to statementsPerInitFun statements ...\n  }\n\n  private fun init2() {\n    // ... next batch ...\n  }\n}\n</code></pre> <p>Configuration options:</p> <ul> <li><code>metro.chunkFieldInits</code> - Enable/disable chunking (default: <code>true</code>)</li> <li><code>metro.statementsPerInitFun</code> - Max statements per init function (default: <code>25</code>)</li> </ul>"},{"location":"dependency-graphs/#sharding","title":"Sharding","text":"<p>For very large graphs, even chunking may not be enough \u2014 the class itself can exceed JVM\u2019s class file size limits. Sharding moves initialization logic into inner shard classes, distributing the code across multiple class files while keeping provider fields on the main graph class.</p> <pre><code>// Generated structure with sharding:\nclass AppGraph$Impl : AppGraph {\n  // Provider fields stay on the main class\n  private val repoProvider: Provider&lt;Repository&gt;\n  private val apiProvider: Provider&lt;ApiService&gt;\n  // ... many more ...\n\n  // Shards hold initialization logic\n  private inner class Shard1 {\n    fun initialize() {\n      repoProvider = provider { Repository.MetroFactory.create() }\n      apiProvider = provider { ApiService.MetroFactory.create(graph.repoProvider) }\n    }\n  }\n\n  private inner class Shard2 {\n    fun initialize() {\n      // ... next batch of initializations ...\n    }\n  }\n\n  init {\n    Shard1().initialize()\n    Shard2().initialize()\n  }\n}\n</code></pre> <p>Sharding respects required binding initialization order and keeps strongly connected components (valid cycles broken by <code>Provider</code>/<code>Lazy</code>) together in the same shard.</p> <p>Configuration options:</p> <ul> <li><code>metro.enableGraphSharding</code> - Enable/disable sharding (default: <code>false</code>)</li> <li><code>metro.keysPerGraphShard</code> - Max bindings per shard (default: <code>2000</code>)</li> </ul>"},{"location":"differences/","title":"Differences from other DI frameworks","text":"DaggerKotlin-InjectAnvilkotlin-inject-anvil <ul> <li><code>@Binds</code> and <code>@Provides</code> declarations can be added directly within graphs and their supertypes.<ul> <li><code>@BindingContainer</code> is the Metro equivalent of a Dagger <code>@Module</code> but it should rarely be used.</li> <li><code>@BindingContainer</code> cannot declare graph extensions in the way <code>@Module</code> can declare subcomponents. Use contributed graph extensions.</li> </ul> </li> <li>There is no Producers support.</li> <li>There is no Hilt support, though some features are similar in the same way that Anvil\u2019s features are similar.</li> <li>There is no <code>@Reusable</code>.</li> <li>There is no <code>@BindsOptionalOf</code>. Instead, Metro supports default optional bindings.<ul> <li>Metro does does support interop with Dagger\u2019s <code>@BindsOptionalOf</code> annotation.</li> </ul> </li> <li>Metro can inject private properties, functions, and constructors.</li> <li>There is no <code>@BindsInstance</code> annotation. Use <code>@Provides</code> on <code>@DependencyGraph.Factory</code> function parameters instead.</li> <li>Included dependencies (\u201ccomponent dependencies\u201d in Dagger) must be annotated with <code>@Includes</code> in graph creators.</li> <li>Metro does not process Java code.</li> <li><code>@Multibinds</code> declarations are implemented in Metro graphs to return the declared multibinding.</li> <li>Empty multibindings are an error by default in Metro. To allow a multibinding to be empty, it must be declared with <code>@Multibinds(allowEmpty = true)</code>.</li> <li>Metro graph classes may not directly extend other graph classes. You should use graph extensions instead in Metro.</li> <li>Dagger technically allows this, but only accessors and injectors cross these boundaries.</li> <li>Metro prohibits scopes on <code>@Binds</code> declarations. Either use <code>@Provides</code> or move the scope to the source class type.</li> </ul> <ul> <li>typealiases are not treated as implicit qualifiers.</li> <li>Dependency graph classes cannot have primary constructors, their parameters must be defined as <code>@Provides</code> or graph parameters on a <code>@DependencyGraph.Factory</code> function like Dagger.</li> <li>Higher order functions cannot be used. Instead, use <code>Provider</code> and declared <code>@AssistedFactory</code>-annotated types.</li> <li>No need for use-site targets for most annotations.</li> <li>No need for <code>@get:Provides Impl.bind: Type get() = this</code> to achieve type bindings. See the docs on <code>@Binds</code>.</li> <li>Metro can inject private properties and functions.</li> <li>Metro does not support detached graph extensions the way kotlin-inject does. Instead, use graph extensions.</li> <li>Metro does not process Java code.</li> <li>Metro does not support assisted parameters in <code>@Provides</code> functions.</li> <li>Metro map multibindings use static map keys rather than aggregating via <code>Pair</code> contributions. More details on why can be found here.</li> </ul> <ul> <li>There is no <code>rank</code> in Metro\u2019s <code>@Contributes*</code> annotations.<ul> <li>Note that if Anvil interop is enabled, its <code>rank</code> properties are supported in interop.</li> </ul> </li> <li>There is no <code>ignoreQualifier</code> in Metro\u2019s <code>@Contributes*</code> annotations.<ul> <li>Note that if Anvil interop is enabled, its <code>ignoreQualifier</code> properties are supported in interop.</li> </ul> </li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> </ul> <ul> <li>There is no need for <code>@CreateComponent</code> or <code>expect fun createComponent()</code> functions.</li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>This is a list of frequently asked questions about Metro. Consider also searching the issue tracker and discussions section of the Metro repo for anything not covered here!</p>"},{"location":"faq/#compiler-plugins-are-not-a-stable-api-is-metro-safe-to-use","title":"Compiler plugins are not a stable API, is Metro safe to use?","text":"<p>This is a fair question! Often times, compiler plugins require new companion releases for each Kotlin release. This is a part of life when using compiler plugins.</p> <p>Metro takes a slightly different approach to this and tries to support forward compatibility on a best-effort basis. Usually, it\u2019s <code>N+.2</code> (so a Metro version built against Kotlin <code>2.3.0</code> will try to support up to <code>2.3.20</code>). This allows Metro to support a reasonable range of Kotlin releases across compiler and IDE versions. See the compatibility docs for more details.</p>"},{"location":"faq/#metro-is-not-a-stable-api-is-metro-safe-to-use","title":"Metro is not a stable API, is Metro safe to use?","text":"<p>Yes, Metro is functionally stable and ready for production use. Its runtime and Gradle plugin APIs are not yet stabilized, which is not the same as being unstable for use</p> <p>See the stability docs for more details.</p>"},{"location":"faq/#why-doesnt-metro-support-reusable","title":"Why doesn\u2019t Metro support <code>@Reusable</code>?","text":"<p>Some technical context</p> <p><code>@Reusable</code> works almost identically in code gen as scoped types, it just uses <code>SingleCheck</code> instead of <code>DoubleCheck</code>. It\u2019s basically like using <code>lazy(NONE)</code> instead of <code>lazy(SYNCHRONIZED)</code>.</p> <p>A few different reasons Metro doesn\u2019t have it</p> <ul> <li>I think it risks being like <code>@Stable</code> in compose where people chase it for perceived performance benefits that they have not profiled or would not actualize if they did. Basically it becomes a premature optimization vector<ul> <li>Ron Shapiro (the author of it) even said you shouldn\u2019t use it or scoping in general [for performance reasons] unless you\u2019ve measured it: https://medium.com/@shapiro.rd/reusable-has-many-of-the-same-costs-as-singleton-c20b5d1ef308</li> </ul> </li> <li>Most people don\u2019t really know when to use it. It doesn\u2019t really strike a balance so much as blurs the line for limited value (see: the first bullet).</li> <li>It invites people to make unclear assumptions. It\u2019s pretty simple to assume something stateful is always a new instance or always the same scoped instance. It is harder to envision scenarios where you have stateful types where you don\u2019t care about knowing if it\u2019s shared or not. You could say this should only be for stateless types then, but then you\u2019re deciding\u2026<ul> <li>Do you want to limit instances? Just scope it</li> <li>Do you not care about limiting instances? Don\u2019t scope it</li> </ul> </li> <li>What\u2019s the expected behavior if you have a <code>@Reusable</code> type <code>Thing</code> and then request a <code>Lazy&lt;Thing&gt;</code> elsewhere? Currently, Metro <code>DoubleCheck.lazy(...)</code>\u2019s whatever binding provides it at the injection site, which would then defeat this. To undo that, Metro would need to introduce some means of indicating \u201cwhat kind\u201d of <code>Lazy</code> is needed, which just complicates things for the developer.</li> </ul>"},{"location":"faq/#why-doesnt-metro-support-kotlin-inject-style-intomap-bindings","title":"Why doesn\u2019t Metro support kotlin-inject-style <code>@IntoMap</code> bindings?","text":"<p>Some technical context</p> <p>kotlin-inject allows you to provide key/value pairs from an <code>@IntoMap</code> function rather than use <code>@MapKey</code> annotations.</p> <p>This allows some dynamism with keys but has some downsides. A few different reasons Metro doesn\u2019t use this approach</p> <ul> <li>Duplicate key checking becomes a runtime failure rather than compile-time.</li> <li>It breaks the ability to expose <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> unless you start manually managing <code>Provider</code> types yourself.</li> <li>You allocate and throw away a <code>Pair</code> instance each time it\u2019s called.</li> </ul>"},{"location":"faq/#will-metro-add-support-for-dagger-android-features-or-dagger-android-interop","title":"Will Metro add support for dagger-android features or dagger-android interop?","text":"<p>No.</p>"},{"location":"faq/#hilt-faq","title":"Hilt FAQ","text":""},{"location":"faq/#will-metro-add-support-for-hilt-features-or-hilt-interop","title":"Will Metro add support for Hilt features or Hilt interop?","text":"<p>Metro is largely inspired by Dagger and Anvil, but not Hilt. Hilt works in different ways and has different goals. Hilt is largely focused around supporting android components and relies heavily on subcomponents to achieve this.</p> <p>Some features overlap but just work differently in Metro:</p> <ul> <li>Instead of <code>@UninstallModules</code> and <code>@TestInstallIn</code>, Metro graphs can exclude aggregations and contributed bindings can replace other bindings.</li> <li>Hilt has support for injecting <code>ViewModel</code>s, but this is entirely doable without Hilt as well by just creating a multibinding. See the android-app sample for an example.</li> <li>Hilt has support for aggregation with <code>@InstallIn</code>, Metro uses <code>@Contributes*</code> annotations.</li> </ul> <p>Some features are focused around injecting Android framework components. There are two arguably better solutions to this and one not-better solution.</p> <ol> <li>(Not better) Expose injector functions on a graph to do member injection directly from the graph.</li> <li>(Better) Constructor-inject these types using <code>AppComponentFactory</code>. This does require minSdk 28. When Hilt was first released in 2020, this was a relatively new API. However, 2020 was a long time ago! minSdk 28+ is much more common today, making this much more feasible of a solution.</li> <li>(Best) Use an app architecture that better abstracts away the surrounding Android framework components, making them solely entry points.</li> </ol> <p>The rest of Hilt\u2019s features focus on gluing these pieces together and also supporting Java (which Metro doesn\u2019t support).</p>"},{"location":"faq/#how-can-i-replicate-hilts-hiltandroidtest","title":"How can I replicate Hilt\u2019s <code>@HiltAndroidTest</code>?","text":"<p>Some technical context</p> <p>Hilt\u2019s <code>@HiltAndroidTest</code> and associated rule allow tests to \u201creplace\u201d bindings in a target graph even if it\u2019s compiled in another project.</p> <p>Metro supports dynamic replacements via a similar feature called dynamic graphs.</p>"},{"location":"faq/#can-metro-do-hilts-automatic-aggregation-of-transitive-dependencies-aggregated-bindings","title":"Can Metro do Hilt\u2019s automatic aggregation of transitive dependencies\u2019 aggregated bindings?","text":"<p>Some technical context</p> <p>Hilt can automatically aggregate transitive dependencies\u2019 contributed bindings even if they are not explicitly visible to the consuming project.</p> <p>In short: no. The fact that Hilt does this is a bad thing in my opinion. It essentially defeats the purpose of incremental compilation because you have to write your own version in a dedicated classpath scanning Gradle task that then generates stub sources for all the stuff you were trying to hide upstream.</p> <p>In Metro, you must play by kotlinc\u2019s native incremental compilation rules. If you want to aggregate bindings from transitive dependencies, you must expose them in that project (i.e. Gradle <code>api</code> dependencies) or explicitly declare those dependencies in the consuming project.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#familiar-semantics","title":"Familiar semantics","text":"<p>Metro builds on top of established patterns from existing DI frameworks with familiar semantics like constructor injection, providers, multibindings, scopes, assisted injection, and intrinsics like Provider/Lazy.</p>"},{"location":"features/#compile-time-validation","title":"Compile-time validation","text":"<p>Like Dagger and KI, Metro validates your dependency graph at compile-time.</p>"},{"location":"features/#compile-time-firir-code-gen","title":"Compile-time FIR+IR code gen","text":"<p>Metro is implemented entirely as a Kotlin compiler plugin, primarily using FIR for error reporting and both FIR and IR for code gen. This affords significant build performance and wins compared to Dagger and KAPT/KSP in two ways:</p> <ul> <li>It avoids extra Kotlin compiler (frontend) invocations to analyze sources and generate new sources.</li> <li>It generates new code to FIR/IR directly, allowing it to be lowered directly into target platforms</li> </ul> <p>FIR/IR generation allows Metro to generate code directly into existing classes, which in turn allows it to do certain things that source-generation cannot. This includes:</p> <ul> <li>Private <code>@Provides</code> declarations.</li> <li>Injection of private member properties and functions.</li> <li>Copying + reuse of default value expressions for optional dependencies, even if they reference private APIs within the source class.</li> </ul>"},{"location":"features/#dagger-esque-code-gen-and-runtime","title":"Dagger-esque code gen and runtime","text":"<ul> <li>Metro\u2019s generated code is similar to Dagger: lean, limited duplication, and practical.</li> <li>Metro\u2019s runtime is similar to Dagger. This includes patterns like <code>DoubleCheck</code>, heavy use of factories, and an assumption that this is going to run in a large/modularized codebase.</li> </ul>"},{"location":"features/#kotlin-inject-esque-api","title":"Kotlin-Inject-esque API","text":"<p>Metro\u2019s user-facing API is similar to kotlin-inject: focused on simplicity and leaning into kotlin-language features.</p> <ul> <li>Top-level function injection</li> <li>Providers live in graph interfaces or supertypes</li> <li>Native support for optional dependencies via default parameter values</li> <li>Use of Kotlin\u2019s native <code>Lazy</code> type for lazy injections</li> </ul>"},{"location":"features/#anvil-esque-aggregation","title":"Anvil-esque aggregation","text":"<p>Like Anvil, Metro supports contributing types via aggregation with annotations like <code>@ContributesTo</code>, <code>@ContributesBinding</code>, etc.</p>"},{"location":"features/#multiplatform","title":"Multiplatform","text":"<p>Metro is multiplatform and supports most major Kotlin multiplatform targets.</p> <p>Warning</p> <p>Multi-module multiplatform targets cannot contribute dependencies (i.e. with <code>@Contributes*</code> annotations) from native targets until https://youtrack.jetbrains.com/issue/KT-75865.</p>"},{"location":"features/#ide-integration","title":"IDE Integration","text":"<p>Most errors are reported in FIR, which should (eventually) be visible in the K2 IDE plugin as well.</p>"},{"location":"features/#helpful-diagnostics","title":"Helpful diagnostics","text":"<p>Metro tries its best to give detailed-yet-readable error messages and diagnostics.</p> <pre><code>e: ExampleGraph.kt:8:3 [Metro/MissingBinding] Cannot find an @Inject constructor or @Provides-annotated function/property for: kotlin.Int\n\n    kotlin.Int is requested at\n        [test.ExampleGraph] test.ExampleGraph.int\n\nSimilar bindings:\n  - @Named(\"qualified\") Int (Different qualifier). Type: Provided. Source: ExampleGraph.kt:11:3\n  - Number (Supertype). Type: Provided. Source: ExampleGraph.kt:10:3\n  - Set&lt;Int&gt; (Multibinding). Type: Multibinding.\n</code></pre> <p>For more thorough debugging, Metro also has controls to enable debug logging controls and write graph reports to an output directory (configurable via the Gradle extension).</p>"},{"location":"features/#advanced-interop","title":"Advanced interop","text":"<p>Metro has advanced interop with existing DI tools.</p> <ul> <li>Metro supports component-level interop with Dagger and kotlin-inject. This means that Metro graphs can depend on Dagger and kotlin-inject components via <code>@Includes</code> dependencies.</li> <li>Metro supports defining user-defined alternatives for common annotations in addition to its first-party options. This allows easier introduction to codebases using annotations from existing DI frameworks.</li> <li>If Dagger interop is enabled, Metro can generate code that both interops with Dagger/Javax/Jakarta\u2019s types directly as well as reuse Dagger/Anvil\u2019s generated factories.</li> <li>If Anvil interop is enabled, Metro\u2019s compiler can interpret Anvil\u2019s <code>@ContributesMultibinding</code> and <code>boundType</code> APIs.</li> </ul>"},{"location":"generating-metro-code/","title":"Generating Metro Code","text":"<p>Java annotation processing and KSP both support multiple rounds of processing, allowing custom processors to generate new code with injection annotations that can be processed in later rounds. Anvil supported custom <code>CodeGenerator</code> implementations in K1 and anvil-ksp and kotlin-inject-anvil support specifying custom contributing annotations to allow them to intelligently defer processing to later rounds.</p> <p>Since Metro is implemented as a compiler plugin, asking users to write compiler plugins to interact with it would be a bit unwieldy. However, KSP processors that generate metro-annotated code work out of the box with it since they run before Metro\u2019s plugin does.</p> <p>If you have an existing KSP processor for a different framework, you could leverage it + custom annotations interop support described above to make them work out of the box with Metro.</p>"},{"location":"generating-metro-code/#origin-annotations","title":"Origin Annotations","text":"<p>When code generators create Metro-annotated types, they can use the <code>@Origin</code> annotation to link the generated type back to its source. This is particularly useful for contribution merging - when a source type is excluded or replaced in a <code>@DependencyGraph</code>, any generated types with <code>@Origin</code> pointing to it will also be excluded or replaced automatically.</p> <pre><code>// Source type\n@GenerateSomething\nclass UserRepository\n\n// Generated by your KSP processor\n@ContributesBinding(AppScope::class)\n@Origin(UserRepository::class)  // Links back to the source\nclass UserRepository_Impl : UserRepository\n</code></pre> <p>Now if <code>UserRepository</code> is excluded in a graph:</p> <pre><code>@DependencyGraph(\n  scope = AppScope::class,\n  excludes = [UserRepository::class]  // This also excludes UserRepository_Impl\n)\ninterface AppGraph\n</code></pre>"},{"location":"generating-metro-code/#custom-origin-annotations","title":"Custom Origin Annotations","text":"<p>You can configure Metro to recognize custom origin annotations through the Gradle plugin:</p> <pre><code>metro {\n  interop {\n    origin.add(\"com.example.GeneratedFrom\")\n  }\n}\n</code></pre> <p>The annotation must have a <code>KClass</code> parameter at index <code>0</code>.</p> <p>If using Anvil interop, kotlin-inject-anvil\u2019s <code>@Origin</code> annotation is automatically recognized.</p> <pre><code>metro {\n  interop {\n    includeAnvil(includeKotlinInjectAnvil = true)\n  }\n}\n</code></pre>"},{"location":"graph-analysis/","title":"Graph Analysis &amp; Visualization","text":"<p>Metro provides Gradle tasks for analyzing and visualizing dependency graphs. These tools help you understand your dependency structure, identify potential issues, and debug complex graphs.</p>"},{"location":"graph-analysis/#setup","title":"Setup","text":"<p>Graph analysis requires setting the <code>reportsDestination</code> property in your Metro configuration:</p> <p>Warning</p> <p>You should not leave this enabled by default as it can be quite verbose and potentially expensive. This property also does not participate in task inputs, so you may need to recompile with <code>--rerun</code> to force recompilation after adding this flag.</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"reports/metro\"))\n}\n</code></pre> <p>This enables the compiler to export graph metadata during compilation.</p>"},{"location":"graph-analysis/#available-tasks","title":"Available Tasks","text":"<p>Warning</p> <p>These tasks are purely for analysis and visualization. They are not intended for continuous validation at the moment due to the caveats with <code>reportsDestination</code> mentioned above.</p>"},{"location":"graph-analysis/#generatemetrographmetadata","title":"<code>generateMetroGraphMetadata</code>","text":"<p>Generates raw JSON metadata files for each dependency graph in your project. This task runs automatically during compilation when <code>reportsDestination</code> is set.</p> <p>Output: <code>{reportsDestination}/{sourceSet}/graph-metadata/graph-{fully.qualified.GraphName}.json</code></p> <p>You typically don\u2019t need to run this task directly, it\u2019s a dependency of the other analysis tasks.</p>"},{"location":"graph-analysis/#analyzemetrograph","title":"<code>analyzeMetroGraph</code>","text":"<p>Aggregates all graph metadata and produces a comprehensive analysis report.</p> <pre><code>./gradlew :app:analyzeMetroGraph\n</code></pre> <p>Output: <code>build/reports/metro/analysis.json</code></p> <p>This task combines all individual graph JSON files into a single aggregated file and runs various graph analysis algorithms. The output can be used for further analysis or consumed by other tools.</p>"},{"location":"graph-analysis/#generatemetrographhtml","title":"<code>generateMetroGraphHtml</code>","text":"<p>Generates interactive HTML visualizations of your dependency graphs using Apache ECharts.</p> <pre><code>./gradlew :app:generateMetroGraphHtml\n</code></pre> <p>Output: <code>{reportsDestination}/html/</code> containing:</p> <ul> <li><code>index.html</code> - Landing page listing all graphs</li> <li><code>{graph-name}.html</code> - Interactive visualization for each graph</li> </ul> <p>Open the HTML files directly in a browser, they\u2019re fully self-contained with no external dependencies.</p>"},{"location":"graph-analysis/#interactive-visualization-features","title":"Interactive Visualization Features","text":"<p>The generated HTML visualizations provide powerful tools for exploring your dependency graphs:</p>"},{"location":"graph-analysis/#navigation","title":"Navigation","text":"<ul> <li>Drag nodes to rearrange the layout</li> <li>Scroll to zoom in/out</li> <li>Click a node to view its details and highlight the path back to the graph root</li> <li>Double-click or press ESC to clear path highlighting</li> <li>Hover over nodes and edges for tooltips</li> </ul>"},{"location":"graph-analysis/#layout-modes","title":"Layout Modes","text":"<ul> <li>Force - Physics-based layout that automatically positions nodes</li> <li>Circular - Arranges nodes in a circle</li> </ul>"},{"location":"graph-analysis/#filtering","title":"Filtering","text":"<p>Multiple filters can be combined to focus on specific parts of your graph:</p> Filter Description Search Filter nodes by name or full type key Show synthetic bindings Toggle visibility of generated/internal bindings (aliases, contributions) Show only scoped bindings Hide non-scoped bindings to focus on singletons Show default value bindings Toggle visibility of synthetic nodes for default parameter values Show metrics glow Toggle the glow effects highlighting nodes with notable metrics Package filter Toggle visibility by package (collapsed by default)"},{"location":"graph-analysis/#analysis-tools","title":"Analysis Tools","text":"<ul> <li>Show Longest Path - Highlights the longest dependency chain in your graph, useful for identifying deep dependency trees</li> </ul>"},{"location":"graph-analysis/#understanding-the-visualization","title":"Understanding the Visualization","text":""},{"location":"graph-analysis/#node-shapes","title":"Node Shapes","text":"Shape Meaning Diamond Main <code>@DependencyGraph</code> Rounded Rectangle <code>@GraphExtension</code> Circle with magenta border Scoped binding (<code>@SingleIn</code>) Circle Regular binding <p>Larger nodes indicate more significant bindings (graphs, extensions, scoped).</p> <p>Full Legend</p> <p>The HTML visualization includes a complete interactive legend at the bottom of the chart showing all binding kinds and their colors. Expand the \u201cEdge Types\u201d section in the sidebar for edge styling details.</p>"},{"location":"graph-analysis/#node-colors","title":"Node Colors","text":"<p>Nodes are colored by binding kind:</p> Color Binding Kind Blue Constructor-injected (<code>@Inject</code>) Green Provided (<code>@Provides</code>) Gray Alias (<code>@Binds</code>) Light Blue Bound instance (graph itself or <code>@Provides</code> parameters) Pink Multibinding (<code>Set&lt;T&gt;</code> or <code>Map&lt;K,V&gt;</code>) Purple Graph extension Peach Assisted injection <p>Synthetic (generated) bindings appear gray and with reduced opacity. They do give you a good sense of the glue that Metro generates behind the scenes.</p>"},{"location":"graph-analysis/#metrics-glow-effects","title":"Metrics Glow Effects","text":"<p>Nodes with notable analysis metrics are highlighted with glow effects to draw attention to potential architectural concerns:</p> Glow Color Trigger Meaning Red Centrality in top 10% Critical connector - many paths flow through it Yellow Centrality in top 25% Moderate connector - notable traffic hub Red Dominator count &gt; 10% of graph Dominates many bindings - initialization bottleneck Blue Fan-in in top 10% Highly depended-upon - changes affect many consumers <p>Dynamic Thresholds</p> <p>Glow thresholds are computed dynamically based on graph size and metrics distribution. This ensures meaningful highlighting for both small (10 nodes) and large (500+ nodes) graphs.</p> <p>Use the \u201cShow metrics glow\u201d filter to toggle these effects on/off.</p>"},{"location":"graph-analysis/#metrics-heatmap-colors","title":"Metrics Heatmap Colors","text":"<p>In tooltips and the details panel, analysis metrics are color-coded by severity:</p> Metric Blue (Good) Yellow (Moderate) Red (High) Fan-in \u2264 5 6-10 &gt; 10 Fan-out \u2264 4 5-8 &gt; 8 Centrality \u2264 10% 10-30% &gt; 30% Dominator count \u2264 5 6-10 &gt; 10 <p>These thresholds help identify bindings that may warrant architectural review.</p>"},{"location":"graph-analysis/#edge-types","title":"Edge Types","text":"<p>Edges are styled to indicate the relationship type:</p> Style Meaning What to Look For Gray, solid Normal dependency Standard injection Light blue, thick Accessor (graph entry point) These are your graph\u2019s public API (accessor properties and functions) Magenta, dashed Inherited binding Extension accessing parent graph\u2019s scoped binding Cyan, dashed Deferrable (<code>Provider</code>/<code>Lazy</code>) Often used to defer initialization or break cycles Orange, thick Assisted injection Runtime parameters passed to factories Purple Multibinding contribution Source bindings feeding into a multibound <code>Set</code> or <code>Map</code> Gray, dotted Alias <code>@Binds</code> type mapping Gray, dashed (faded) Optional Has a default value"},{"location":"graph-analysis/#reading-the-analysis","title":"Reading the Analysis","text":""},{"location":"graph-analysis/#understanding-graph-structure","title":"Understanding Graph Structure","text":"<p>Entry points (roots): The graph\u2019s entry points are tracked in the <code>roots</code> metadata object, separate from binding dependencies. This includes:</p> <ul> <li>Accessors - Properties on the graph interface that expose bindings (e.g., <code>val serviceA: ServiceA</code>)</li> <li>Injectors - Functions that inject dependencies into targets (e.g., <code>fun inject(target: Activity)</code>)</li> </ul> <p>Light blue edges from the main graph (diamond) show these entry points\u2014your graph\u2019s public API. The analysis infrastructure creates edges from the graph to accessor targets when building the graph structure.</p> <p>Graph extensions: Rounded rectangle nodes show <code>@GraphExtension</code> types. Extension information is tracked in the <code>extensions</code> metadata object:</p> <ul> <li>accessors - Non-factory extension accessors</li> <li>factoryAccessors - Factory accessors that create extension instances</li> <li>factoriesImplemented - Factory interfaces this graph implements</li> </ul> <p>Magenta dashed edges indicate which scoped bindings extensions inherit from the parent graph.</p> <p>Binding flow: Follow edges from entry points inward to understand how dependencies are resolved. The direction of arrows shows the \u201cdepends on\u201d relationship.</p>"},{"location":"graph-analysis/#tips","title":"Tips","text":""},{"location":"graph-analysis/#identifying-issues","title":"Identifying Issues","text":"<p>Deep dependency chains: Use \u201cShow Longest Path\u201d to find the deepest dependency chain. Very long paths may indicate:</p> <ul> <li>Overly coupled code</li> <li>Missing abstractions</li> <li>Opportunities to defer dependencies with <code>Provider</code>/<code>Lazy</code></li> </ul> <p>Too many scoped bindings: Filter to \u201cShow only scoped bindings\u201d. If you have many scoped bindings:</p> <ul> <li>Consider if all truly need to be singletons</li> <li>Scoped bindings add memory overhead and complexity</li> <li>Some may be candidates for unscoped bindings</li> </ul> <p>Complex multibindings: Look for pink nodes with many incoming purple edges. Large multibindings may indicate:</p> <ul> <li>Plugin systems that could be simplified</li> <li>Opportunities to use more targeted bindings</li> </ul> <p>Circular dependencies: While Metro prevents true cycles, you may see near-cycles broken by <code>Provider</code>/<code>Lazy</code> (cyan dashed edges). Many of these may indicate:</p> <ul> <li>Tightly coupled components</li> <li>Opportunities for refactoring</li> </ul>"},{"location":"graph-analysis/#performance","title":"Performance","text":"<p>For large graphs, the force layout may take a moment to stabilize. You can:</p> <ul> <li>Use the circular layout for a quicker overview</li> <li>Filter to specific packages to reduce complexity</li> <li>Hide synthetic bindings to focus on your code</li> </ul>"},{"location":"graph-analysis/#debugging","title":"Debugging","text":"<p>When investigating a specific binding:</p> <ol> <li>Use the search box to find it</li> <li>Click the node to see its details panel</li> <li>Review its dependencies and dependents</li> <li>Follow edges to understand the resolution path</li> </ol>"},{"location":"graph-analysis/#sharing","title":"Sharing","text":"<p>The HTML files are self-contained and can be:</p> <ul> <li>Committed to version control for historical comparison</li> <li>Shared with team members</li> <li>Attached to code reviews for dependency discussions</li> </ul>"},{"location":"graph-analysis/#example-workflow","title":"Example Workflow","text":"<pre><code># Generate visualizations\n./gradlew :app:generateMetroGraphHtml\n\n# Open in browser\nopen app/build/reports/metro/html/index.html\n</code></pre> <p>Then in the visualization:</p> <ol> <li>Click your main graph in the index</li> <li>Use \u201cShow Longest Path\u201d to understand depth</li> <li>Filter to \u201cShow only scoped bindings\u201d to review singletons</li> <li>Search for specific types you\u2019re investigating</li> <li>Click nodes to explore their dependencies</li> </ol>"},{"location":"graph-analysis/#analysis-metrics","title":"Analysis Metrics","text":"<p>The <code>analyzeMetroGraph</code> task computes several metrics that help identify architectural issues. Here\u2019s what each metric means and how to use it.</p>"},{"location":"graph-analysis/#fan-in-and-fan-out","title":"Fan-In and Fan-Out","text":"<p>What it measures: How many things depend on a binding (fan-in) and how many things a binding depends on (fan-out).</p> Metric Meaning Fan-In Number of other bindings that depend on this one Fan-Out Number of dependencies this binding requires <p>How to interpret:</p> <ul> <li> <p>High fan-in = Many things depend on this binding. It\u2019s a \u201cpopular\u201d dependency.</p> <ul> <li>Good: Core utilities, interfaces, shared services</li> <li>Warning sign: If it changes frequently, many things break</li> <li>Action: Ensure high fan-in bindings have stable APIs and good test coverage</li> </ul> </li> <li> <p>High fan-out = This binding depends on many things. It has lots of dependencies.</p> <ul> <li>Warning sign: May be doing too much (violates Single Responsibility)</li> <li>Action: Consider breaking into smaller, focused classes</li> </ul> </li> <li> <p>High fan-in AND high fan-out = A \u201chub\u201d that\u2019s both heavily used and complex</p> <ul> <li>Warning sign: Changes here are risky and have wide impact</li> <li>Action: Prioritize for refactoring; consider splitting responsibilities</li> </ul> </li> </ul>"},{"location":"graph-analysis/#betweenness-centrality","title":"Betweenness Centrality","text":"<p>What it measures: How often a binding lies on the shortest path between other bindings. Think of it as measuring how much of a \u201cbottleneck\u201d or how sticky a binding is.</p> <p>In simple terms: If you imagine dependencies flowing through your graph like traffic, high betweenness centrality means lots of traffic flows through this binding to get elsewhere.</p> <p>How to interpret:</p> <ul> <li> <p>High centrality = This binding is a critical connector in your graph</p> <ul> <li>Many dependency chains pass through it</li> <li>It\u2019s a potential bottleneck for initialization</li> <li>Changes here can have ripple effects</li> </ul> </li> <li> <p>What to do with high-centrality bindings:</p> <ul> <li>Review for stability, these should rarely change</li> <li>Consider if they\u2019re doing too much coordination</li> <li>May indicate a missing abstraction layer</li> <li>Good candidates for careful interface design</li> </ul> </li> </ul> <p>Example: If <code>NetworkClient</code> has high betweenness centrality, it means many different parts of your app depend on things that go through <code>NetworkClient</code>. This is expected for infrastructure, but surprising for business logic.</p>"},{"location":"graph-analysis/#dominator-analysis","title":"Dominator Analysis","text":"<p>What it measures: A binding D \u201cdominates\u201d binding N if every path from the graph root to N must go through D. In other words, you can\u2019t reach N without first going through D.</p> <p>In simple terms: Dominators are mandatory waypoints. If <code>AuthManager</code> dominates <code>UserProfile</code>, then there\u2019s no way to create a <code>UserProfile</code> without first having an <code>AuthManager</code>.</p> <p>How to interpret:</p> <ul> <li> <p>High dominator count = Many bindings can only be reached through this one</p> <ul> <li>It\u2019s a gatekeeper in your dependency structure</li> <li>If it fails to initialize, everything it dominates also fails</li> </ul> </li> <li> <p>What to do with high-dominator bindings:</p> <ul> <li>Ensure they initialize quickly and reliably</li> <li>Consider if the dominance is intentional (auth gates make sense) or accidental</li> <li>May indicate overly tight coupling if unexpected</li> <li>Good candidates for early initialization and error handling</li> </ul> </li> </ul> <p>Example: If <code>DatabaseConnection</code> dominates 50 bindings, all 50 of those bindings require the database. Ask: do they all really need the database, or could some work offline?</p>"},{"location":"graph-analysis/#longest-path-analysis","title":"Longest Path Analysis","text":"<p>What it measures: The deepest chain of dependencies from any entry point to a leaf binding.</p> <p>In simple terms: How many \u201chops\u201d does the deepest dependency chain take? If creating <code>A</code> requires <code>B</code> which requires <code>C</code> which requires <code>D</code>, that\u2019s a path of length 4.</p> <p>How to interpret:</p> <ul> <li> <p>Long paths (10+ nodes) may indicate:</p> <ul> <li>Deeply nested architecture</li> <li>Potential for slow initialization (each hop adds time)</li> <li>Complex debugging when something fails deep in the chain</li> </ul> </li> <li> <p>What to do about long paths:</p> <ul> <li>Look for opportunities to flatten the hierarchy</li> <li>Consider if intermediate layers add value</li> <li>Use <code>Provider</code>/<code>Lazy</code> to defer initialization of deep branches</li> <li>May indicate \u201cwrapper\u201d classes that just delegate</li> </ul> </li> </ul>"},{"location":"graph-analysis/#shortest-paths-to-root","title":"Shortest Paths to Root","text":"<p>What it measures: The shortest path from each binding back to the graph root, computed using Dijkstra\u2019s algorithm.</p> <p>In simple terms: For any binding, what\u2019s the most direct route back to where it\u2019s consumed by the graph? This is precomputed during analysis and used to power the path highlighting feature in the visualization.</p> <p>How to use it:</p> <ul> <li>Click any node in the visualization to highlight its path back to the graph root</li> <li>The path shows the minimum number of hops to reach that binding from the graph\u2019s entry points</li> <li>Useful for understanding how deeply nested a binding is in the dependency structure</li> <li>Helps trace the resolution path when debugging injection issues</li> </ul> <p>In the analysis JSON: <pre><code>val pathsToRoot = graph.pathsToRoot\nval path = pathsToRoot.paths[\"com.example.MyService\"]\n// Returns: [\"MyService\", \"MyRepository\", \"AppGraph\"] (from binding to root)\n</code></pre></p>"},{"location":"graph-analysis/#root-and-leaf-analysis","title":"Root and Leaf Analysis","text":"<p>What it measures:</p> <ul> <li>Roots: Bindings with no dependents (nothing depends on them). These are typically your entry points \u2014 accessors on the graph.</li> <li>Leaves: Bindings with no dependencies. These are the \u201cbottom\u201d of your graph \u2014 things that don\u2019t need anything else.</li> </ul> <p>How to interpret:</p> <ul> <li> <p>Many roots = Your graph exposes many entry points</p> <ul> <li>Expected for large graphs with rich APIs</li> <li>Consider if all roots are necessary</li> </ul> </li> <li> <p>Many leaves = Lots of \u201cprimitive\u201d bindings at the bottom</p> <ul> <li>Often configuration values, constants, or external dependencies</li> <li>Expected for well-factored code</li> </ul> </li> <li> <p>Binding that\u2019s both root AND leaf = Isolated binding</p> <ul> <li>Nothing depends on it and it depends on nothing</li> <li>Worth investigating, this might be dead code</li> </ul> </li> </ul>"},{"location":"graph-analysis/#putting-it-all-together","title":"Putting It All Together","text":"<p>When analyzing a graph, look for patterns:</p> Pattern What It Suggests Action High fan-in + high centrality Critical infrastructure binding Stabilize API, add tests High fan-out + low fan-in Complex internal implementation Consider splitting High dominator count Initialization bottleneck Ensure fast, reliable init Very long paths Deep coupling Look for flattening opportunities High fan-in + high dominator True architectural cornerstone Document, protect, version carefully"},{"location":"graph-analysis/#programmatic-access","title":"Programmatic Access","text":"<p>The JSON outputs can be consumed programmatically for custom analysis.</p>"},{"location":"graph-analysis/#raw-metadata","title":"Raw Metadata","text":"<p>The raw graph metadata from <code>generateMetroGraphMetadata</code>:</p> <pre><code>// Parse raw graph metadata\nval metadata = Json.decodeFromString&lt;AggregatedGraphMetadata&gt;(\n    file(\"build/reports/metro/graphMetadata.json\").readText()\n)\n\n// Analyze bindings\nval scopedCount = metadata.graphs.sumOf { graph -&gt;\n    graph.bindings.count { it.isScoped }\n}\nprintln(\"Total scoped bindings: $scopedCount\")\n\n// Check entry points\nfor (graph in metadata.graphs) {\n    println(\"Graph: ${graph.graph}\")\n    graph.roots?.let { roots -&gt;\n        println(\"  Accessors: ${roots.accessors.size}\")\n        println(\"  Injectors: ${roots.injectors.size}\")\n    }\n    graph.extensions?.let { ext -&gt;\n        println(\"  Extension factories: ${ext.factoriesImplemented.size}\")\n    }\n}\n</code></pre> <p>The raw metadata includes:</p> <ul> <li>roots - Entry points into the graph<ul> <li><code>accessors</code> - Properties exposing bindings from the graph</li> <li><code>injectors</code> - Functions that inject dependencies into targets</li> </ul> </li> <li>extensions - Graph extension information<ul> <li><code>accessors</code> - Non-factory extension accessors</li> <li><code>factoryAccessors</code> - Factory accessors (with <code>isSAM</code> flag)</li> <li><code>factoriesImplemented</code> - Factory interfaces this graph implements</li> </ul> </li> <li>bindings - All bindings with their kinds, scopes, and dependencies</li> <li>Multibinding information (sources, collection type)</li> <li>Origin locations (file and line numbers)</li> <li>Synthetic binding flags</li> </ul>"},{"location":"graph-analysis/#analysis-report","title":"Analysis Report","text":"<p>The analysis report from <code>analyzeMetroGraph</code> is organized by graph, with all analysis data grouped together:</p> <pre><code>// Parse analysis report\nval report = Json.decodeFromString&lt;FullAnalysisReport&gt;(\n    file(\"build/reports/metro/analysis.json\").readText()\n)\n\n// Each graph has all its analysis co-located\nfor (graph in report.graphs) {\n    println(\"Graph: ${graph.graphName}\")\n    println(\"  Bindings: ${graph.statistics.totalBindings}\")\n    println(\"  Scoped: ${graph.statistics.scopedBindings}\")\n    println(\"  Longest path: ${graph.longestPath.longestPathLength}\")\n\n    // High fan-in bindings\n    graph.fanAnalysis.highFanIn.take(3).forEach { binding -&gt;\n        println(\"  High fan-in: ${binding.key} (${binding.fanIn} dependents)\")\n    }\n}\n</code></pre> <p>The analysis report structure:</p> <pre><code>data class FullAnalysisReport(\n    val projectPath: String,\n    val graphs: List&lt;GraphAnalysis&gt;  // All analysis grouped by graph\n)\n\ndata class GraphAnalysis(\n    val graphName: String,\n    val statistics: GraphStatistics,    // Binding counts, averages\n    val longestPath: LongestPathResult, // Deepest dependency chains\n    val dominator: DominatorResult,     // Dominator tree analysis\n    val centrality: CentralityResult,   // Betweenness centrality scores\n    val fanAnalysis: FanAnalysisResult, // Fan-in/fan-out metrics\n    val pathsToRoot: PathsToRootResult  // Shortest paths from each node to graph root\n)\n</code></pre>"},{"location":"injection-types/","title":"Injection Types","text":"<p>Metro supports multiple common injection types.</p>"},{"location":"injection-types/#constructor-injection","title":"Constructor Injection","text":"<p>Most types should use constructor injection if possible. For this case, you can annotate either a class itself (if it has exactly one, primary constructor) or exactly one specific constructor.</p> <pre><code>@Inject\nclass ClassInjected\n\nclass SpecificConstructorInjection(val text: String) {\n  @Inject constructor(value: Int) : this(value.toString())\n}\n</code></pre> <p>Constructor-injected classes can be instantiated+managed entirely by Metro and encourages immutability.</p>"},{"location":"injection-types/#assisted-injection","title":"Assisted Injection","text":"<p>For types that require dynamic dependencies at instantiation, assisted injection can be used to supply these inputs. In this case - an injected constructor (or class with one constructor) must be annotated with <code>@AssistedInject</code>, assisted parameters annotated with <code>@Assisted</code>, and a factory interface or abstract class with one single abstract function that accepts these assisted parameters and returns the target class.</p> <pre><code>@AssistedInject\nclass HttpClient(\n  @Assisted val timeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeout: Duration): HttpClient\n  }\n}\n</code></pre> <p>Then, the <code>@AssistedFactory</code>-annotated type can be accessed from the dependency graph.</p> <pre><code>@Inject\nclass ApiClient(httpClientFactory: HttpClient.Factory) {\n  private val httpClient = httpClientFactory.create(30.seconds)\n}\n</code></pre> <p>Like Dagger, the <code>@Assisted</code> parameters can take optional <code>value</code> keys to disambiguate matching types.</p> <pre><code>@AssistedInject\nclass HttpClient(\n  @Assisted(\"connect\") val connectTimeout: Duration,\n  @Assisted(\"request\") val requestTimeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(\n      @Assisted(\"connect\") connectTimeout: Duration,\n      @Assisted(\"request\") requestTimeout: Duration,\n    ): HttpClient\n  }\n}\n</code></pre>"},{"location":"injection-types/#automatic-assisted-factory-generation","title":"Automatic Assisted Factory Generation","text":"<p>Metro supports automatic generation of assisted factories via opt-in compiler option. If enabled, Metro will automatically generate a default factory as a nested class within the injected type.</p> <pre><code>@AssistedInject\nclass HttpClient(\n  @Assisted timeoutDuration: Duration,\n  cache: Cache,\n) {\n  // Generated by Metro\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeoutDuration: Duration): HttpClient\n  }\n}\n</code></pre> <p>If a nested class called <code>Factory</code> is already present, Metro will do nothing.</p>"},{"location":"injection-types/#why-opt-in","title":"Why opt-in?","text":"<p>The main reason this is behind an opt-in option at the moment is because compiler plugin IDE support requires some rudimentary configuration to work. See the docs for how to enable IDE support.</p> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  generateAssistedFactories.set(true)\n}\n</code></pre>"},{"location":"injection-types/#member-injection","title":"Member Injection","text":"<p>Metro supports member injection to inject mutable properties or functions post-construction or into existing class instances.</p> <p>This can be useful for classes that cannot be constructor-injected, for example Android Activity classes (on older SDK versions) as well as constructor-injected classes that perhaps don\u2019t want or need to expose certain types directly in their constructors.</p> <p>Tip</p> <p>Unlike Dagger and kotlin-inject, injected members in Metro can be <code>private</code>.</p> <p>Note</p> <p>Member function injection does not (currently) support default values.</p> <pre><code>class ProfileActivity : Activity() {\n  // Property injection\n  @Inject private lateinit var db: UserDatabase\n\n  @Inject private var notifications: Notifications? = null\n\n  // Function injection\n  @Inject private fun injectUser(user: User) {\n    // ...\n  }\n}\n</code></pre> <p>Like Dagger, these classes can be injected via multiple avenues.</p>"},{"location":"injection-types/#1-in-constructor-injected-types-inject-annotated-members-are-injected-automatically","title":"1. In constructor-injected types, <code>@Inject</code>-annotated members are injected automatically.","text":"<pre><code>// Injection with constructor injection\n@Inject\nclass ProfileInjector(\n  // ...\n) {\n  // Automatically injected during constructor injection\n  @Inject private fun injectUser(value: String) {\n    // ...\n  }\n}\n</code></pre> <p>In these cases, Metro will automatically inject these members automatically and immediately after instantiation during constructor injection.</p>"},{"location":"injection-types/#2-exposing-a-fun-injecttarget-profileactivity-function-on-the-graph","title":"2. Exposing a <code>fun inject(target: ProfileActivity)</code> function on the graph","text":"<pre><code>// Graph inject() functions\n@DependencyGraph\ninterface AppGraph {\n  // ...\n\n  fun inject(target: ProfileActivity)\n}\n\n// Somewhere else\nval graph = createGraph&lt;AppGraph&gt;()\ngraph.inject(profileActivity)\n</code></pre> <p>With this option, you can call <code>graph.inject(target)</code> on the instance with members you wish to inject.</p>"},{"location":"injection-types/#3-requesting-a-membersinjector-instance-from-the-dependency-graph","title":"3. Requesting a <code>MembersInjector</code> instance from the dependency graph.","text":"<pre><code>// Injection with MembersInjector\n@Inject\nclass ProfileInjector(\n  private val injector: MembersInjector&lt;ProfileActivity&gt;\n) {\n  fun performInjection(activity: ProfileActivity) {\n    injector.inject(activity)\n  }\n}\n</code></pre> <p>Like Dagger, option #3 is accomplished via <code>MembersInjector</code> interface at runtime and in code gen. This should be reserved for advanced use cases.</p> Implementation Notes <ul> <li>Property accessors don\u2019t use <code>get</code>/<code>set</code> names in <code>inject{name}()</code> function names.</li> <li>MembersInjector classes are generated as nested classes, allowing private member access.<ul> <li>This includes parent classes\u2019 private members (!!)</li> </ul> </li> <li>optional dependencies are not supported for injected member functions currently, but may be possible in the future.</li> </ul>"},{"location":"injection-types/#top-level-function-injection","title":"Top-level Function Injection","text":"<p>Like KI, Metro supports top-level function injection (behind an opt-in compiler option). The primary use case for this is composable functions and standalone applications that run from <code>main</code> functions.</p> <pre><code>@Inject\nfun App(message: String) {\n  // ...\n}\n</code></pre> <p>To do this, Metro\u2019s FIR plugin will generate a concrete type that acts as a bridge for this function.</p> <pre><code>@Inject\nclass AppClass(\n  private val message: Provider&lt;String&gt;\n) {\n  operator fun invoke() {\n    App(message())\n  }\n}\n</code></pre> <p>Because it\u2019s generated in FIR, this type will be user-visible in the IDE and can then be referenced in a graph.</p> <p>Note that this feature requires enabling third party FIR plugins in the IDE to fully work. It will compile without it, but generated wrapper classes will be red/missing in the IDE.</p> <p>Note</p> <p>The generated class is called <code>&lt;function name&gt;</code> + <code>Class</code> because of a limitation in the Kotlin compiler. TODO Link issue?</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val app: AppClass\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n\n// Usage\nval app = createGraphFactory&lt;AppGraph.Factory&gt;()\n  .create(\"Hello, world!\")\n  .app\n\n// Run the app\napp()\n</code></pre> <p>To add assisted parameters, use <code>@Assisted</code> on the parameters in the function description. These will be propagated accordingly.</p> <pre><code>@Inject\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval app = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Run the app\napp(\"Hello, world!\")\n</code></pre> <p>This is particularly useful for Compose, and <code>@Composable</code> functions will be copied over accordingly.</p> <pre><code>@Inject\n@Composable\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  @Composable\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval App = createGraph&lt;AppGraph&gt;().app\n\n// Call it in composition\nsetContent {\n  App(\"Hello, world!\")\n}\n</code></pre> <p>Similarly, if the injected function is a <code>suspend</code> function, the <code>suspend</code> keyword will be ported to the generated <code>invoke()</code> function too.</p>"},{"location":"injection-types/#context-parameters","title":"Context parameters","text":"<p>Top-level injected functions also support context parameters. Both regular and context parameters may be assisted.</p> <p>Any assisted context parameters will be carried as context parameters to the generated class\u2019s <code>invoke()</code> function.</p> SourceGenerated <pre><code>@Inject\n@Composable\ncontext(@Assisted sharedTransitionScope: SharedTransitionScope)\nfun ClockWidget(\n  clock: Clock, // injected\n  @Assisted modifier: Modifier, // assisted inject\n) {\n  // ...\n}\n</code></pre> <pre><code>@Inject\nclass ClockWidgetClass(private val clock: Provider&lt;Clock&gt;) {\n  @Composable\n  context(sharedTransitionScope: SharedTransitionScope)\n  operator fun invoke(modifier: Modifier) {\n    ClockWidget(clock(), modifier)\n  }\n}\n</code></pre>"},{"location":"injection-types/#why-opt-in_1","title":"Why opt-in?","text":"<p>There are three reasons this is behind an opt-in option at the moment.</p> <ol> <li>Generating top-level declarations in Kotlin compiler plugins (in FIR specifically) is not    currently compatible with incremental compilation on the JVM.</li> <li>Generating top-level declarations in Kotlin compiler plugins (in FIR specifically) is not    currently compatible with non-JVM targets.</li> <li>IDE support is rudimentary at best and currently requires enabling a custom registry flag.    See the docs for how to enable IDE support.</li> </ol> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  enableTopLevelFunctionInjection.set(true)\n}\n</code></pre> Implementation Notes <ul> <li>This is fairly different from kotlin-inject\u2019s typealias approach. This is necessary because Metro doesn\u2019t use higher order function types or typealiases as qualifiers.</li> <li>Since the compose-compiler\u2019s IR transformer may run before Metro\u2019s, we check for this during implementation body generation and look up the transformed target composable function as needed.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Metro is primarily applied via its companion Gradle plugin.</p> <pre><code>plugins {\n  kotlin(\"multiplatform\") // or jvm, android, etc\n  id(\"dev.zacsweers.metro\")\n}\n</code></pre> <p>\u2026and that\u2019s it! This will add metro\u2019s runtime dependencies and do all the necessary compiler plugin wiring.</p> <p>If applying in other build systems, apply it however that build system conventionally applies Kotlin compiler plugins. For example with Bazel:</p> <pre><code>load(\"@rules_kotlin//kotlin:core.bzl\", \"kt_compiler_plugin\")\nload(\"@rules_kotlin//kotlin:jvm.bzl\", \"kt_jvm_library\")\n\nkt_compiler_plugin(\n    name = \"metro_plugin\",\n    compile_phase = True,\n    id = \"dev.zacsweers.metro.compiler\",\n    options = {\n        \"enabled\": \"true\",\n        \"debug\": \"false\",\n    },\n    deps = [\n        \"@maven//:dev_zacsweers_metro_compiler\",\n    ],\n)\n\nkt_jvm_library(\n    name = \"sample\",\n    # The SampleGraph class is annotated with @DependencyGraph\n    srcs = [\"SampleGraph.kt\"],\n    plugins = [\n        \":metro_plugin\",\n    ],\n    deps = [\n        \"@maven//:dev_zacsweers_metro_runtime_jvm\",\n    ],\n)\n</code></pre>"},{"location":"installation/#ide-support","title":"IDE Support","text":"<p>The K2 Kotlin IntelliJ plugin supports running third party FIR plugins in the IDE, but this feature is hidden behind a flag. Some Metro features can take advantage of this, namely diagnostic reporting directly in the IDE and some opt-in features to see generated declarations. </p> <p>To enable it, do the following:</p> <ol> <li>Enable K2 Mode for the Kotlin IntelliJ plugin.</li> <li>Open the Registry</li> <li>Set the <code>kotlin.k2.only.bundled.compiler.plugins.enabled</code> entry to <code>false</code>.</li> </ol> <p>Note that support is unstable and subject to change.</p>"},{"location":"interop/","title":"Interop","text":""},{"location":"interop/#annotations","title":"Annotations","text":"<p>Metro supports user-defined annotations for common annotations. This means that a user doesn\u2019t necessarily have to use Metro\u2019s annotations if they\u2019re introducing it to an existing codebase. Support varies depending on the annotation\u2019s use case.</p> <p>Compile-only annotations are mostly supported. This includes the following:</p> <ul> <li><code>@AssistedFactory</code></li> <li><code>@AssistedInject</code></li> <li><code>@Assisted</code></li> <li><code>@BindsInstance</code></li> <li><code>@Binds</code></li> <li><code>@ContributesBinding</code></li> <li><code>@ContributesTo</code></li> <li><code>@DependencyGraph.Factory</code></li> <li><code>@DependencyGraph</code></li> <li><code>@ElementsIntoSet</code></li> <li><code>@Inject</code></li> <li><code>@IntoMap</code></li> <li><code>@IntoSet</code></li> <li><code>@MapKey</code></li> <li><code>@Module</code></li> <li><code>@Multibinds</code></li> <li><code>@Provides</code></li> <li><code>@Qualifier</code></li> <li><code>@Scope</code></li> </ul> <p>These are configurable via Metro\u2019s Gradle extension.</p> <pre><code>metro {\n  interop {\n    assisted.add(\"dagger/assisted/Assisted\")\n  }\n}\n</code></pre> <p>For Dagger and KI specifically, there are convenience helper functions.</p> <pre><code>metro {\n  interop {\n    // Dagger\n    includeDagger()\n    includeAnvilForDagger()\n\n    // kotlin-inject\n    includeKotlinInject()\n    includeAnvilForKotlinInject()\n\n    // Guice\n    includeGuice()\n  }\n}\n</code></pre> <p><code>@DependencyGraph</code> is replaceable but your mileage may vary if you use Anvil or modules, since Metro\u2019s annotation unifies Anvil\u2019s <code>@MergeComponent</code> functionality and doesn\u2019t support modules.</p> <p>Similarly, <code>@ContributesBinding</code> is replaceable but there are not direct analogues for Anvil\u2019s <code>@ContributesMultibinding</code> or kotlin-inject-anvil\u2019s <code>@ContributesBinding(multibinding = \u2026)</code> as these annotations are implemented as <code>@ContributesInto*</code> annotations in Metro.</p> <p><code>binding</code> in Metro uses a more flexible mechanism to support generics, but interop with Anvil\u2019s <code>boundType: KClass&lt;*&gt;</code> property is supported.</p>"},{"location":"interop/#components","title":"Components","text":"<p>Metro graphs can interop with components generated by Dagger and Kotlin-Inject. These work exclusively through their public accessors and can be depended on like any other graph dependency.</p> <pre><code>@DependencyGraph\ninterface MetroGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(\n      @Includes daggerComponent: DaggerComponent\n    ): MetroGraph\n  }\n}\n\n@dagger.Component\ninterface DaggerComponent {\n  val message: String\n\n  @dagger.Component.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): DaggerComponent\n  }\n}\n</code></pre> <p>Conversely, kotlin-inject and Dagger components can also depend on Metro graphs.</p> <pre><code>@DependencyGraph\ninterface MessageGraph {\n  val message: String\n\n  // ...\n}\n\n// Dagger\n@Component(dependencies = [MessageGraph::class])\ninterface DaggerComponent {\n  val message: String\n\n  @Component.Factory\n  fun interface Factory {\n    fun create(messageGraph: MessageGraph): DaggerComponent\n  }\n}\n\n// kotlin-inject\n@Component\nabstract class KotlinInjectComponent(\n  @Component val messageGraph: MessageGraph\n) {\n  abstract val message: String\n}\n</code></pre>"},{"location":"interop/#runtime","title":"Runtime","text":""},{"location":"interop/#dagger","title":"Dagger","text":"<p>Enabling dagger interop also enables more advanced runtime interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code>/<code>Lazy</code> types.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n  }\n}\n</code></pre> <p>This specifically enables three features.</p> <ol> <li>Interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code> and <code>Lazy</code> runtime intrinsics.</li> <li>Interop with generated Dagger factories for constructor-injected classes, assisted-injected classes, member-injected classes, and Dagger modules. This means that Metro can natively reuse an upstream class or module that was processed with the dagger compiler (or Anvil, if using its factory generation) and has a generated factory/injector class.</li> <li>Interop with Dagger\u2019s <code>@BindsOptionalOf</code> annotation.</li> </ol> <p>Note the companion Gradle plugin automatically adds an extra <code>dev.zacsweers.metro:interop-dagger</code> runtime dependency to support this interop. If you only want annotation interop, just replace the annotations only.</p>"},{"location":"interop/#guice","title":"Guice","text":"<p>Enabling Guice interop enables annotation interop with the following Guice annotations:</p> <ul> <li><code>@Inject</code> (but not <code>@Inject.optional</code>)</li> <li><code>@Provides</code></li> <li><code>@Assisted</code></li> <li><code>@AssistedInject</code></li> <li><code>@BindingAnnotation</code></li> <li><code>@ScopeAnnotation</code></li> <li><code>@MapKey</code></li> <li><code>@ProvidesIntoMap</code></li> <li><code>@ProvidesIntoSet</code></li> </ul> <p>Enabling this also enables runtime interop with:</p> <ul> <li>Guice\u2019s <code>Provider</code> type. This means that you can use Guice\u2019s <code>Provider</code> type interchangeably with Metro\u2019s <code>Provider</code> type.</li> <li>Jakarta\u2019s <code>Provider</code> type.</li> <li>Guice modules<ul> <li>Only <code>@Provides</code> declarations are supported. <code>configure</code> implementations (including anything that would go in them) are not.</li> </ul> </li> </ul> <pre><code>metro {\n  interop {\n    includeGuice()\n  }\n}\n</code></pre> <p>Note the companion Gradle plugin automatically adds an extra <code>dev.zacsweers.metro:interop-guice</code> runtime dependency to support this interop.</p> <p>Why not javax.inject?</p> <p>Guice dropped support for javax.inject in 7.0.0.</p>"},{"location":"interop/#diagnostics","title":"Diagnostics","text":"<p>When interoping with annotations that are written in Kotlin and have parameters, it may be unsafe to rely on positional arguments. Metro\u2019s own annotations often have the same indices, but not always! If you want to be super safe, you can enable the <code>interopAnnotationsNamedArgSeverity</code> to <code>WARN</code> or <code>ERROR</code> to report diagnostics for positional arguments in any custom annotations that Metro is configured to look at.</p> <p>Why only Kotlin annotations?</p> <p>This is because the Kotlin compiler doesn\u2019t support positional arguments for annotations that are written in Java.</p>"},{"location":"metro-intrinsics/","title":"Metro Intrinsics","text":"<p>Like Dagger, Metro supports injection of bindings wrapped in intrinsic types. Namely - <code>Provider</code> and <code>Lazy</code>. These are useful for deferring creation/initialization of dependencies. These only need to be requested at the injection site, Metro\u2019s code gen will generate all the necessary stitching to fulfill that request.</p>"},{"location":"metro-intrinsics/#provider","title":"<code>Provider</code>","text":"<p><code>Provider</code> is like Dagger\u2019s <code>Provider</code> \u2014 it is a simple interface who\u2019s <code>invoke()</code> call returns a new instance every time. If the underlying binding is scoped, then the same (scoped) instance is returned every time <code>invoke()</code> is called.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Provider&lt;Cache&gt;) {\n  fun createCache() {\n    val cache = cacheProvider()\n  }\n}\n</code></pre>"},{"location":"metro-intrinsics/#lazy","title":"<code>Lazy</code>","text":"<p><code>Lazy</code> is Kotlin\u2019s standard library <code>Lazy</code>. It lazily computes a value the first time it\u2019s evaluated and is thread-safe.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Lazy&lt;Cache&gt;) {\n  fun createCache() {\n    // The value is computed once and cached after\n    val cache = cacheProvider.value\n  }\n}\n</code></pre> <p>Note that <code>Lazy</code> is different from scoping in that it is confined to the scope of the injected type, rather than the component instance itself. There is functionally no difference between injecting a <code>Provider</code> or <code>Lazy</code> of a scoped binding. A <code>Lazy</code> of a scoped binding can still be useful to defer initialization. The underlying implementation in Metro\u2019s <code>DoubleCheck</code> prevents double memoization in this case.</p> <p>Why doesn\u2019t <code>Provider</code> just use a property like <code>Lazy</code>?</p> <p>A property is appropriate for <code>Lazy</code> because it fits the definition of being a computed value that is idempotent for repeat calls. Metro opts to make its <code>Provider</code> use an <code>invoke()</code> function because it does not abide by that contract.</p>"},{"location":"metro-intrinsics/#providers-of-lazy","title":"Providers of Lazy","text":"<p>Metro supports combining <code>Provider</code> and <code>Lazy</code> to inject <code>Provider&lt;Lazy&lt;T&gt;&gt;</code>. On unscoped bindings this means the provider will return a new deferrable computable value (i.e. a new Lazy). Meanwhile <code>Lazy&lt;Provider&lt;T&gt;&gt;</code> is meaningless and not supported.</p>"},{"location":"metrox-android/","title":"MetroX Android","text":"<p>Core Android support for Metro. This artifact specifically focuses on integration with <code>AppComponentFactory</code>, which requires API 28+. As a result, this artifact requires min SDK 28 since it\u2019s useless on older versions.</p>"},{"location":"metrox-android/#usage","title":"Usage","text":"<p>For simple cases, all you need to do is</p> <ol> <li> <p>Depend on this artifact</p> <p> <pre><code>dependencies {\n  implementation(\"dev.zacsweers.metro:metrox-android:x.y.z\")\n}\n</code></pre> 2. Make your <code>AppGraph</code> (or equivalent) implement <code>MetroAppComponentProviders</code>. <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph : MetroAppComponentProviders\n</code></pre> 3. Make your <code>Application</code> subclass implement <code>MetroApplication</code> and implement <code>appComponentProviders</code>. <pre><code>class MyApp : Application(), MetroApplication {\n  private val appGraph by lazy { createGraph&lt;AppGraph&gt;() }\n  override val appComponentProviders: MetroAppComponentProviders\n    get() = appGraph\n}\n</code></pre></p> </li> </ol>"},{"location":"metrox-android/#advanced","title":"Advanced","text":"<p>If you have your own custom <code>AppComponentFactory</code>, you will need to exclude the MetroX implementation in your <code>AndroidManifest.xml</code> via <code>tools:replace</code> attribute.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  xmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n  &lt;application\n    ...\n    android:appComponentFactory=\"your.custom.AppComponentFactory\"\n    tools:replace=\"android:appComponentFactory\"\n  &gt;\n  &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>Then you can replicate what <code>MetroAppComponentFactory</code> does or subclass it in your custom factory.</p>"},{"location":"metrox-viewmodel-compose/","title":"MetroX ViewModel Compose","text":"<p>Compose integration for MetroX ViewModel. This artifact provides Compose-specific utilities for injecting ViewModels.</p> <p>Should I use this?</p> <p>Well, that\u2019s up to you! This artifact is mostly for projects coming from heavy use of more vanilla Android architecture components or <code>hiltViewModel()</code> use. Modern Android apps should use higher level architectures like Circuit*, Voyager, etc. that abstract away <code>ViewModel</code> management.</p> <p>*Disclosure: I am one of the authors of Circuit, and I\u2019m a big fan of it!</p>"},{"location":"metrox-viewmodel-compose/#usage","title":"Usage","text":"<pre><code>dependencies {\n  implementation(\"dev.zacsweers.metro:metrox-viewmodel-compose:x.y.z\")\n}\n</code></pre> <p>This artifact depends on <code>metrox-viewmodel</code> transitively.</p>"},{"location":"metrox-viewmodel-compose/#setup","title":"Setup","text":""},{"location":"metrox-viewmodel-compose/#1-set-up-your-graph","title":"1. Set up your graph","text":"<p>Create a graph interface that extends <code>ViewModelGraph</code>:</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph : ViewModelGraph\n</code></pre>"},{"location":"metrox-viewmodel-compose/#2-provide-localmetroviewmodelfactory","title":"2. Provide LocalMetroViewModelFactory","text":"<p>At the root of your Compose hierarchy, provide the factory via <code>CompositionLocalProvider</code>:</p> <pre><code>@Composable\nfun App(metroVmf: MetroViewModelFactory) {\n  CompositionLocalProvider(LocalMetroViewModelFactory provides metroVmf) {\n    // Your app content\n  }\n}\n</code></pre> <p>On Android, inject the factory into your Activity:</p> <pre><code>@Inject\nclass MainActivity(private val metroVmf: MetroViewModelFactory) : ComponentActivity() {\n  override fun onCreate(savedInstanceState: Bundle?) {\n    super.onCreate(savedInstanceState)\n    setContent {\n      CompositionLocalProvider(LocalMetroViewModelFactory provides metroVmf) {\n        App()\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"metrox-viewmodel-compose/#using-viewmodels","title":"Using ViewModels","text":""},{"location":"metrox-viewmodel-compose/#standard-viewmodels","title":"Standard ViewModels","text":"<p>Use <code>metroViewModel()</code> to retrieve injected ViewModels:</p> <pre><code>@Composable\nfun HomeScreen(viewModel: HomeViewModel = metroViewModel()) {\n  // ...\n}\n</code></pre>"},{"location":"metrox-viewmodel-compose/#assisted-viewmodels","title":"Assisted ViewModels","text":"<p>For ViewModels with <code>ViewModelAssistedFactory</code>:</p> <pre><code>@Composable\nfun DetailsScreen(\n  data: String,\n  viewModel: DetailsViewModel = assistedMetroViewModel()\n) {\n  // ...\n}\n</code></pre>"},{"location":"metrox-viewmodel-compose/#manual-assisted-viewmodels","title":"Manual Assisted ViewModels","text":"<p>For ViewModels with <code>ManualViewModelAssistedFactory</code>:</p> <pre><code>@Composable\nfun CustomScreen(\n  viewModel: CustomViewModel = assistedMetroViewModel&lt;CustomViewModel, CustomViewModel.Factory&gt; {\n    create(\"param1\", 42)\n  }\n) {\n  // ...\n}\n</code></pre>"},{"location":"metrox-viewmodel/","title":"MetroX ViewModel","text":"<p>ViewModel integration for Metro. This artifact provides core utilities for injecting ViewModels using Metro\u2019s dependency injection.</p> <p>For Compose-specific APIs (<code>LocalMetroViewModelFactory</code>, <code>metroViewModel()</code>, etc.), see the <code>metrox-viewmodel-compose</code> artifact.</p> <p>Should I use this?</p> <p>Well, that\u2019s up to you! This artifact is mostly for projects coming from heavy use of more vanilla Android architecture components or <code>hiltViewModel()</code> use. Modern Android apps should use higher level architectures like Circuit*, Voyager, etc. that abstract away <code>ViewModel</code> management.</p> <p>*Disclosure: I am one of the authors of Circuit, and I\u2019m a big fan of it!</p>"},{"location":"metrox-viewmodel/#usage","title":"Usage","text":"<pre><code>dependencies {\n  implementation(\"dev.zacsweers.metro:metrox-viewmodel:x.y.z\")\n}\n</code></pre>"},{"location":"metrox-viewmodel/#core-components","title":"Core Components","text":""},{"location":"metrox-viewmodel/#viewmodelgraph","title":"ViewModelGraph","text":"<p>Create a graph interface that extends <code>ViewModelGraph</code> to get multibindings for ViewModel providers:</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph : ViewModelGraph\n</code></pre> <p><code>ViewModelGraph</code> includes map multibindings for: - <code>viewModelProviders</code> - Standard ViewModel providers - <code>assistedFactoryProviders</code> - Assisted ViewModel factory providers - <code>manualAssistedFactoryProviders</code> - Manual assisted factory providers</p> <p>It also provides a <code>metroViewModelFactory</code> property for creating ViewModels.</p>"},{"location":"metrox-viewmodel/#metroviewmodelfactory","title":"MetroViewModelFactory","text":"<p>A <code>ViewModelProvider.Factory</code> implementation that uses injected maps to create ViewModels. Subclass it to provide your own bindings:</p> <pre><code>@Inject\n@ContributesBinding(AppScope::class)\n@SingleIn(AppScope::class)\nclass MyViewModelFactory(\n  override val viewModelProviders: Map&lt;KClass&lt;out ViewModel&gt;, Provider&lt;ViewModel&gt;&gt;,\n  override val assistedFactoryProviders: Map&lt;KClass&lt;out ViewModel&gt;, Provider&lt;ViewModelAssistedFactory&gt;&gt;,\n  override val manualAssistedFactoryProviders: Map&lt;KClass&lt;out ManualViewModelAssistedFactory&gt;, Provider&lt;ManualViewModelAssistedFactory&gt;&gt;,\n) : MetroViewModelFactory()\n</code></pre>"},{"location":"metrox-viewmodel/#contributing-viewmodels","title":"Contributing ViewModels","text":"<p>Use <code>@ViewModelKey</code> with <code>@ContributesIntoMap</code> to contribute ViewModels:</p> <pre><code>@Inject\n@ViewModelKey(HomeViewModel::class)\n@ContributesIntoMap(AppScope::class)\nclass HomeViewModel : ViewModel() {\n  // ...\n}\n</code></pre>"},{"location":"metrox-viewmodel/#assisted-viewmodel-creation","title":"Assisted ViewModel Creation","text":"<p>For ViewModels requiring runtime parameters and only using <code>CreationParams</code> can use <code>ViewModelAssistedFactory</code>:</p> <pre><code>@AssistedInject\nclass DetailsViewModel(@Assisted val id: String) : ViewModel() {\n  // ...\n\n  @AssistedFactory\n  @ViewModelAssistedFactoryKey(Factory::class)\n  @ContributesIntoMap(AppScope::class)\n  fun interface Factory : ViewModelAssistedFactory {\n    override fun create(extras: CreationExtras): DetailsViewModel {\n      return create(extras.get&lt;String&gt;(KEY_ID))\n    }\n\n    fun create(@Assisted id: String): DetailsViewModel\n  }\n}\n</code></pre>"},{"location":"metrox-viewmodel/#manual-assisted-injection","title":"Manual Assisted Injection","text":"<p>For full control over ViewModel creation, use <code>ManualViewModelAssistedFactory</code>:</p> <pre><code>@AssistedInject\nclass CustomViewModel(@Assisted val param1: String, @Assisted val param2: Int) : ViewModel() {\n  // ...\n\n  @AssistedFactory\n  @ManualViewModelAssistedFactoryKey(Factory::class)\n  @ContributesIntoMap(AppScope::class)\n  interface Factory : ManualViewModelAssistedFactory {\n    fun create(param1: String, param2: Int): CustomViewModel\n  }\n}\n</code></pre>"},{"location":"metrox-viewmodel/#android-framework-integration","title":"Android Framework Integration","text":"<pre><code>// Activity\n@Inject\nclass ExampleActivity(private val viewModelFactory: MyViewModelFactory) : ComponentActivity() {\n  override val defaultViewModelProviderFactory: ViewModelProvider.Factory\n    get() = viewModelFactory\n}\n\n// Fragment\n@Inject\nclass ExampleFragment(private val viewModelFactory: MyViewModelFactory) : Fragment() {\n  override val defaultViewModelProviderFactory: ViewModelProvider.Factory\n    get() = viewModelFactory\n}\n</code></pre>"},{"location":"multiplatform/","title":"Multiplatform","text":"<p>The runtime and code gen have been implemented to be entirely platform-agnostic so far.</p>"},{"location":"multiplatform/#supported-targets-for-artifactsfeatures","title":"Supported Targets for artifacts/features","text":"Artifact/feature JVM Android JS WASM Apple Linux Windows Android Native runtime \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 interop-javax \u2705 \u2705 \u2015 \u2015 \u2015 \u2015 \u2015 \u2015 interop-jakarta \u2705 \u2705 \u2015 \u2015 \u2015 \u2015 \u2015 \u2015 interop-dagger \u2705 \u2705 \u2015 \u2015 \u2015 \u2015 \u2015 \u2015 interop-guice \u2705 \u2705 \u2015 \u2015 \u2015 \u2015 \u2015 \u2015 \u2014 - - - - - - - - Multi-module aggregation \u2705 \u2705 Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Top-level function injection \u2705 \u2705 Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> Kotlin <code>2.3.20</code> <p>Legend: - WASM: wasmJs, wasmWasi - Apple: macOS (x64, arm64), iOS (x64, arm64, simulatorArm64), watchOS (x64, arm32, arm64, deviceArm64, simulatorArm64), tvOS (x64, arm64, simulatorArm64) - Linux: linuxX64, linuxArm64 - Windows: mingwX64 - Android Native: androidNativeArm32, androidNativeArm64, androidNativeX86, androidNativeX64</p> <p>Cross-platform aggregation features are only supported on JVM and Android at the moment but should be available in Kotlin 2.3.20+. Follow this issue.</p> <p>When mixing contributions between common and platform-specific source sets, you must define your final <code>@DependencyGraph</code> in the platform-specific code. This is because a graph defined in commonMain wouldn\u2019t have full visibility of contributions from platform-specific types. A good pattern for this is to define your canonical graph in commonMain without a <code>@DependencyGraph</code> annotation and then a <code>{Platform}{Graph}</code> type in the platform source set that extends it and does have the <code>@DependencyGraph</code>. Metro automatically exposes bindings of the base graph type on the graph for any injections that need it.</p> <pre><code>// In commonMain\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n\n// In jvmMain\n@DependencyGraph\ninterface JvmAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(Netty)\n}\n\n// In androidMain\n@DependencyGraph\ninterface AndroidAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(OkHttp)\n}\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>Metro strives to be a performant solution with minimal overhead at build-time and generating fast, efficient code at runtime. As build performance is the primary consideration for most developers considering this, most of this doc will be focused on that.</p>"},{"location":"performance/#build-performance","title":"Build Performance","text":"<p>Metro\u2019s compiler plugin is designed to be fast. Running as a compiler plugin allows it to: - Avoid generating new sources that need to be compiled - Avoid running KSP/KAPT - Generate IR that lowers directly into target platforms - Hook directly into kotlinc\u2019s IC APIs.</p> <p>In a straightforward migration, it improves ABI-changing build performance from 30-70%.</p>"},{"location":"performance/#benchmarking","title":"Benchmarking","text":"<p>To benchmark against Anvil-KSP, Dagger (KSP or KAPT), and Kotlin-Inject (+ Anvil), there is a benchmark directory with a generator script. There are more details in its README, but in short it generates a nontrivial multi-module project (default is 500 modules but is configurable) and benchmarks with gradle-profiler.</p> <p>Summary</p> <p>Results as of Metro <code>0.3.7</code>, Anvil-KSP <code>0.4.1</code>, Dagger <code>2.56.2</code>, and Kotlin-Inject <code>0.8.0</code> with kotlin-inject-anvil <code>0.1.6</code> are as follows.</p> <p>(Median times in seconds)</p> Metro Anvil KSP Anvil Kapt Kotlin-Inject ABI 5.3s 40.5s (+663%) 25.3s (+377%) 10.3s (+94%) Non-ABI 2.6s 3.8s (+45%) 7.1s (+171%) 3.3s (+26%) Graph processing 6.9s 28.9s (+318%) 8.7s (+25%) 11s (+59%)"},{"location":"performance/#modes","title":"Modes","text":"<ul> <li>Metro: Purely running metro</li> <li>Anvil KSP: Running dagger-ksp with anvil-ksp for contribution merging.</li> <li>Anvil KAPT: Running dagger with kapt with anvil-ksp for contribution merging.</li> <li>Kotlin Inject: Running kotlin-inject + kotlin-inject-anvil for contribution merging.</li> </ul>"},{"location":"performance/#abi-change","title":"ABI Change","text":"<p>This benchmark makes ABI-breaking source changes in a lower level module. This is where Metro shines the most.</p> <p></p>"},{"location":"performance/#non-abi-change","title":"Non-ABI Change","text":"<p>This benchmark makes non-ABI-breaking source changes in a lower level module. The differences are less significant here as KSP is quite good at compilation avoidance now too. The outlier here is KAPT, which still has to run stub gen + apt and cannot fully avoid it.</p> <p></p>"},{"location":"performance/#raw-graphcomponent-processing","title":"Raw Graph/Component Processing","text":"<p>This benchmark reruns the top-level merging graph/component where all the downstream contributions are merged. This also builds the full dependency graph and any contributed graph extensions/subcomponents.</p> <p>Metro again shines here. Dagger-KSP seems to have a bottleneck that disproportionately affects it here too.</p> <p></p>"},{"location":"performance/#real-world-results","title":"Real-World Results","text":"<p>Below are some results from real-world projects, shared with the developers\u2019 permission.</p> <p>Cash App</p> <p>Cash App wrote a blog post about their migration to Metro: Cash App Moves to Metro</p> <p>According to our benchmarks, by migrating to Metro and K2 we managed to improve clean build speeds by over 16% and incremental build speeds by almost 60%!</p> <p>Gabriel Ittner from Freeletics</p> <p>I\u2019ve got Metro working on our code base now using the Kotlin 2.2.0 preview</p> <p>Background numbers</p> <ul> <li>551 modules total</li> <li>105 modules using Anvil KSP \u27a1\ufe0f migrated to pure Metro</li> <li>154 modules using Anvil KSP + other KSP processor \u27a1\ufe0f Metro + other KSP processor</li> <li>1 module using Dagger KAPT \u27a1\ufe0f migrated to pure Metro</li> </ul> <p>Build performance</p> <ul> <li>Clean builds without build cache are 12 percentage points faster</li> <li>Any app module change ~50% faster (this is the one place that had kapt and it\u2019s mostly empty other than generating graphs/components)</li> <li>ABI changes in other modules ~ 40% - 55% faster</li> <li>non ABI changes in other modules unchanged or minimally faster</li> </ul> <p>Madis Pink from emulator.wtf</p> <p>I got our monorepo migrated over from anvil, it sliced off one third of our Gradle tasks and <code>./gradlew classes</code> from clean is ~4x faster</p> <p>Kevin Chiu from BandLab</p> <p>We migrated our main project at BandLab to metro, finally!</p> <p>Some context about our project:</p> <ul> <li>We use Dagger + Anvil KSP</li> <li>929 modules, 89 of them are running Dagger compiler (KAPT) to process components</li> <li>7 KSP processors</li> </ul> Build Dagger + Anvil KSP Metro (\u0394) UiKit ABI change (Incremental) 59.7 s 26.9 s (55% faster) Root ABI change (Incremental) 95.7 s 48.1 s (49.8% faster) Root non-ABI change (Incremental) 70.9 s 38.9 s (45.2% faster) Clean build 327 s 288 s (11.7% faster) <p>Cyril Mottier from Amo</p> <p>Ref</p> <p>We already had incremental compilation in the single-digit seconds range, but I\u2019m still blown away by how much faster it is now that the entire codebase is fully on Metro. \ud83e\udd2f</p>"},{"location":"performance/#reporting","title":"Reporting","text":"<p>If you want to investigate the performance of different stages of Metro\u2019s compiler pipeline, you can enable reporting in the Gradle DSL.</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre> <p>Among the reports written there, there will also be a trace log that dumps a simple trace of the different stages.</p> <pre><code>[ExampleGraph] \u25b6 Transform dependency graph\n  \u25b6 Build DependencyGraphNode\n  \u25c0 Build DependencyGraphNode (xx ms)\n  \u25b6 Implement creator functions\n  \u25c0 Implement creator functions (xx ms)\n  \u25b6 Build binding graph\n  \u25c0 Build binding graph (xx ms)\n  \u25b6 Validate binding graph\n    \u25b6 Check self-cycles\n    \u25c0 Check self-cycles (xx ms)\n    \u25b6 Validate graph\n      \u25b6 seal graph\n        \u25b6 Populate bindings\n        \u25c0 Populate bindings (xx ms)\n        \u25b6 Build adjacency list\n        \u25c0 Build adjacency list (xx ms)\n        \u25b6 Sort and validate\n          \u25b6 Topo sort\n            \u25b6 Compute SCCs\n            \u25c0 Compute SCCs (xx ms)\n            \u25b6 Check for cycles\n            \u25c0 Check for cycles (xx ms)\n            \u25b6 Build component DAG\n            \u25c0 Build component DAG (xx ms)\n            \u25b6 Topo sort component DAG\n            \u25c0 Topo sort component DAG (xx ms)\n            \u25b6 Expand components\n            \u25c0 Expand components (xx ms)\n          \u25c0 Topo sort (xx ms)\n        \u25c0 Sort and validate (xx ms)\n        \u25b6 Compute binding indices\n        \u25c0 Compute binding indices (xx ms)\n      \u25c0 seal graph (xx ms)\n      \u25b6 check empty multibindings\n      \u25c0 check empty multibindings (xx ms)\n      \u25b6 check for absent bindings\n      \u25c0 check for absent bindings (xx ms)\n    \u25c0 Validate graph (xx ms)\n  \u25c0 Validate binding graph (xx ms)\n  \u25b6 Transform metro graph\n    \u25b6 Collect bindings\n    \u25c0 Collect bindings (xx ms)\n    \u25b6 Implement overrides\n    \u25c0 Implement overrides (xx ms)\n  \u25c0 Transform metro graph (xx ms)\n[ExampleGraph] \u25c0 Transform dependency graph (xx ms)\n</code></pre>"},{"location":"performance/#runtime-performance","title":"Runtime Performance","text":"<p>Metro\u2019s compiler generates Dagger-style factory classes for every injection site.</p> <p>The same factory classes are reused across modules and downstream builds, so there\u2019s no duplicated glue code or runtime discovery cost.</p> <p>Because the full dependency graph is wired at compile-time, each binding is accessed through a direct field reference in the generated code. No reflection, no hashmap lookups, no runtime service locator hops, etc.</p>"},{"location":"provides/","title":"<code>@Provides</code>","text":"<p>Providers can be defined in graphs or supertypes that graphs extend. Defining them in supertypes allows for them to be reused across multiple graphs and organize providers into logic groups. This is similar to how modules in Dagger work.</p> <pre><code>interface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface AppGraph : NetworkProviders\n</code></pre> <p>Provider functions should be <code>private</code> by default and are automatically transformed to be private by the Metro compiler. This means you can write a provider function with no explicit (or public) visibility and it will be made private by Metro at compile-time.</p> <p>Provider properties cannot be private yet due to KT-76257, but may be supported in the future.</p> <p>Providers may also be declared in binding Containers.</p> <p>Tip</p> <p>It\u2019s recommended to not call providers from each other.</p>"},{"location":"provides/#overrides","title":"Overrides","text":"<p>It is an error to override providers declarations. While it can be enticing for testing reasons to try to replicate Dagger 1\u2019s module overrides, it quickly becomes difficult to reason about in code gen.</p> <ul> <li>What if you override with sub/supertypes?</li> <li>What if your override\u2019s implementation needs different dependencies?</li> </ul> <p>To the testing end, it is recommended to instead leverage the <code>DependencyGraph.excludes</code> + <code>ContributesTo.replaces</code> APIs in merging.</p> <pre><code>// Don't do this pattern!\ninterface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface TestAppGraph : NetworkProviders {\n  // This will fail to compile\n  override fun provideHttpClient(): HttpClient = TestHttpClient()\n}\n</code></pre>"},{"location":"provides/#companion-providers","title":"Companion Providers","text":"<p>Providers can alternatively be implemented in <code>companion object</code>s for staticization.</p> <pre><code>interface MessageGraph {\n  val message: String\n  companion object {\n    @Provides\n    private fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre> Implementation Notes <p>private interface functions are not usually visible to downstream compilations in IR. To work around this, Metro will use a new API in Kotlin 2.1.20 to add custom metadata to the parent class to denote these private providers\u2019 existence and where to find them.</p>"},{"location":"samples/","title":"Metro Samples","text":"<p>The samples directory contains various sample projects demonstrating different use cases and integrations for Metro.</p>"},{"location":"samples/#android-app","title":"android-app","text":"<p>A simple Android sample app that demonstrates using Metro to constructor-inject Android framework components like <code>Activity</code>, <code>Fragment</code>, and <code>ViewModel</code> with multibindings.</p>"},{"location":"samples/#circuit-app","title":"circuit-app","text":"<p>A multiplatform sample that demonstrates using Metro with Circuit and Jetpack Compose.</p>"},{"location":"samples/#compose-viewmodels","title":"compose-viewmodels","text":"<p>A multiplatform sample that demonstrates using Metro for <code>ViewModel</code> injection in a multi-module Compose app with Compose Navigation. Shows both standard and assisted ViewModel injection patterns.</p>"},{"location":"samples/#interop","title":"interop","text":"<p>Various demonstrating interop between Metro and other dependency injection frameworks.</p>"},{"location":"samples/#weather-app","title":"weather-app","text":"<p>A simple command-line weather app that demonstrates basic Metro usage.</p>"},{"location":"scopes/","title":"Scopes","text":"<p>Like Dagger and KI, Metro supports scopes to limit instances of types on the dependency graph. A scope is any annotation annotated with <code>@Scope</code>, with a convenience <code>@SingleIn</code> scope available in Metro\u2019s runtime.</p> <p>Scopes must be applied to either the injected class or the provider function providing that binding. They must also match the graph that they are used in.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\nabstract class AppGraph {\n  private var counter = 0\n\n  abstract val count: Int\n\n  @SingleIn(AppScope::class) @Provides fun provideCount() = counter++\n}\n</code></pre> <p>In the above example, multiple calls to <code>AppGraph.count</code> will always return 0 because the returned value from <code>provideCount()</code> will be cached in the <code>AppGraph</code> instance the first time it\u2019s called.</p> <p>It is an error for an unscoped graph to access scoped bindings.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>It is also an error for a scoped graph to access scoped bindings whose scope does not match.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(UserScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>Like Dagger, graphs can have multiple scopes that they support.</p> <pre><code>@Scope annotation class Singleton\n\n@Singleton\n@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is ok\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre>"},{"location":"stability/","title":"Stability","text":"<p>Metro is functionally stable and ready for production use and many companies are doing so.</p> <p>Metro\u2019s runtime and Gradle plugin APIs are not yet stabilized and versioned as <code>0.x.x</code> as a result. Changes to their APIs are infrequent, rarely invasive, and usually come with deprecation cycles before full removal. These APIs will eventually be stabilized.</p>"},{"location":"stability/#what-about-compiler-plugin-stability","title":"What about compiler plugin stability?","text":"<p>See the compatibility docs.</p>"},{"location":"stability/#generated-code-stability","title":"Generated Code Stability","text":"<p>A second layer of stability to consider is the compatibility of Metro-generated code with different versions of the runtime.</p> <p>Example</p> <p>If you compile a library against one version of Metro and then use it in another project that depends on a different version of Metro\u2019s runtime.</p> <p>As is typical of most code generation tools, Metro does not guarantee generated code will be compatible with different versions of the runtime other than the one it was compiled against. This is usually not an issue, but some larger teams working in multi-repo environments will want to be mindful of this.</p> <p>Metro may support this in the future, If you have reasonable use cases or suggestions of how you\u2019d expect such support to work, please raise a discussion about it on the repo\u2019s discussions section.</p>"},{"location":"stability/#language-evolution","title":"Language Evolution","text":"<p>Generally speaking, Metro adopts new language features as they become available in Kotlin and where they make sense.</p> <ul> <li>In the event of a new runtime feature, Metro would only support that version of Kotlin or later starting in that release. Users still on older versions Kotlin would need to update Kotlin first before updating to that Metro version.</li> </ul> <p>Example</p> <p>If Metro started using the stdlib\u2019s <code>AutoCloseable</code> interface in its runtime, that Metro version would only support Kotlin <code>2.0.0</code> or later (the version of Kotlin that introduced <code>AutoCloseable</code>.)</p> <ul> <li>In the event of a new compiler feature, Metro will support that on a best-effort basis but not necessarily impose that version of kotlin.</li> </ul> <p>Example</p> <p>Metro\u2019s compiler supports context parameters in Kotlin <code>2.2.20</code> but context parameters were not yet stable in that version of Kotlin.</p>"},{"location":"validation-and-error-reporting/","title":"Validation &amp; Error Reporting","text":"<p>Common programmer/usage errors are implemented in FIR. This should allow errors to appear directly in the IDE, offering the best and fastest feedback loop for developers writing their code.</p> <p>TODO IDE screenshot example</p> <p>Dependency graph validation is performed at the per-graph level. Metro seeks to report binding validation errors at least on par with Dagger, if not better.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/DependencyCycle] Found a dependency cycle:\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n    kotlin.String is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideDouble(..., string)\n    kotlin.Double is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideInt(..., double)\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n</code></pre> <p>Binding errors take learnings from Dagger and report fully qualified references that IDEs like IntelliJ can usually autolink.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/GraphDependencyCycle] Dependency graph dependency cycle detected! The below graph depends on itself.\n    test.CharSequenceGraph is requested at\n        [test.CharSequenceGraph] test.CharSequenceGraph.Factory.create()\n</code></pre> <p>Note that binding graph resolution currently only happens in the compiler IR backend, but maybe someday we can move this to FIR to get errors in the IDE.</p>"}]}