{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude87 Metro","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Metro is a compile-time dependency injection framework that draws heavy inspiration from Dagger, Anvil, and Kotlin-Inject. It seeks to unify their best features under one, cohesive solution while adding a few new features and implemented as a compiler plugin.</p>"},{"location":"#why-another-di-framework","title":"Why another DI framework?","text":"<p>It\u2019s felt for some time like the Kotlin community has been waiting for a library at the intersection of these different tools and features. Different tools exist for parts of these, but there\u2019s not yet been a unified solution that checks all these boxes, leaves behind some of these tools\u2019 limitations, and embraces newer features that native compiler plugins offer.</p> <p>In short, Metro stands on the shoulders of giants. It doesn\u2019t try to reinvent the wheel, it does try to make those wheels work better together.</p> <p>Note</p> <p>I\u2019m aware of the XKCD comic \ud83d\ude42, I think Metro offers a compelling feature set with interop hooks that make it easy to integrate with an existing codebase.</p>"},{"location":"#installation","title":"Installation","text":"<p>Apply the gradle plugin.</p> <pre><code>plugins {\n  id(\"dev.zacsweers.metro\") version \"x.y.z\"\n}\n</code></pre> <p>And that\u2019s it! The default configuration will add the multiplatform <code>runtime</code> artifact (which has annotations you can use) and wire it all automatically.</p> <p>You can configure custom behaviors with APIs on the <code>metro</code> DSL extension.</p> <pre><code>metro {\n  // Defines whether or not metro is enabled. Useful if you want to gate this behind a dynamic\n  // build configuration.\n  enabled = true // Default\n\n  // Enable (extremely) verbose debug logging\n  debug = false // Default\n\n  // See the kdoc on MetroPluginExtension for full details\n}\n</code></pre> <p>Snapshots of the development version are available in Sonatype\u2019s <code>snapshots</code> repository.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>The compiler plugin itself supports all multiplatform project types. The first-party annotations artifact is also multiplatform and supports all common JVM, JS, and native targets.</p> <p>Contribution hint generation is not currently supported on native or Wasm targets until KT-58886 is resolved. They do work within the same compilation though.</p>"},{"location":"#caveats","title":"Caveats","text":"<ul> <li>Kotlin compiler plugins are not a stable API! Compiled outputs from this plugin should be stable, but usage in newer versions of kotlinc are not guaranteed to be stable. That said, Metro will strive to make matching releases available quickly and test against Kotlin prereleases eagerly.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Special thanks to the many people that helped advise and offer feedback on Metro\u2019s design and implementation.</p> <ul> <li>Brian Norman</li> <li>Ralf Wondratschek</li> <li>Jesse Wilson</li> <li>Dany Santiago</li> <li>Eva Tatarka</li> <li>Bill Phillips</li> <li>Bryan Stern</li> <li>James Barr</li> <li>and many more!</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>Copyright (C) 2025 Zac Sweers\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"adoption/","title":"Adoption Strategies","text":"<p>If adopting Metro into an existing codebase, you can use a few different strategies.</p> <ol> <li>First, add the Metro Gradle plugin and runtime deps. The plugin id is <code>dev.zacsweers.metro</code>, runtime is <code>dev.zacsweers.metro:runtime</code>. The Gradle Plugin should add the runtime automatically, but it\u2019s there just in case!</li> <li>Apply the Gradle plugin to your relevant project(s).</li> </ol> From DaggerFrom kotlin-inject"},{"location":"adoption/#precursor-steps","title":"Precursor steps","text":"<p>Compiler options you should enable in Dagger</p> <p>Dagger has some compiler options you should enable and get working first to make it easier to move to Metro.</p> <ul> <li>useBindingGraphFix <ul> <li>The issue it fixes is something that Metro catches as well.</li> </ul> </li> <li>ignoreProvisionKeyWildcards</li> </ul> <p>K2 Migration</p> <p>If you are migrating from square/anvil, you likely are also going to have to migrate to Kotlin K2 as a part of this. If you want to split that effort up, you can consider migrating to anvil-ksp first. This would move fully over to KSP and K2 first, then you can resume here.</p>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level","title":"Option 1: Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on Dagger components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is also good if you just want to do a simple, isolated introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations","title":"Option 2: Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from Dagger/Anvil. Here is an example for enabling that in Gradle.</p> <ol> <li>Remove the dagger-compiler/anvil plugin (but keep their runtime deps).</li> <li>Enable interop with the Metro gradle plugin</li> </ol> <pre><code>metro {\n  interop {\n    includeDagger()\n    includeAnvil() // If using Anvil\n  }\n}\n</code></pre> <p>Most things will Just Work\u2122, but you will still possibly need to do some manual migrations.</p> <ul> <li>If you use <code>KClass</code> and <code>Class</code> interchangeably in your graph, Metro distinguishes between these and you\u2019ll need to move fully over to one or the other, likely <code>KClass</code>.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>If you use <code>@MergeComponent</code> with <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>Not necessary if coming from anvil-ksp.</li> <li>Migrate <code>@BindsInstance</code> to <code>@Provides</code>. Metro consolidated these to just one annotation.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul> <p>You can also remove any <code>@JvmSuppressWildcard</code> annotations, these are ignored in Metro.</p>"},{"location":"adoption/#option-3-full-migration","title":"Option 3: Full migration","text":"<ul> <li>Remove the Dagger and anvil runtimes.</li> <li>Replace all Dagger/anvil annotations with Metro equivalents.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> <li>Migrate from javax/jakarta <code>Provider</code> and <code>dagger.Lazy</code> APIs to Metro\u2019s <code>Provider</code> and the stdlib\u2019s <code>Lazy</code> APIs.</li> </ul>"},{"location":"adoption/#precursor-steps_1","title":"Precursor steps","text":"<ol> <li>Remove the kotlin-inject(-anvil) dependencies (but keep their runtime deps if you use option 1 below!).</li> <li>Migrate to <code>@AssistedFactory</code> if you haven\u2019t already.</li> </ol>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level_1","title":"Option 1: Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on kotlin-inject components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is also good if you want to do a simple, isolated introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations_1","title":"Option 2: Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from kotlin-inject/kotlin-inject-anvil. Here is an example for enabling that in Gradle.</p> <ol> <li>Remove the kotlin-inject and kotlin-inject-anvil KSP processors (but keep their runtime deps).</li> <li>Enable interop with the Metro Gradle plugin</li> </ol> <pre><code>metro {\n  interop {\n    includeKotlinInject()\n    includeAnvil() // If using kotlin-inject-anvil\n  }\n}\n</code></pre> <p>You will still possibly need to do some manual migrations, namely providers.</p> <ul> <li>Any map multibindings need to migrate to use map keys.</li> <li>Any higher order function injection will need to switch to using Metro\u2019s <code>Provider</code> API.</li> <li>Any higher order assisted function injection will need to switch to using <code>@AssistedFactory</code>-annotated factories.</li> <li>If you use <code>@MergeComponent</code> + <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"adoption/#option-3-full-migration_1","title":"Option 3: Full migration","text":"<ul> <li>Any map multibindings need to migrate to use map keys.</li> <li>Any higher order function injection will need to switch to using Metro\u2019s <code>Provider</code> API.</li> <li>Any higher order assisted function injection will need to switch to using <code>@AssistedFactory</code>-annotated factories.</li> <li>Remove the kotlin-inject and kotlin-inject-anvil runtimes.</li> <li>Replace all kotlin-inject/kotlin-inject-anvil annotations with Metro equivalents.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"aggregation/","title":"Aggregation (aka \u2018Anvil\u2019)","text":"<p>Metro supports Anvil-style aggregation in graphs via <code>@ContributesTo</code> and <code>@ContributesBinding</code> annotations. As aggregation is a first-class citizen of Metro\u2019s API, there is no <code>@MergeComponent</code> annotation like in Anvil. Instead, <code>@DependencyGraph</code> defines which contribution scope it supports directly.</p> <pre><code>@DependencyGraph(scope = AppScope::class)\ninterface AppGraph\n</code></pre> <p>When a graph declares a <code>scope</code>, all contributions to that scope are aggregated into the final graph implementation in code gen.</p> <p>If a graph supports multiple scopes, use <code>additionalScopes</code>.</p> <pre><code>@DependencyGraph(\n  AppScope::class,\n  additionalScopes = [LoggedOutScope::class]\n)\ninterface AppGraph\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@DependencyGraph</code> supports excluding contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(\n  scope = AppScope::class,\n  excludes = [RealNetworkProviders::class]\n)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class)\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesto","title":"@ContributesTo","text":"<p>This annotation is used to contribute graph interfaces to the target scope to be merged in at graph-processing time to the final merged graph class as another supertype.</p> <pre><code>@ContributesTo(AppScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesTo(AppScope::class)\n@ContributesTo(LoggedInScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@ContributesBinding</code> (as well as the other <code>@Contributes*</code> annotations) supports replacing other contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class, replaces = [RealNetworkProviders::class])\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesbinding","title":"@ContributesBinding","text":"<p>This annotation is used to contribute injected classes to a target scope as a given bound type.</p> <p>The below example will contribute the <code>CacheImpl</code> class as a <code>Cache</code> type to <code>AppScope</code>.</p> <pre><code>@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For simple cases where there is a single supertype, that type is implicitly used as the bound type. If your bound type is qualified, for the implicit case you can put the qualifier on the class.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For classes with multiple supertypes or advanced cases where you want to bind an ancestor type, you can explicitly define this via <code>binding</code> parameter.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Whoa, is that a function call in an annotation argument? Nope! <code>binding</code> is just a decapitalized class in this case, intentionally designed for readability. It\u2019s an adjective in this context and the functional syntax better conveys that.</p> <p>Note that the bound type is defined as the type argument to <code>@ContributesBinding</code>. This allows for the bound type to be generic and is validated in FIR.</p> <p>Qualifier annotations can also be specified on the <code>binding</code> type parameter and will take precedence over any qualifiers on the class itself.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;@Named(\"cache\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;AnotherType&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Contributions may be <code>object</code> classes. In this event, Metro will automatically provide the object instance in its binding.</p>"},{"location":"aggregation/#implicitly-injected-contributesbinding-types","title":"Implicitly-injected <code>@ContributesBinding</code> types","text":"<p>Up to version <code>0.7.0</code>, Metro has always required you to use <code>@Inject</code> on most <code>@Contributes*</code> annotated types. However, this can feel a bit repetitive and tedious. Starting in <code>0.7.0</code>, there is a new <code>contributesAsInject</code> Gradle DSL option that can be enabled that will treat all <code>@Contributes*</code> annotated types as <code>@Inject</code> by default. You can still use <code>@Inject</code> on classes to be explicit, and if you have multiple constructors you must still use <code>@Inject</code> on the constructor you want to be used.</p> <p>The only exception to this is <code>@ContributesTo</code>, which isn\u2019t applicable to injected types.</p> <p>This is disabled by default to start but will likely become the default in a future release.</p> <pre><code>@ContributesBinding(AppScope::class)\n// @Inject // &lt;-- now implicit!\nclass TacoImpl(...) : Taco\n</code></pre>"},{"location":"aggregation/#contributesintosetcontributesintomap","title":"@ContributesIntoSet/@ContributesIntoMap","text":"<p>To contribute into a multibinding, use the <code>@ContributesIntoSet</code> or <code>@ContributesIntoMap</code> annotations as needed.</p> <pre><code>@ContributesIntoSet(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>Same rules around qualifiers and <code>binding()</code> apply in this scenario</p> <p>To contribute into a Map multibinding, the map key annotation must be specified on the class or <code>binding</code> type argument.</p> <pre><code>// Will be contributed into a Map multibinding with @StringKey(\"Networking\")\n@ContributesIntoMap(AppScope::class)\n@StringKey(\"Networking\")\n@Inject\nclass CacheImpl(...) : Cache\n\n// Or if using binding\n@ContributesIntoMap(\n  scope = AppScope::class,\n  binding = binding&lt;@StringKey(\"Networking\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>This annotation is also repeatable and can be used to contribute to multiple scopes, multiple bound types, and multiple map keys.</p> <p>You can use <code>@IntoMap</code>/<code>@IntoSet</code> to provide into the same container:</p> <pre><code>// Method 1: applying @ContributesIntoMap to bind directly from the implementation class\n@ContributesIntoMap(AppScope::class)\n@StringKey(\"remote\")\n@Inject\nclass RemoteCache(...) : Cache\n\n// Method 2: Declare the class, then provide @IntoMap binding separately via a BindingContainer\nclass LocalCache(...) : Cache\n\n@BindingContainer\n@ContributesTo(AppScope::class)\nobject CacheBindingContainer {\n  @Provides\n  @IntoMap\n  @StringKey(\"local\")\n  fun cache(): Cache = LocalCache(...)\n}\n\n// Accessing the resultant map, containing both implementations:\n@Inject\nclass CompositeCache(private val caches: Map&lt;String, Cache&gt;) {\n  val local: Cache = caches[\"local\"]\n  val remote: Cache = caches[\"remote\"]\n}\n\n// Alternatively, specify Provider in the map type to lazily-initialize the implementations\n@Inject\nclass CompositeCacheAlternate(private val caches: Map&lt;String, Provider&lt;Cache&gt;&gt;) {\n  val local: Cache = caches[\"local\"]()\n  val remote: Provider&lt;Cache&gt; = caches[\"remote\"]\n\n  fun someTimeLater() {\n    remote().doSomethingWithCache()\n  }\n}\n</code></pre> <p>Like <code>@ContributesBinding</code>, enabling the <code>contributesAsInject</code> Gradle DSL option will treat all <code>@ContributesIntoSet</code>/<code>@ContributesIntoMap</code>-annotated types as <code>@Inject</code> by default.</p>"},{"location":"aggregation/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers (see Binding Containers) can also be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"aggregation/#replacing-contributed-binding-containers","title":"Replacing Contributed Binding Containers","text":"<p>Similar to other contribution types, binding containers can replace other contributed binding containers:</p> <pre><code>// In production\n@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n// In tests\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre>"},{"location":"aggregation/#replacing-contributed-bindings","title":"Replacing Contributed Bindings","text":"<p>Binding containers can replace other contributed bindings, too:</p> <pre><code>// In production\n@ContributesBinding(AppScope::class)\n@Inject\nclass HttpClientImpl : HttpClient\n\n// In tests\n@ContributesTo(AppScope::class, replaces = [HttpClientImpl::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre>"},{"location":"aggregation/#excluding-contributed-binding-containers","title":"Excluding Contributed Binding Containers","text":"<p>Graphs can exclude specific contributed binding containers:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface TestAppGraph {\n  // NetworkBindings will not be included\n}\n</code></pre>"},{"location":"aggregation/#implementation-notes","title":"Implementation notes","text":"<p>This leans on Kotlin\u2019s ability to put generic type parameters on annotations. That in turn allows for both generic bound types and to contribute map bindings to multiple map keys.</p> <p>Because it\u2019s a first-party feature, there\u2019s no need for intermediary \u201cmerged\u201d components like kotlin-inject-anvil and anvil-ksp do.</p> <p>Generated contributing interfaces are generated to the <code>metro.hints</code> package and located during graph supertype generation in FIR downstream. Any contributed bindings are implemented as <code>@Binds</code> (\u00b1 IntoSet/IntoMap/etc) annotated properties.</p>"},{"location":"bindings/","title":"Bindings","text":""},{"location":"bindings/#qualifiers","title":"Qualifiers","text":"<p>Like Dagger and KI, Metro supports qualifier annotations to allow disambiguation of types. These are applied at injection and provision sites. A qualifier annotation is any annotation annotated with <code>@Qualifier</code>. For convenience, there is an included <code>@Named</code> qualifier available in Metro\u2019s runtime that can be used too.</p> <p>A \u201ctype key\u201d in Metro is composed of a concrete type and (if any) qualifier annotation attached to it.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val int: Int\n  @Named(\"named\") val namedInt: Int\n\n  @Provides\n  fun provideInt(): Int = 3\n\n  @Provides\n  @Named(\"named\")\n  fun provideNamedInt(): Int = 4\n}\n</code></pre>"},{"location":"bindings/#binds","title":"@Binds","text":"<p>In many cases, a developer may have an implementation type on the graph that they want to expose as just its supertype.</p> <p>Like Dagger, Metro supports this with <code>@Binds</code>.</p> <p>For these cases, an abstract provider can be specified with the following conditions.</p> <ul> <li>It must be abstract</li> <li>It must define one extension receiver that is a subtype of its provided type</li> </ul> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: Message\n\n  // Bind MessageImpl as Message\n  @Binds val MessageImpl.bind: Message\n\n  @Provides\n  fun provideText(): String = \"Hello, world!\"\n}\n\n@Inject\nclass MessageImpl(val text: String) : Message\n</code></pre> <p>If you want to limit access to these from your API, you can make these declarations <code>private</code> and just return <code>this</code>. Note it\u2019s still important to annotate them with <code>@Binds</code> so that the Metro compiler understands its intent! Otherwise, it\u2019s an error to implement these declarations.</p> <p><code>@Binds</code> declarations can also declare multibinding annotations.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val messages: Message\n\n  @Binds @IntoSet val MessageImpl.bind: Message\n}\n</code></pre> <p><code>@Binds</code> declarations may also be declared in binding Containers.</p> <p>Note</p> <p>In theory, you can implement a provider with a getter that replicates this (similar to how kotlin-inject uses <code>@get:Provider</code> + <code>this</code>), but this will be an error in FIR because Metro can generate more efficient code at compile-time if you use <code>@Binds</code>. This is because Metro can avoid calling the function entirely and just use this information at compile-time to optimize the generated code.</p>"},{"location":"bindings/#multibindings","title":"Multibindings","text":"<p>Like Dagger and KI, Metro supports <code>Set</code> and <code>Map</code> multibindings. Multibindings are collections of bindings of a common type. Multibindings are implicitly declared by the existence of providers annotated with <code>@IntoSet</code>, <code>@IntoMap</code>, or <code>@ElementsIntoSet</code>.</p> <pre><code>@DependencyGraph\ninterface SetMultibinding {\n  // contains a set of [1, 2, 3, 4]\n  val ints: Set&lt;Int&gt;\n\n  @Provides @IntoSet fun provideInt1() = 1\n\n  @Provides @IntoSet fun provideInt2() = 2\n\n  @Provides\n  @ElementsIntoSet\n  fun provideInts() = setOf(3, 4)\n}\n</code></pre> <p>Map multibindings use <code>@IntoMap</code> and require a map key annotation. Map keys are any annotation annotated with <code>@MapKey</code>. Metro\u2019s runtime includes a number of common ones like <code>@ClassKey</code> and <code>@StringKey</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  // contains a map of {1:1, 2:2}\n  val ints: Map&lt;Int, Int&gt;\n\n  @Provides\n  @IntoMap\n  @IntKey(1)\n  fun provideInt1() = 1\n\n  @Provides\n  @IntoMap\n  @IntKey(2)\n  fun provideInt2() = 2\n}\n</code></pre> <p>Alternatively, they can be declared with an <code>@Multibinds</code>-annotated accessor property/function in a component. This member will be implemented by the Metro compiler and is useful for scenarios where the multibinding may be empty.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinds(allowEmpty = true)\n  val ints: Map&lt;Int, Int&gt;\n}\n</code></pre> <p>Multibinding collections are immutable at runtime and cannot be defined as mutable at request sites.</p> <p>Map multibindings support injecting map providers, where the value type can be wrapped in <code>Provider</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinds(allowEmpty = true)\n  val ints: Map&lt;Int, Provider&lt;Int&gt;&gt;\n}\n</code></pre> <p>Unlike Dagger, empty multibindings in Metro are a compile error by default. Empty multibindings are allowed but must be opted into via <code>@Multibinds(allowEmpty = true)</code>.</p> Implementation Notes <p>Metro takes inspiration from Guice in handling these in the binding graph. Since they cannot be added directly to the graph as-is (otherwise they would cause duplicate binding errors), a synthetic <code>@MultibindingElement</code> qualifier annotation is generated for them at compile-time to disambiguate them. These are user-invisible but allows them to participate directly in graph validation like any other dependency. Metro then just adds these bindings as dependencies to <code>Binding.Multibinding</code> types.</p>"},{"location":"bindings/#optional-dependencies","title":"Optional Dependencies","text":"<p>Metro supports optional dependencies by leaning on Kotlin\u2019s native support for default parameter values. These are checked at injection sites and are allowed to be missing from the dependency graph when performing a lookup at validation/code-gen time.</p> <p>The below example would, since there is no <code>Int</code> binding provided, provide a message of <code>Count: -1</code>.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(count: Int = -1) = \"Count: $count\"\n}\n</code></pre> <p>To expose accessors for optional dependencies, use <code>@OptionalDependency</code> on the accessor. Note that the accessor must declare a default body that Metro will use if the dependency is absent.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  @OptionalDependency\n  val message: String\n    get() = \"Absent!\"\n}\n</code></pre> <p>There are a couple of optional configuration for Metro\u2019s optional dependency support that can be configured via the <code>optionalDependencyBehavior</code> Gradle DSL:</p> <ul> <li><code>DISABLED</code> - Disallows optional dependencies entirely.</li> <li><code>REQUIRE_OPTIONAL_DEPENDENCY</code> - Requires optional dependency parameters to also be annotated with <code>@OptionalDependency</code>. This may be preferable for consistency with accessors and/or explicitness.</li> <li><code>DEFAULT</code> - The default behavior as described above \u2014 accessors must be annotated with <code>@OptionalDependency</code> with default bodies and parameters just use default value expressions.</li> </ul> <p>Dagger supports a similar feature via <code>@BindsOptionalOf</code>, but requires a separate declaration of this optional dependency to the graph.</p> <p>KI supports the same feature.</p>"},{"location":"bindings/#nullability","title":"Nullability","text":"<p>As nullability is a first-class concept in Kotlin, Metro supports it too. Bindings in Metro graphs may be nullable, but it\u2019s important to understand how Metro treats them!</p> <p>In short, Metro will treat nullable types as different type keys than their non-nullable analogues. That is to say, <code>String</code> and <code>String?</code> are treated as distinct types in Metro.</p> <p>Furthermore, a <code>String</code> binding cannot satisfy a <code>String?</code> automatically. You may however <code>@Binds</code> a <code>String</code> to a <code>String?</code> and Metro will treat it as a valid binding.</p> <pre><code>@DependencyGraph(Unit::class)\ninterface ExampleGraph {\n  val int: Int\n  val nullableInt: Int?\n\n  @Provides\n  fun provideInt(): Int = 1\n\n  @Binds\n  val Int.bindAsNullable: Int?\n}\n</code></pre> Implementation Notes <p>While kotlin-inject can support this by simply invoking functions with omitted arguments, Metro has to support this in generated factories.</p> <p>To accomplish this, Metro will slightly modify how generated provider/constructor injection factory classes look compared to Dagger. Since we are working in IR, we can copy the default value expressions from the source function/constructor to the factory\u2019s newInstance and create() functions. This in turn allows calling generated graphs to simply omit absent binding arguments from their creation calls. This is a tried and tested pattern used by other first party plugins, namely kotlinx-serialization.</p> <p>There are a few cases that need to be handled here:</p> <ul> <li>Expressions may reference previous parameters or instance members. To support this, we\u2019ll transform them in IR to point at new parameters in those functions.</li> <li>Expressions may reference private instance members. To support this, Metro factories are generated as nested classes within the source class or graph.<ul> <li>This does depart from how dagger factories work, but if we ever wanted to have some sort of interop for that we could always generate bridging factory classes in the places dagger expects later.</li> </ul> </li> <li>Parameters in <code>create()</code> need to be wrapped in <code>Provider</code> calls. This means that for cases where they back-reference other parameters, those will need to be transformed into <code>invoke()</code> calls on those providers too.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li> <p>New: Add missing dependency hints for missing bindings errors <pre><code>[Metro/MissingBinding] Cannot find an @Inject constructor or @Provides-annotated function/property for: FooImpl\n\n    FooImpl is injected at\n        [AppGraph] Bindings.bind: FooImpl\n    Base is requested at\n        [AppGraph] AppGraph.base\n\n(Hint)\n'FooImpl' doesn't appear to be visible to this compilation. This can happen when a binding references a type from an 'implementation' dependency that isn't exposed to the consuming graph's module.\nPossible fixes:\n- Mark the module containing 'FooImpl' as an 'api' dependency in the module that defines 'Bindings' (which is requesting it).\n- Add the module containing 'FooImpl' as an explicit dependency to the module that defines 'AppGraph'.\n</code></pre></p> </li> <li> <p>Enhancement: Improve code generation around multibinding collection builders and contributors, using more lazy getters in graph code gen.</p> </li> <li>Enhancement: Short-circuit empty map providers to <code>emptyMap()</code>.</li> <li>Enhancement: Support default values for assisted parameter arguments in top-level function injection.</li> <li>Fix: Compute <code>Optional</code> instance lazily when requested as a <code>Provider&lt;Optional&lt;T&gt;&gt;</code> and the underlying optional is not empty. Only applies to <code>@BindsOptionalOf</code> interop.</li> <li>Fix: Don\u2019t generate duplicate <code>init()</code> functions when chunking initializers if graphs already have an explicit <code>init()</code> function.</li> <li>Fix: Fix support for assisted inject with no assisted params.</li> <li>Fix: Detect platform types in just the <code>kotlin</code> package. Previously it missed any that didn\u2019t have multiple package segments.</li> </ul>"},{"location":"changelog/#070","title":"0.7.0","text":"<p>2025-10-17</p>"},{"location":"changelog/#dynamic-graphs","title":"Dynamic Graphs","text":"<p>Dynamic graphs are a powerful new feature of the Metro compiler that allows for dynamically replacing bindings in a given graph. To use them, you can pass in a vararg set of binding containers to the <code>createDynamicGraph()</code> and <code>createDynamicGraphFactory()</code> intrinsics.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(): String = \"real\"\n}\n\nclass AppTest {\n  val testGraph = createDynamicGraph&lt;AppGraph&gt;(FakeBindings)\n\n  @Test\n  fun test() {\n    assertEquals(\"fake\", testGraph.message)\n  }\n\n  @BindingContainer\n  object FakeBindings {\n    @Provides fun provideMessage(): String = \"fake\"\n  }\n}\n</code></pre> <p>This is particularly useful for tests. See their docs for more information: Dynamic Graphs.</p> <p>This API is experimental and may change in the future, please report any issues you encounter!</p>"},{"location":"changelog/#implicit-inject-behavior-on-most-contributes-annotated-types","title":"Implicit <code>@Inject</code> behavior on (most) <code>@Contributes*</code>-annotated types","text":"<p>Up to this point, Metro has always required you to use <code>@Inject</code> on most <code>@Contributes*</code> annotated types. However, this can feel a bit repetitive and tedious. In this release, there is a new <code>contributesAsInject</code> option that can be enabled that will treat all <code>@Contributes*</code> annotated types as <code>@Inject</code> by default. You can still use <code>@Inject</code> on classes to be explicit, and if you have multiple constructors you must still use <code>@Inject</code> on the constructor you want to be used.</p> <p>The only exception to this is <code>@ContributesTo</code>, which isn\u2019t applicable to injected types.</p> <p>This is disabled by default to start but will likely become the default in a future release.</p> <pre><code>@ContributesBinding(AppScope::class)\n// @Inject // &lt;-- now implicit!\nclass TacoImpl(...) : Taco\n</code></pre>"},{"location":"changelog/#other-changes","title":"Other Changes","text":"<ul> <li>Behavior change: Remove <code>assistedInjectMigrationSeverity</code> DSL. You must now move fully to using <code>@AssistedInject</code> annotations for assisted types.</li> <li>New: Allow exposing assisted-injected classes on a graph with qualifier annotations via <code>@Provides</code> declarations. This means you could, for example, write a provider like so: <pre><code>@Provides @Named(\"qualified\")\nfun provideTaco(factory: Taco.Factory): Taco = factory.create(\"spicy\")\n</code></pre></li> <li>New: Add diagnostic disallowing qualifier annotations directly on <code>@AssistedInject</code>-annotated classes.</li> <li>New: Add <code>wasmWasi</code> targets to Metro\u2019s runtime.</li> <li>New: Add diagnostic to report positional arguments use in custom interop annotations. See the interop docs for more information. This is disabled by default but can be configured via the <code>interopAnnotationsNamedArgSeverity</code> option.</li> <li>New: Support context parameters on top-level injected functions. See the docs for more information.</li> <li>New: Improve diagnostic checks around binding container arguments to annotations and graph creators.</li> <li>New: Add a diagnostic to warn on suspicious injection of unqualified object classes.</li> <li>Enhancement: Add diagnostic for providing a constructor-injected class with a different scope than the class (if the class has a scope).</li> <li>Enhancement: Allow replacing/excluding binding containers by <code>@Origin</code> annotations.</li> <li>Fix: Don\u2019t use interoped annotation arguments at matching indices if their name does not match the requested name.</li> <li>Fix: Trace all member injection dependencies from supertypes in graph reachability computation.</li> <li>Fix: Use compat <code>getContainingClassSymbol()</code> (fixes Kotlin 2.3.0-x compatibility).</li> <li>Fix: Better escape field names to be valid in JVM.</li> <li>Fix: Don\u2019t double-invoke <code>Optional</code> binding fields.</li> <li>Fix: Don\u2019t report duplicate bindings if injectors for both a parent and child class are present on a graph.</li> <li>Fix: Look up correct target class ID for computed member injectors in <code>BindingLookup</code>.</li> <li>Fix: Don\u2019t allow binding containers to be <code>inner</code> classes.</li> <li>Fix: Don\u2019t allow binding containers to be local classes.</li> <li>Fix: Don\u2019t allow binding containers to be anonymous objects.</li> <li>Fix: Fix wrong parent graph name in <code>IncompatiblyScopedBindings</code> hint.</li> <li>Fix: Fix replacements for regular contributed types not getting processed in graph extensions.</li> <li>Fix: Don\u2019t re-process contribution merging for generated graph extension impls during graph node creation.</li> <li>Fix: Don\u2019t reserve provider fields for custom wrapper types like interoped <code>Optional</code> types, avoiding accidental eager initialization in cycles.</li> <li>Change the warning key for redundant provides to more specific <code>REDUNDANT_PROVIDES</code>.</li> </ul> <p>Special thanks to @erawhctim and @CharlieTap for contributing to this release!</p>"},{"location":"changelog/#0610","title":"0.6.10","text":"<p>2025-10-11</p>"},{"location":"changelog/#optional-dependency-behaviors","title":"Optional Dependency Behaviors","text":"<p>Graph accessors can now expose optional dependencies, just use <code>@OptionalDependency</code> on the accessor. Note that the accessor must declare a default body that Metro will use if the dependency is absent.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  @OptionalDependency\n  val message: String\n    get() = \"Absent!\"\n}\n</code></pre> <p>There are a couple of optional configuration for Metro\u2019s optional dependency support that can be configured via the <code>optionalDependencyBehavior</code> Gradle DSL:</p> <ul> <li><code>DISABLED</code> - Disallows optional dependencies entirely.</li> <li><code>REQUIRE_OPTIONAL_DEPENDENCY</code> - Requires optional dependency parameters to also be annotated with <code>@OptionalDependency</code>. This may be preferable for consistency with accessors and/or explicitness.</li> <li><code>DEFAULT</code> - The default behavior as described above \u2014 accessors must be annotated with <code>@OptionalDependency</code> with default bodies and parameters just use default value expressions.</li> </ul>"},{"location":"changelog/#other-changes_1","title":"Other changes","text":"<ul> <li>New: Add interop for Dagger <code>@BindsOptionalOf</code>. Note this is currently only limited to <code>java.util.Optional</code>.</li> <li>Enhancement: Improve error messages for unexpected <code>IrErrorType</code> encounters.</li> <li>Enhancement: Add configurable <code>statementsPerInitFun</code> to option to control the number of statements per init function. Only for advanced/debugging use.</li> <li>Fix: Allow <code>@Includes</code> types themselves (i.e., not their accessors) to be dependencies in generated graphs.</li> <li>Fix: Allow multiple graph extension factory accessors of the same factory type on parent graphs.</li> <li>Fix: Report all missing <code>@Provides</code> body diagnostics rather than returning early.</li> <li>Fix: Allow <code>open</code> members from abstract graph class superclasses to be accessors.</li> <li>Fix: When detecting default function/property getter bodies in graph accessors, check for <code>open</code> modality as well.</li> <li>Fix: Don\u2019t duplicate includes accessor keys across multiple parent context levels.</li> <li>Fix: Fix not respecting ref counting when allocating provider fields for constructor-injected class providers. This should reduce generated graph code size quite a bit.</li> </ul> <p>Special thanks to @ChristianKatzmann for contributing to this release!</p>"},{"location":"changelog/#069","title":"0.6.9","text":"<p>2025-10-07</p> <p>This release introduces new experimental support for multiple compiler and IDE versions. The primary goal of this is to better support running Metro\u2019s FIR extensions across different IntelliJ Kotlin Plugin versions and make IDE support more robust, and general compiler compatibility falls out of that more or less for free. This is experimental and only going to target forward compatibility.</p> <ul> <li>New: Report more IR errors up to a maximum. The default is <code>20</code>, but is configurable via the <code>maxIrErrors</code> Gradle DSL option. If you want to restore the previous \u201cfail-fast\u201d behavior, you can set this value to <code>1</code>.</li> <li>New: Generate specific containing names in Kotlin 2.3.0+ when generating top-level functions for hint gen.</li> <li>Behavior change: Assisted-inject types can only be directly exposed on a graph if qualified.</li> <li>Behavior change: Update the Gradle plugin to target Kotlin 2.0, which requires Gradle <code>8.11</code> or later.</li> <li>Enhancement: Improve compatibility across 2.2.20 and 2.3.0+ releases. This release should be compatible with both!</li> <li>Enhancement: Add diagnostic for directly injecting unqualified assisted-injected classes rather than using their factories.</li> <li>Enhancement: Add diagnostic mixing <code>Provider</code> and <code>Lazy</code> types for <code>Provider&lt;Lazy&lt;T&gt;&gt;</code> injections.</li> <li>Enhancement: Add diagnostics for custom map keys.</li> <li>Enhancement: Fully allow exposing <code>Provider&lt;Lazy&lt;T&gt;&gt;</code> accessor types.</li> <li>Enhancement: Significantly improve duplicate binding error message rendering.</li> <li>Enhancement: Inline internal <code>trace</code> functions to reduce overhead.</li> <li>Enhancement: Don\u2019t always generate fields for <code>MembersInjector</code> bindings.</li> <li>Enhancement: Improve formatting of long cycles in <code>DependencyCycle</code> error messages.</li> <li>Enhancement: Improve formatting of aliases in <code>DependencyCycle</code> error messages. Aliases are now indicated with <code>~~&gt;</code> arrows instead of <code>--&gt;</code>.</li> <li>Enhancement: Improve formatting of member declarations in error messages for better IDE linking (if in the IDE terminal/console output) by using <code>.</code> separators instead of <code>#</code>.</li> <li>Fix: Avoid obscure <code>UnsupportedOperationException</code> failures when reporting missing bindings.</li> <li>Fix: Only generate assisted factories if <code>@AssistedInject</code> annotations are used on the target class.</li> <li>Fix: Remove <code>PsiElement</code> shading workaround when reporting diagnostics.</li> <li>Fix: Treat <code>MembersInjector</code> types as implicitly deferrable in binding graph validation.</li> <li>Fix: Report cycles in form of <code>binding --&gt; dependency</code> rather than the reverse for better readability.</li> </ul> <p>Special thanks to @kevinguitar, @hossain-khan, and @vRallev for contributing to this release!</p>"},{"location":"changelog/#068","title":"0.6.8","text":"<p>2025-09-26</p> <ul> <li>Fix: Preserve original nullability when canonicalizing generic types.</li> </ul>"},{"location":"changelog/#067","title":"0.6.7","text":"<p>2025-09-25</p>"},{"location":"changelog/#new-assistedinject-annotation","title":"New <code>@AssistedInject</code> annotation","text":"<p>Assisted-injected classes must now use <code>@AssistedInject</code> instead of <code>@Inject</code>.</p> <p>This is for multiple reasons:   - It\u2019s more explicit at the source declaration site that this uses assisted injection and cannot be requested directly on the DI graph. This is particularly useful for scenarios where there no assisted parameters but you still want to use assisted injection.   - This will allow adding more granular checks at compile-time to validate use-sites.   - This will allow providing assisted types directly on the graph.   - Will simplify some of Metro\u2019s internal logic.</p> <p>Note that not all internal changes are implemented yet to allow for a migration period. In this release, use of <code>@Inject</code> with <code>@Assisted</code> parameters is a compiler warning and will become an error in the future. This diagnostic is configurable via the <code>assistedInjectMigrationSeverity</code> Gradle DSL option.</p>"},{"location":"changelog/#other-changes_2","title":"Other changes","text":"<ul> <li>New: Support for interop with externally generated Dagger modules.</li> <li>Enhancement: Always check for available assisted factories when reporting <code>InvalidBinding</code> errors about misused assisted injects.</li> <li>Enhancement: Always specifically report mismatched assisted parameter mismatches.</li> <li>Enhancement: Validate <code>Lazy</code> assisted factory injections in more places.</li> <li>Enhancement: Allow private <code>@Binds</code> properties.</li> <li>Enhancement: Better canonicalize flexible mutability from Dagger interop in collections and flexible nullability.</li> <li>Enhancement: Better canonicalize flexible nullability from Dagger interop in generic type arguments.</li> <li>Enhancement: Simplify assisted factory impl class generation by moving it entirely to IR.</li> <li>Enhancement: Allow qualifier narrowing but not widening on graph accessor types. Essentially, you can have a base interface with an unqualified accessor and then override that to add a qualifier in a subtype, but not the other way around.</li> <li>Fix: Register <code>MetroDiagnostics</code> in FIR.</li> <li>Fix: Use correct severity when reporting warnings to <code>MessageCollector</code> from newer IR diagnostics factories.</li> <li>Fix: When transforming FIR override statuses, check all supertypes and not just immediate supertype.</li> <li>Fix: Carry qualifiers over from Dagger inject constructors when interoping with dagger factories.</li> <li>If Dagger runtime interop is enabled, do not run status transformation on <code>@Provides</code> declarations in dagger modules.</li> </ul> <p>Special thanks to @kevinguitar, @ChristianKatzmann, and @hossain-khan for contributing to this release!</p>"},{"location":"changelog/#066","title":"0.6.6","text":"<p>2025-09-11</p> <ul> <li>Enhancement: Optimize annotation lookups in some places in IR.</li> <li>Fix: If a graph declares an overridable declaration that matches one of a contributed supertype, transform it to add the requisite <code>override</code> modifier.<ul> <li>All that is to say, this code now works <pre><code>@ContributesTo(AppScope::class)\ninterface StringRequester {\n  val string: String\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val string: String // &lt;-- previously failed to compile due to missing override\n}\n</code></pre></li> </ul> </li> <li>Update to Kotlin <code>2.2.20</code>. This release requires <code>2.2.20</code> or later. See the compatibility docs.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#065","title":"0.6.5","text":"<p>2025-09-11</p> <ul> <li>New: Add <code>@Origin</code> annotation for custom code generators to link origin classes. See the docs.</li> <li>Fix: Fix wrong <code>IrType</code> for default value expressions wrapped in <code>Provider</code>.</li> </ul> <p>Special thanks to @ChristianKatzmann, @KevinGuitar, and @hossain-khan for contributing to this release!</p>"},{"location":"changelog/#064","title":"0.6.4","text":"<p>2025-09-01</p> <ul> <li>Enhancement: Transform and collect contribution data in a single pass during IR.</li> <li>Fix: Ensure contributed binding containers\u2019 included containers are available in root dependency graphs.</li> <li>Fix: Make <code>@Includes</code> parameter keys available to extensions.</li> <li>Fix: Fix an edge case where an included binding container that\u2019s transitively included by another container is seen to have zero bindings.</li> <li>Fix: Report diagnostic errors to check that binding containers don\u2019t extend other binding containers.</li> <li>Fix: Report diagnostic errors if accessors or injectors have conflicting qualifiers in overridden functions.</li> <li>Fix: Report diagnostic errors if an injector function does not return <code>Unit</code>.</li> </ul> <p>Special thanks to @joelwilcox, @vRallev, @kevinguitar, and @erawhctim for contributing to this release!</p>"},{"location":"changelog/#063","title":"0.6.3","text":"<p>2025-08-23</p> <ul> <li>Enhancement: Allow <code>@Includes</code> parameters that are binding containers to transitively include other binding containers.</li> <li>Fix: Ensure provider fields for graph instances when needed by extensions.</li> </ul> <p>Special thanks to @hossain-khan, @vRallev, and @erawhctim for contributing to this release!</p>"},{"location":"changelog/#062","title":"0.6.2","text":"<p>2025-08-22</p> <ul> <li>Enhancement: Add diagnostic for contributed binding containers with no (visible) no-arg constructor.</li> <li>Enhancement: Add hint for missing bindings if the binding appears to be contributed by an <code>internal</code> type in another, non-friend module.</li> <li>Fix: Don\u2019t allocate new fields for deferred bindings reserved by extension graphs.</li> <li>Fix: Allow graph extensions to expose their own factories if inherited from parents.</li> </ul> <p>Special thanks to @KevinGuitar, @hossain-khan and @ChrisBanes for contributing to this release!</p>"},{"location":"changelog/#061","title":"0.6.1","text":"<p>2025-08-20</p> <ul> <li>New: Add a diagnostic to report parent keys used by graph extensions <code>parent-keys-used-*.txt</code>.</li> <li>Enhancement: Graph extensions are now generated as <code>inner</code> classes, reducing much of the necessary generated code in parent graphs and allowing them to access parent binding fields directly.</li> <li>Enhancement: Allow graph extensions to depend on other graph extensions within the context of their parent graph.</li> <li>Enhancement: Add a diagnostic for graph factories with vararg parameters.</li> <li>Enhancement: Allow graph extension factories to participate in the binding graph, which then allows injecting or binding them like any other dependency.</li> <li>Enhancement: Improve error message location accuracy for missing bindings when reporting from a <code>@Binds</code> declaration.</li> <li>Fix: Don\u2019t override graph extension factories\u2019 default functions.</li> <li>Fix: Fix Kotlin internal error overriding Metro error when there\u2019s a missing factory for a Java <code>@Inject</code> class.</li> <li>[Docs] The project website is now versioned. This means you can read the documentation at different versions:</li> <li>Latest release: https://zacsweers.github.io/metro/latest/</li> <li>Snapshots (example): https://zacsweers.github.io/metro/0.7.0-SNAPSHOT/</li> <li>Past release (example): https://zacsweers.github.io/metro/0.6.0/</li> <li>Deprecate the <code>enableStrictValidation</code> Gradle property in favor of <code>enableFullBindingGraphValidation</code>, which aligns with Dagger\u2019s (better) name for the same functionality.</li> <li>Update Wire to <code>5.3.11</code>.</li> </ul> <p>Special thanks to @hossain-khan and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#060","title":"0.6.0","text":"<p>2025-08-15</p>"},{"location":"changelog/#graph-extensions-are-no-longer-detached","title":"Graph extensions are no longer detached.","text":"<p>TL;DR: Metro graph extensions are now wired similar to Dagger subcomponents and use a new <code>@GraphExtension</code> annotation. <code>@Extends</code> and <code>isExtendable</code> are now deleted, <code>@ContributesGraphExtension</code> and <code>enableScopedInjectClassHints()</code> are deprecated.</p> <p>Up to this point, Metro\u2019s graph extensions have been detached. This meant that extensions could simply depend on a parent graph via <code>@Extends</code> and parent graphs had to mark themselves as extendable via <code>isExtendable = true</code>. This approach mirrored kotlin-inject\u2019s approach and was convenient in its flexibility. However, it\u2019s proven too problematic in practice for a few reasons:</p> <ol> <li>Parent graphs have to generate a bunch of extra code for extensions. Namely, scoped providers and any instances of containers/parents they are holding on to need accessors. It also generates extra metadata (metro serializes its own metadata to its types) for separate graphs to read.</li> <li>Because of the above, parent graphs had to opt-in to extension via <code>isExtendable = true</code>.</li> <li>Up to this point, parent graphs always held scoped providers for all <code>@Provides</code> bindings in it or containers, even if they do not use them.</li> <li>Similar to #3, we\u2019ve had to add support for automatic discovery of scoped constructor-injected classes (via <code>enableScopedInjectClassHints()</code>) to ensure they are also held at the appropriate scope.</li> <li>This has ended up causing a lot of headaches because eager validation complicates these in scenarios where you have multiple graphs that may not actually use that class anywhere (and thus not provide some of its dependencies)</li> <li>Because every graph must expose every available binding to unknown extensions, every graph in a chain is often bloated with bindings it doesn\u2019t use.</li> </ol> <p>Metro could optimize the <code>@ContributesGraphExtension</code> cases where Metro\u2019s compiler has a view of the entire graph chain, but that would frankly leave Metro with a lot of edge cases to deal with and users with needing to know about two different ways to extend graphs. We opted against that, and instead are now going to process graph extensions in a similar way to Dagger\u2019s subcomponents.</p> <p>This will allow Metro to</p> <ol> <li>Fully optimize the whole graph chain.</li> <li>Automatically scope bindings in parents (no need to expose accessors for scoped bindings unused in parents).</li> <li>Only generate exactly the bindings that are used in each graph with lazy validation of bindings.</li> </ol>"},{"location":"changelog/#graphextension","title":"<code>@GraphExtension</code>","text":"<p><code>@GraphExtension</code> is a new annotation to denote a graph that is an extension. This is analogous to Dagger\u2019s <code>@Subcomponent</code> and dagger interop treats it as such.</p> <p>To connect an extension to a parent graph, you can do one of multiple ways:</p> <ul> <li>Declare an accessor on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraph: LoggedInGraph\n}\n</code></pre> <ul> <li>(If the extension has a creator) declare the creator on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraphFactory: LoggedInGraph.Factory\n}\n</code></pre> <ul> <li>(If the extension has a creator) make the parent graph implement the creator.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph : LoggedInGraph.Factory\n</code></pre> <ul> <li>Contribute the factory to the parent graph via <code>@ContributesTo</code>.</li> </ul> <pre><code>@GraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n  @ContributesTo(AppScope::class)\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"changelog/#migration","title":"Migration","text":"<p>The following APIs have been removed or deprecated:</p> <ul> <li><code>@Extends</code>. Migrate to <code>@GraphExtension</code>, remove this parameter, and expose the factory in the parent graph API as documented above.</li> <li><code>isExtendable</code> is removed from <code>@DependencyGraph</code> and <code>@ContributesGraphExtension</code>.</li> <li><code>@ContributesGraphExtension</code> is now deprecated and treated like <code>@GraphExtension</code>.</li> <li><code>@ContributesGraphExtension.Factory</code> is deprecated with error severity and requires migration to the new <code>@ContributesTo</code> pattern.</li> <li><code>enableScopedInjectClassHints()</code> is now deprecated and does nothing. It will be removed in the future.</li> <li>Graph extensions may no longer have multiple direct parents.</li> </ul> <p>To create graph extensions, you now must do so via a parent graph (using one of the above connecting mechanisms).</p>"},{"location":"changelog/#other-changes_3","title":"Other changes","text":"<ul> <li>Breaking change: Rename <code>custom-graph</code> compiler option to <code>custom-dependency-graph</code>.</li> <li>Breaking change: Rename <code>custom-dependency-graph-factory</code> compiler option to <code>custom-dependency-graph-factory</code>.</li> <li>Breaking change: Rename <code>MetroPluginExtension.graph</code> gradle extension property to <code>MetroPluginExtension.dependencyGraph</code>.</li> <li>Breaking change: Rename <code>MetroPluginExtension.graphFactory</code> gradle extension property to <code>MetroPluginExtension.dependencyGraphFactory</code>.</li> <li>Behavior change: <code>@Provides</code> and <code>@Binds</code> bindings are now only validated if they are used by the owning graph. Previously, they were always validated.<ul> <li>If you want to keep the previous behavior, you can enable the <code>enableStrictValidation()</code> option.</li> </ul> </li> <li>Behavior change: <code>chunkFieldInits()</code> is now enabled by default.</li> <li>Behavior change: When adding bindings from extended parent graphs, ignore any that are provided directly in the child graph. Previously, Metro only ignored the binding if the binding was itself a graph type.</li> <li>New: Add diagnostic reports for (valid) cycles. This means if you have a cycle in your graph and enable a <code>reportsDestination</code>, Metro will generate files with a list of all the keys in that cycle.</li> <li>Enhancement: In tracing logs, include the graph name in the \u201cTransform dependency graph\u201d sections.</li> <li>Enhancement: Allow contributing annotations on assisted-injected classes.</li> <li>Enhancement: Improve dagger interop with <code>dagger.Lazy</code> types by allowing <code>Provider</code> subtypes to be wrapped too.</li> <li>Enhancement: Support <code>rank</code> interop on Anvil annotations in contributed graph extensions.</li> <li>Enhancement: Support <code>ignoreQualifier</code> interop on Anvil annotations in contributed graph extensions.</li> <li>Enhancement: Only process contributions to the consuming graph\u2019s scopes when processing <code>rank</code> replacements in FIR.</li> <li>Enhancement: Improve error message for invalid assisted inject bindings to injected target.</li> <li>Enhancement: Report similar bindings in missing binding errors where the similar binding doesn\u2019t have a qualifier but the requested binding does. Previously we only reported if the similar binding had a qualifier and the requested binding didn\u2019t.</li> <li>Fix: Don\u2019t link expect/actual declarations if they\u2019re in the same file.</li> <li>Fix: Don\u2019t copy map keys over into generated <code>@Binds</code> contributions unless it\u2019s an <code>@IntoMap</code> binding.</li> <li>Fix: Fall back to annotation sources if needed when reporting errors with bound types in FIR.</li> <li>Fix: Use <code>MapProviderFactory.builder().build()</code> for Dagger interop on <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> types as there is no <code>MapProviderFactory.empty()</code>.</li> <li>Fix: Don\u2019t assume <code>@ContributesGraphExtension</code> to have aggregation scopes during graph generation.</li> <li>Fix: When extending graphs, ignore bindings of the same type as the inheriting graph.</li> <li>Fix: Propagate parent graph empty <code>@Multibinds</code> declarations to extensions.</li> <li>Fix: Propagate managed binding containers to extension graphs.</li> <li>Fix: Propagate transitively included binding containers contributed to contributed graphs (sorry, word soup).</li> <li>Fix: Make generated multibinding element IDs stable across compilations.</li> <li>Fix: Handle location-less declarations when reporting invalid assisted inject bindings.</li> <li>Fix: Don\u2019t chunk parent graph validation statements as these must be in the original constructor body.</li> <li>Fix: Fix wrong receiver context for chunked field initializers.</li> <li>Fix: Fix support for generic private injected constructors.</li> <li>[internal change] Simplify metadata and just use accessor annotations.</li> <li>[internal change] Graph extension impls are now generated as nested classes within the generated metro graph that they are contributed to.</li> <li>Update to Kotlin <code>2.2.10</code>.</li> </ul> <p>Special thanks to @hossain-khan, @Egorand, @kevinguitar, @jonapoul, and @martinbonnin for contributing to this release!</p>"},{"location":"changelog/#055","title":"0.5.5","text":"<p>2025-08-02</p> <ul> <li>Fix: Fix Wire shading in native targets.</li> </ul>"},{"location":"changelog/#054","title":"0.5.4","text":"<p>2025-08-01</p> <ul> <li>Enhancement: Support <code>excludes</code>, <code>bindingContainers</code>, and <code>additionalScopes</code> in <code>@ContributesGraphExtension</code>.</li> <li>Enhancement: Allow binding containers and regular contributed classes to replace each other in contribution merging.</li> <li>Enhancement: Allow <code>@ElementsIntoSet</code> on properties.</li> <li>Enhancement: Don\u2019t run FIR extensions on Java sources.</li> <li>Fix: Report incompatible scopes in nested contributed graphs to <code>MessageCollector</code> until Kotlin 2.2.20.</li> <li>Fix: Report binding issues from externally contributed graphs to <code>MessageCollector</code> until Kotlin 2.2.20.</li> <li>Fix: Preserve nullability when remapping type parameters.</li> <li>Fix: Don\u2019t double-add <code>@ContributesTo</code> contributions while merging contributed graphs.</li> <li>Fix: Check <code>rawStatus</code> for overrides when merging contributed supertypes.</li> <li>Fix: Correctly extract the element type when creating implicit <code>Set</code> multibindings from <code>@ElementsIntoSet</code> contributors.</li> <li>Fix: Check <code>additionalScopes</code> when merging binding containers too.</li> <li>Fix: Don\u2019t fail if multiple contributing annotations on binding containers match the target scope when aggregating them.</li> <li>Fix: Dedupe binding containers during graph node generation.</li> <li>Fix: Add a checker for <code>@Provides</code> constructor parameters in binding containers.</li> <li>Fix: Fix reading repeated external contributed annotations.</li> <li>Fix: Filter by matching scopes when merging contributed types with repeated annotations.</li> </ul> <p>Special thanks to @hossain-khan, @gabrielittner, @kevinguitar, @JoelWilcox, and @martinbonnin for contributing to this release!</p>"},{"location":"changelog/#053","title":"0.5.3","text":"<p>2025-07-28</p> <ul> <li>Behavior change: The <code>enableScopedInjectClassHints</code> option is no longer enabled by default. This option is tricky to get right and will be iterated on further in #764.</li> <li>Enhancement: Generate synthetic <code>$$BindsMirror</code> classes to\u2026<ul> <li>support full IC compatibility with changing annotations and return types on <code>@Binds</code> and <code>@Multibinds</code> declarations</li> <li>allow these declarations to be <code>private</code></li> </ul> </li> <li>Enhancement: Allow <code>@Binds</code> and <code>@Multibinds</code> functions to be private.</li> <li>Enhancement: Allow \u201cstatic graphs\u201d via companions implementing the graph interface itself.</li> <li>Enhancement: Allow graphs to aggregate <code>internal</code> contributions from other compilations IFF those compilations are marked as friend paths. This mainly allows for test graphs to consume contributions from their corresponding main source sets.</li> <li>Enhancement: Allow <code>internal</code> graphs to extend <code>internal</code> contributed interfaces from other compilations IFF those compilations are marked as friend paths.</li> <li>Fix: Sort soft edges before hard edges within (valid) cycles. Previously we would just apply a standard topological sort here, but in this scenario we want to add extra weight to ready-up nodes that depend directly on the deferred type being used to break the cycle first.</li> <li>Fix: When recording IC lookups of overridable declarations, only record the original declaration and not fake overrides.</li> <li>Fix: Record IC lookups to <code>@Multibinds</code> declarations.</li> <li>Fix: Write <code>@Multibinds</code> information to metro metadata.</li> <li>Fix: Always write metro metadata to <code>@BindingContainer</code> classes, even if empty.</li> <li>Fix: When <code>@Includes</code>-ing other graphs, link against the original interface accessor rather than the generated <code>$$MetroGraph</code> accessor.</li> <li>Fix: Disambiguate contributed nullable bindings from non-nullable bindings.</li> <li>Fix: When computing <code>@Includes</code> graph dependencies from accessors, only consider directly included graphs and not transitively included graphs.</li> <li>Fix: Expose <code>@Includes</code> graph dependencies as synthetic <code>_metroAccessor</code> types for extended graphs rather than exposing the included graph directly.</li> <li>Fix: Prohibit calling <code>.asContribution()</code> on <code>@ContributesGraphExtension</code>-annotated types. <code>@ContributesGraphExtension</code>-annotated types cannot be validated at compile-time with this function as their generated class is definitionally contextual and the compiler cannot infer that from callsites of this function alone.</li> <li>Fix: Only process <code>@DependencyGraph</code> types in FIR supertype generation. Contributed graph extension supertypes are merged only in IR.</li> <li>Fix: Generate <code>$$MetroContribution</code> binds functions before aggregating contributions.</li> <li>Fix: Don\u2019t short-circuit class visiting in contribution visiting in IR.</li> <li>Fix: Propagate property annotations for <code>@Provides</code>-properties, previously only the accessor function annotations were being included.</li> <li>Fix: Propagate class annotations for <code>@Inject</code>-annotated constructors to factory class mirror functions, previously only the constructor\u2019s annotations were being included.</li> <li>Fix: Fix dispatch receiver for <code>DelegateFactory</code> fields when <code>chunkFieldInits</code> is enabled.</li> <li>Fix: Fix compilation error for members-injected classes with no direct, but only inherited <code>@Inject</code> attributes.</li> <li>Fix: Always look up member injectors of ancestor classes of classes member-injected by graphs (sorry, word soup I know).</li> <li>Fix: Ensure <code>$$MetroContribution</code> interfaces are not generated for binding containers by ensuring binding container annotations are readable during their generation.</li> <li>Change to <code>UnsupportedOperationException</code> for compiler intrinsic stubs, matching what the stdlib does.</li> <li>Add a <code>ViewModel</code> assisted injection example to <code>compose-navigation-app</code> sample.</li> <li>Small improvements to the doc site (404 page, favicon, etc.)</li> </ul> <p>Special thanks to @hossain-khan, @bnorm, @yschimke, @kevinguitar, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#052","title":"0.5.2","text":"<p>2025-07-21</p> <ul> <li>Enhancement: De-dupe contributions before processing in contributed graphs.</li> <li>Fix: Don\u2019t extend contributed binding container classes in generated contributed graphs.</li> <li>Small doc fixes.</li> </ul> <p>Special thanks to @bnorm and @alexvanyo for contributing to this release!</p>"},{"location":"changelog/#051","title":"0.5.1","text":"<p>2025-07-18</p> <ul> <li>Breaking change: Rename the <code>generateHintProperties</code> Gradle DSL property to <code>generateContributionHints</code>.</li> <li>Enhancement: Chunk field initializers and constructor statements across multiple init functions to avoid <code>MethodTooLargeException</code> in large graphs. This is currently experimental and gated behind the <code>chunkFieldInits()</code> Gradle DSL.</li> <li>Enhancement: Mark generated factories and member injectors\u2019 constructors as <code>private</code>, matching the same change in Dagger 2.57.</li> <li>Enhancement: Add a new Metro option <code>warnOnInjectAnnotationPlacement</code> to disable suggestion to lift @Inject to class when there is only one constructor, the warning applies to constructors with params too.</li> <li>Fix: Fix <code>@Contributes*.replaces</code> not working if the contributed type is in the same compilation but a different file.</li> <li>Fix: Fix generated <code>MembersInjector.create()</code> return types\u2019 generic argument to use the target class.</li> <li>Fix: Don\u2019t generated nested MetroContribution classes for binding containers.</li> <li>Fix: Fix contributing binding containers across compilations.</li> </ul> <p>Special thanks to @kevinguitar and @ChristianKatzmann for contributing to this release!</p>"},{"location":"changelog/#050","title":"0.5.0","text":"<p>2025-07-14</p> <ul> <li>New: Experimental support for \u201cbinding containers\u201d via <code>@BindingContainer</code>. See their docs for more details.</li> <li>New: Add <code>keys-scopedProviderFields-*.txt</code> and <code>keys-providerFields-*.txt</code> reports to see generated field reports for graphs.</li> <li>Enhancement: Remove <code>Any</code> constraint from <code>binding&lt;T&gt;()</code>, allowing bindings to satisfy nullable variants.</li> <li>Enhancement: Add diagnostic to check for scoped <code>@Binds</code> declarations. These are simple pipes and should not have scope annotations.</li> <li>Enhancement: Move graph dependency cycle checks to earlier in validation.</li> <li>Enhancement: When using Dagger interop, default <code>allowEmpty</code> to true when using Dagger\u2019s <code>@Multibinds</code> annotation.</li> <li>Enhancement: Make Dagger interop providers/lazy instances a <code>dagger.internal.Provider</code> internally for better compatibility with Dagger internals. Some dagger-generated code assumes this type at runtime.</li> <li>Enhancement: Support javax/jakarta <code>Provider</code> types as multibinding Map value types when Dagger interop is enabled.</li> <li>Enhancement: Completely skip processing local and enum classes as they\u2019re irrelevant to Metro\u2019s compiler.</li> <li>Enhancement: When reporting <code>@Binds</code> declarations in binding stacks, report the original declaration rather than inherited fake overrides.</li> <li>Enhancement: Add interop support for kotlin-inject\u2019s <code>@AssistedFactory</code> annotations.</li> <li>Enhancement: Add diagnostic to check for graph classes directly extending other graph classes. You should use <code>@Extends</code>.</li> <li>Enhancement: Add diagnostic to check for <code>@Assisted</code> parameters in provides functions.</li> <li>Enhancement: Add diagnostic to check duplicate <code>@Provides</code> declaration names in the same class.</li> <li>Fix: Within (valid) cycles, topographically sort bindings within the cycle. Previously these would fall back to a deterministic-but-wrong alphabetical sort.</li> <li>Fix: Handle enum entry arguments to qualifier, scope, and map key annotations.</li> <li>Fix: Report the original location of declarations in fake overrides in error reporting.</li> <li>Fix: Handle default values on provides parameters with absent bindings during graph population.</li> <li>Fix: Don\u2019t try to read private accessors of <code>@Includes</code> parameters.</li> <li>Fix: Don\u2019t quietly stub accessors for missing <code>Binding.Provided</code> bindings.</li> <li>Fix: Check constructor-annotated injections when discovering scoped classes in parent graphs.</li> <li>Fix: Fix <code>BaseDoubleCheck.isInitialized()</code>.</li> <li>Fix: Gracefully fall back to <code>MessageCollector</code> for graph seal and contributed graph errors on sourceless declarations.</li> <li>Fix: Fix supporting overloads of binds functions from parent graphs or external supertypes.</li> <li>Fix: Fix generating binding functions with names that contain dashes.</li> <li>Fix: Treat interop\u2019d Dagger/Anvil/KI components as implicitly extendable.</li> <li>Fix: Record lookups of <code>@Binds</code> declarations for IC.</li> <li>Fix: Record lookups of generated class factories and their constructor signatures for IC.</li> </ul> <p>Special thanks to @kevinguitar, @gabrielittner, @chrisbanes, @yschimke, and @ajarl for contributing to this release!</p>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>2025-06-23</p> <ul> <li>New: Injected constructors may now be private. This can be useful for scenarios where you want <code>@Inject</code>-annotated constructors to only be invokable by Metro\u2019s generated code.</li> <li>New: If reporting is enabled, write unused bindings diagnostics to <code>keys-unused-*.txt</code>.</li> <li>New: Support for generic assisted injection.</li> <li>New: Support for generic member injection.</li> <li>New: Add diagnostic to prohibit type parameters on injected member functions.</li> <li>Enhancement: Enable child graphs to depend on parent-scoped dependencies that are unused and not referenced in the parent scope. This involves generating hints for scoped <code>@Inject</code> classes and is gated on a new Metro option <code>enableScopedInjectClassHints</code>, which is enabled by default.</li> <li>Enhancement: Check for context parameters in top-level function injection checker.</li> <li>Enhancement: Store member injection info in metro metadata to slightly optimize member injection code gen.</li> <li>Enhancement: Avoid writing providers fields in graphs for unused bindings.</li> <li>Enhancement: Improve missing binding trace originating from root member injectors.</li> <li>Fix: Fix support for generic injected constructor parameters.</li> <li>Fix: Fix support for repeated contributes annotations by moving contribution binding function generation to IR.</li> <li>Fix: Ensure scope/qualifier annotation changes on constructor-injected classes dirty consuming graphs in incremental compilation.</li> <li>Fix: Report member injection dependencies when looking up constructor-injected classes during graph population.</li> <li>Fix: Disable IR hint generation on JS targets too, as these now have the same limitation as native/WASM targets in Kotlin 2.2. Pending upstream support for generating top-level FIR declarations in KT-75865.</li> <li>Fix: Ensure private provider function annotations are propagated across compilation boundaries.</li> <li>Fix: Substitute copied FIR type parameter symbols with symbols from their target functions.</li> <li>Fix: Improved support for generic member injection.</li> <li>Fix: Propagate qualifiers on graph member injector functions.</li> <li>Fix: Fix support for requesting <code>MembersInjector</code> types.</li> <li>[internal] Report IR errors through <code>IrDiagnosticReporter</code>.</li> <li>[internal] Significantly refactor + simplify IR parameter handling.</li> <li>Fix publishing Apple native targets in snapshots.</li> <li>Update to Kotlin <code>2.2.0</code>.</li> <li>Update Gradle plugin to target Kotlin language version to <code>1.9</code> (requires Gradle 8.3+).</li> </ul> <p>Special thanks to @kevinguitar, @gabrielittner, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#038","title":"0.3.8","text":"<p>2025-06-16</p> <ul> <li>Enhancement: Disambiguate <code>MetroContribution</code> class names based on scope to better support IC when changing scopes.</li> <li>Enhancement: Minimize deferred types when breaking cycles.</li> <li>Fix: Disallow injection of <code>Lazy&lt;T&gt;</code> where <code>T</code> is an <code>@AssistedFactory</code>-annotated class.</li> <li>Fix: Don\u2019t short-circuit assisted injection validation if only an accessor exists.</li> <li>Fix: Allow cycles of assisted factories to their target classes.</li> <li>Update shaded okio to <code>3.13.0</code>.</li> <li>Update atomicfu to <code>0.28.0</code>.</li> </ul> <p>Special thanks to @kevinguitar, @bnorm, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#037","title":"0.3.7","text":"<p>2025-06-08</p> <ul> <li>Fix: Record lookups of generated static member inject functions for IC.</li> <li>Fix: Dedupe merged overrides of <code>@Includes</code> accessors.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#036","title":"0.3.6","text":"<p>2025-06-06</p> <ul> <li>New: Add new <code>Provider.map</code>, <code>Provider.flatMap</code>, <code>Provider.zip</code>, and <code>Provider.memoize</code> utility APIs.</li> <li>Enhancement: Improve graph validation performance by avoiding unnecessary intermediate sorts (again).</li> <li>Enhancement: Fail eagerly with a clear error message if <code>languageVersion</code> is too old.</li> <li>Enhancement: Validate improperly depending on assisted-injected classes directly at compile-time.</li> <li>Fix: Support constructing nested function return types for provider functions.</li> <li>Fix: Propagate <code>@Include</code> bindings from parent graphs to extension graphs.</li> <li>Fix: Reparent copied lambda default values in IR.</li> <li>[internal] Make internal renderings of <code>IrType</code> more deterministic.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#035","title":"0.3.5","text":"<p>2025-05-31</p> <ul> <li>New: Implement top-level function injection checkers.</li> <li>Change: Disallow top-level function injections to be scoped.</li> <li>Fix: Support type parameters with <code>where</code> bounds.</li> <li>Fix: Support injected class type parameters with any bounds.</li> <li>Fix: Support generic graph factory interfaces.</li> <li>Fix: In the presence of multiple contributing annotations to the same scope, ensure only hint function/file is generated.</li> <li>Fix: Improve shading to avoid packaging in stdlib and other dependency classes.</li> <li>Fix: Revert #483 as it broke some cases we haven\u2019t been able to debug yet.</li> </ul> <p>Special thanks to @gabrielittner and @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#034","title":"0.3.4","text":"<p>2025-05-27</p> <ul> <li>Enhancement: Use a simple numbered (but deterministic) naming for contributed graph classes to avoid long class names.</li> <li>Enhancement: Improve graph validation performance by avoiding unnecessary intermediate sorts.</li> <li>Enhancement: Move binding validation into graph validation step.</li> <li>Enhancement: Avoid unnecessary BFS graph walk in provider field collection.</li> <li>Fix: Fix provider field populating missing types that previously seen types dependent on.</li> </ul> <p>Special thanks to @ChristianKatzmann and @madisp for contributing to this release!</p>"},{"location":"changelog/#033","title":"0.3.3","text":"<p>2025-05-26</p> <ul> <li>Enhancement: Don\u2019t unnecessarily wrap <code>Provider</code> graph accessors.</li> <li>Enhancement: Allow multiple contributed graphs to the same parent graph.</li> <li>Fix: Don\u2019t unnecessarily recompute bindings for roots when populating graphs.</li> <li>Fix: Better handle generic assisted factory interfaces.</li> <li>Fix: Use fully qualified names when generating hint files to avoid collisions.</li> <li>Fix: Support provides functions with capitalized names.</li> <li>Fix: Prohibit consuming <code>Provider&lt;Lazy&lt;...&gt;&gt;</code> graph accessors.</li> <li>[internal] Migrate to new IR <code>parameters</code>/<code>arguments</code>/<code>typeArguments</code> compiler APIs.</li> </ul> <p>Special thanks to @gabrielittner for contributing to this release!</p>"},{"location":"changelog/#032","title":"0.3.2","text":"<p>2025-05-15</p> <ul> <li>Enhancement: Optimize supertype lookups in IR.</li> <li>Fix: Fix generic members inherited from generic supertypes of contributed graphs.</li> <li>Fix: Fix <code>@ContributedGraphExtension</code> that extends the same interface as the parent causes a duplicate binding error.</li> <li>Fix: Fix contributed binding replacements not being respected in contributed graphs.</li> <li>Fix: Fix contributed providers not being visible to N+2+ descendant graphs.</li> <li>Fix: Collect bindings from member injectors as well as exposed accessors when determining scoped provider fields.</li> <li>Fix: Fix a few <code>-Xverify-ir</code> and <code>-Xverify-ir-visibility</code> issues + run all tests with these enabled now.</li> </ul> <p>Special thanks to @bnorm, @gabrielittner, @kevinguitar, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#031","title":"0.3.1","text":"<p>2025-05-13</p> <ul> <li>Enhancement: Rewrite graph resolution using topological sorting to vastly improve performance and simplify generation.</li> <li>Enhancement: Return early once an externally-compiled dependency graph is found.</li> <li>Enhancement: Simplify multibinding contributor handling in graph resolution by generating synthetic qualifiers for each of them. This allows them to participate in standard graph resolution.</li> <li>Enhancement: When there are multiple empty <code>@Multibinds</code> errors, report them all at once.</li> <li>Enhancement: Avoid unnecessary <code>StringBuilder</code> allocations.</li> <li>Fix: Don\u2019t transform <code>@Provides</code> function\u2019s to be private if its visibility is already explicitly defined.</li> <li>Fix: Fix a comparator infinite loop vector.</li> <li>Fix: Fix <code>@ElementsIntoSet</code> multibinding contributions triggering a dependency cycle in some situations.</li> <li>Fix: Fix assertion error for generated multibinding name hint when using both @Multibinds and @ElementsIntoSet for the same multibinding.</li> <li>Fix: Fix contributed graph extensions not inheriting empty declared multibindings.</li> <li>Fix: Ensure we report the <code>@Multibinds</code> declaration location in errors if one is available.</li> <li>Fix: Dedupe overrides by all parameters not just value parameters.</li> <li>Fix: Dedupe overrides by signature rather than name when generating contributed graphs.</li> <li>Fix: Fix accidentally adding contributed graphs as child elements of parent graphs twice.</li> <li>Fix: Fix not deep copying <code>extensionReceiverParameter</code> when implementing fake overrides in contributed graphs.</li> <li>Fix: Report fully qualified qualifier renderings in diagnostics.</li> <li>Fix: Don\u2019t generate provider fields for multibinding elements unnecessarily.</li> <li>When debug logging + reports dir is enabled, output a <code>logTrace.txt</code> to the reports dir for tracing data.</li> <li>Update to Kotlin <code>2.1.21</code>.</li> </ul> <p>Special thanks to @asapha, @gabrielittner, @jzbrooks, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>2025-05-05</p> <ul> <li>New: Add support for <code>@ContributesGraphExtension</code>! See the docs for more info.</li> <li>New: Add a <code>asContribution()</code> compiler intrinsic to upcast graphs to expected contribution types. For example: <code>val contributedInterface = appGraph.asContribution&lt;ContributedInterface&gt;()</code>. This is validated at compile-time.</li> <li>New: Automatically transform <code>@Provides</code> functions to be <code>private</code>. This is enabled by defaults and supersedes the <code>publicProviderSeverity</code> when enabled, and can be disabled via the Gradle extension or <code>transform-providers-to-private</code> compiler option. Note that properties and providers with any annotations with <code>KClass</code> arguments are not supported yet pending upstream kotlinc changes.</li> <li>Enhancement: Rewrite the internal <code>BindingGraph</code> implementation to be more performant, accurate, and testable.</li> <li>Enhancement: Add diagnostic to check that graph factories don\u2019t provide their target graphs as parameters.</li> <li>Enhancement: Add diagnostic to check that a primary scope is defined if any additionalScopes are also defined on a graph annotation.</li> <li>Enhancement: Add diagnostic to validate that contributed types do not have narrower visibility that aggregating graphs. i.e. detect if you accidentally try to contribute an <code>internal</code> type to a <code>public</code> graph.</li> <li>Enhancement: Optimize supertype lookups when building binding classes by avoiding previously visited classes.</li> <li>Enhancement: Don\u2019t generate hints for contributed types with non-public API visibility.</li> <li>Enhancement: When reporting duplicate binding errors where one of the bindings is contributed, report the contributing class in the error message.</li> <li>Enhancement: When reporting scope incompatibility, check any extended parents match the scope and suggest a workaround in the error diagnostic.</li> <li>Enhancement: Allow AssistedFactory methods to be protected.</li> <li>Fix: Fix incremental compilation when a parent graph or supertype modifies/removes a provider.</li> <li>Fix: Fix rank processing error when the outranked binding is contributed using Metro\u2019s ContributesBinding annotation.</li> <li>Fix: Fix <code>@Provides</code> graph parameters not getting passed on to extended child graphs.</li> <li>Fix: Fix qualifiers on bindings not getting seen by extended child graphs.</li> <li>Fix: Fix qualifiers getting ignored on accessors from <code>@Includes</code> dependencies.</li> <li>Fix: Fix transitive scoped dependencies not always getting initialized first in graph provider fields.</li> <li>Fix: Fix injected <code>lateinit var</code> properties being treated as if they have default values.</li> <li>Fix: Alias bindings not always having their backing type visited during graph validation.</li> <li>Fix: Fix race condition in generating parent graphs first even if child graph is encountered first in processing.</li> <li>Fix: Fallback <code>AssistedInjectChecker</code> error report to the declaration source.</li> <li>Fix: Fix missing parent supertype bindings in graph extensions.</li> <li>Change: <code>InstanceFactory</code> is no longer a value class. This wasn\u2019t going to offer much value in practice.</li> <li>Change: Change debug reports dir to be per-compilation rather than per-platform.</li> </ul> <p>Special thanks to @gabrielittner, @kevinguitar, @JoelWilcox, and @japplin for contributing to this release!</p>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>2025-04-21</p> <ul> <li>New: Nullable bindings are now allowed! See the nullability docs for more info.</li> <li>Enhancement: Add diagnostics for multibindings with star projections.</li> <li>Enhancement: Add diagnostic for map multibindings with nullable keys.</li> <li>Fix: Ensure assisted factories\u2019 target bindings\u2019 parameters are processed in MetroGraph creation. Previously, these weren\u2019t processed and could result in scoped bindings not being cached.</li> <li>Fix: Fix duplicate field accessors generated for graph supertypes.</li> <li>Add compose navigation sample.</li> </ul> <p>Special thanks to @bnorm and @yschimke for contributing to this release!</p>"},{"location":"changelog/#013","title":"0.1.3","text":"<p>2025-04-18</p> <ul> <li>Change: Multibindings may not be empty by default. To allow an empty multibinding, <code>@Multibinds(allowEmpty = true)</code> must be explicitly declared now.</li> <li>New: Write graph metadata to reports (if enabled).</li> <li>New: Support configuring debug and reports globally via <code>metro.debug</code> and <code>metro.reportsDestination</code> Gradle properties (respectively).</li> <li>Enhancement: Change how aggregation hints are generated to improve incremental compilation. Externally contributed hints are now looked up lazily per-scope instead of all at once.</li> <li>Enhancement: Optimize empty map multibindings to reuse a singleton instance.</li> <li>Enhancement: Report error diagnostic if Dagger\u2019s <code>@Reusable</code> is used on a provider or injected class.</li> <li>Enhancement: Tweak diagnostic error strings for members so that IDE terminals auto-link them better. i.e., instead of printing <code>example.AppGraph.provideString</code>, Metro will print <code>example.AppGraph#provideString</code> instead.</li> <li>Enhancement: Support repeatable @ContributesBinding annotations with different scopes.</li> <li>Fix: Fix incremental compilation when <code>@Includes</code>-annotated graph parameters change accessor signatures.</li> <li>Fix: Don\u2019t allow graph extensions to use the same scope as any extended ancestor graphs.</li> <li>Fix: Don\u2019t allow multiple ancestor graphs of graph extensions to use the same scope.</li> <li>Fix: Handle scenarios where the compose-compiler plugin runs before Metro\u2019s when generating wrapper classes for top-level <code>@Composable</code> functions.</li> <li>Fix: Fix an edge case in graph extensions where child graphs would miss a provided scoped binding in a parent graph that was also exposed as an accessor.</li> <li>Fix: Fix Dagger interop issue when calling Javax/Jakarta/Dagger providers from Metro factories.</li> <li>Fix: Fix Dagger interop issue when calling <code>dagger.Lazy</code> from Metro factories.</li> <li>Fix: Preserve the original <code>Provider</code> or <code>Lazy</code> type used in injected types when generating factory creators.</li> <li>Temporarily disable hint generation in WASM targets to avoid file count mismatches until KT-75865.</li> <li>Add an Android sample: https://github.com/ZacSweers/metro/tree/main/samples/android-app</li> <li>Add a multiplatform Circuit sample: https://github.com/ZacSweers/metro/tree/main/samples/circuit-app</li> <li>Add samples docs: https://zacsweers.github.io/metro/samples</li> <li>Add FAQ docs: https://zacsweers.github.io/metro/faq</li> </ul> <p>Special thanks to @JoelWilcox, @bnorm, and @japplin for contributing to this release!</p>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>2025-04-08</p> <ul> <li>Enhancement: Implement <code>createGraph</code> and <code>createGraphFactory</code> FIR checkers for better error diagnostics on erroneous type arguments.</li> <li>Enhancement: Add <code>ContributesBinding.rank</code> interop support with Anvil.</li> <li>Enhancement: Check Kotlin version compatibility. Use the <code>metro.version.check=false</code> Gradle property to disable these warnings if you\u2019re feeling adventurous.</li> <li>Fix: Fix class-private qualifiers on multibinding contributions in other modules not being recognized in downstream graphs.</li> <li>Fix: Fix member injectors not getting properly visited in graph validation.</li> <li>Fix: Fix a bug where <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> multibindings weren\u2019t always unwrapped correctly.</li> <li>Fix: Fix <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> type keys not correctly interpreting the underlying type key as <code>Map&lt;Key, Value&gt;</code>.</li> <li>Change: Change <code>InstanceFactory</code> to a value class.</li> <li>Change: Make <code>providerOf</code> use <code>InstanceFactory</code> under the hood.</li> </ul> <p>Special thanks to @JoelWilcox, @bnorm, @japplin, @kevinguitar, and @erawhctim for contributing to this release!</p>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>2025-04-03</p> <p>Initial release!</p> <p>See the announcement blog post: https://www.zacsweers.dev/introducing-metro/</p>"},{"location":"code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> <li>Respecting maintainers\u2019 time and not asking for ETAs</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others\u2019 private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code-of-conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pandanomic@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code-of-conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code-of-conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code-of-conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code-of-conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code-of-conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla\u2019s code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"compatibility/","title":"Kotlin Compatibility","text":"<p>The Kotlin compiler plugin API is not a stable API, so not every version of Metro will work with every version of the Kotlin compiler.</p> <p>Starting with Metro <code>0.6.9</code>, Metro tries to support forward compatibility on a best-effort basis. Some releases may introduce prohibitively difficult breaking changes that require companion release, so check Metro\u2019s open PRs for one targeting that Kotlin version for details.</p> Kotlin version Metro versions (inclusive) 2.3.0 0.6.9 - 2.2.20 0.6.6 - 2.2.10 0.4.0 - 0.6.5 2.2.0 0.4.0 - 0.6.5 2.1.21 0.3.1 - 0.3.8 2.1.20 0.1.2 - 0.3.0"},{"location":"contributing/","title":"Contributing to Metro","text":"<p>Metro welcomes contributions! Small contributions like documentation improvements, small obvious fixes, etc are always good and don\u2019t need prior discussion. I liberally leave TODO comments in code that don\u2019t quite meet the standard of an issue but are still things worth improving :). For larger functionality changes or features, please raise a discussion or issue first before starting work.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Local development with Metro is fairly straightforward. You should be able to clone the repo and open it in IntelliJ as a standard Gradle project.</p> <p>Note: This project uses a specific JDK (see the <code>jdk</code> version in <code>libs.versions.toml</code>). If you don\u2019t have that JDK installed, you can likely change it to whatever JDK suits your needs as long as it\u2019s compatible with the <code>jvmTarget</code> version defined in <code>libs.versions.toml</code>.</p> <p>There are a few primary subprojects to consider.</p> <ol> <li><code>:compiler</code> \u2014 Metro\u2019s compiler plugin implementation lives. This includes compiler-supported interop features too.</li> <li><code>:compiler-tests</code> \u2014 Compiler tests using JetBrains\u2019 official compiler testing infrastructure.</li> <li><code>:gradle-plugin</code> \u2014 Metro\u2019s companion Gradle plugin implementation. Mostly just an extension API and compiler plugin wiring with KGP.<ul> <li>This is also where incremental compilation integration tests live!</li> </ul> </li> <li><code>:runtime</code> \u2014 Metro\u2019s core multiplatform runtime API. This is mostly annotations plus some small runtime APIs.</li> <li><code>:interop-dagger</code> \u2014 An ancillary set of JVM-only Dagger-specific runtime APIs for interop with Dagger.</li> <li><code>samples/</code> \u2014 A separate gradle project that contains several sample projects. This includes the core artifacts as an included build. You can add this project in IntelliJ as another Gradle project to support developing both. There are also some integration tests in here.</li> <li><code>:integration-tests</code> \u2014 self-explanatory.</li> <li><code>:multi-module-test</code> \u2014 A multi-module integration test.</li> </ol> <p>There is a useful <code>./metrow</code> helper CLI that can perform a few common commands across the various subprojects.</p> <p>Tip</p> <p>Before submitting a PR, it is useful to run <code>regen</code> and <code>check</code>.</p> <ul> <li><code>./metrow format</code> \u2014 Runs all code formatters.</li> <li><code>./metrow regen</code> \u2014 Regenerates <code>.api</code> files and runs all code formatters.</li> <li><code>./metrow check</code> \u2014 Runs checks across all included Gradle projects (including samples and the Gradle plugin).</li> <li><code>./metrow publish --local --version x.y.z</code> \u2014 Publishes to maven local with the specified <code>x.y.z</code> version (replace this with whatever you want, like <code>1.0.0-LOCAL01</code>.)</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Tests are spread across a few areas.</p> <ul> <li><code>compiler-tests/</code> \u2014 New compiler tests using JetBrains\u2019 official compiler testing infrastructure. If possible, write new compiler tests in here! See this PR for more details on how they work.</li> <li><code>compiler/src/test/</code> \u2014 Core compiler tests. These should be focused primarily on error testing but can also perform limited functional testing. Note that while many tests are here, new tests should ideally use <code>compiler-tests</code>.</li> <li><code>gradle-plugin/src/functionalTest</code> \u2014 Integration gradle tests, primarily focused on exercising different incremental compilation scenarios.</li> <li><code>samples/</code> \u2014 Some samples have tests! This is useful to assert that these samples work as expected.<ul> <li><code>integration-tests/</code> \u2014 Integration tests. These should only be functional in nature and not test error cases (error cases won\u2019t compile!). Note that new integration tests should usually be written in <code>compiler-tests</code>. Some scenarios, such as multi-compilation tests across Gradle, may make more sense to write here.</li> </ul> </li> </ul> <p>To publish to a local maven repo, run this:</p> <pre><code>./metrow publish --local --version 1.0.0-LOCAL01 # whatever version you want\n</code></pre>"},{"location":"contributing/#compiler-plugin-design","title":"Compiler Plugin Design","text":"<p>The compiler plugin is implemented primarily in two parts.</p>"},{"location":"contributing/#1-fir","title":"1. FIR","text":"<p>The FIR frontend generates declarations, generates supertypes, and performs diagnostic checks for Metro types. Any class or callable declaration generated by Metro should be done here as this is required for them to be visible in Kotlin metadata later.</p> <p>Generators go in the <code>dev.zacsweers.metro.compiler.fir.generators</code> package.</p> <p>Checkers go in the <code>dev.zacsweers.metro.compiler.fir.checkers</code> package.</p> <p>New checker contributions are generally welcome. New generators almost always warrant prior discussion first!</p>"},{"location":"contributing/#2-ir","title":"2. IR","text":"<p>The IR backend performs two main functions:</p> <ol> <li>Implements declarations generated in FIR. This includes generated graphs, factories, member injectors, etc.</li> <li>Performs dependency graph construction and validation. This is primarily spread across <code>DependencyGraphTransformer</code>, <code>BindingGraph</code>, and <code>Binding</code>.</li> </ol> <p>Most of this is implemented as transformers in the <code>dev.zacsweers.metro.compiler.ir.transformers</code> package. Note that all transformers are run from the <code>DependencyGraphTransformer</code>, which is the only true <code>IrTransformer</code> of the bunch and just delegates out to the other transformers as needed.</p> <p>Aggregation hint properties are also implemented in IR as a workaround to support incremental compilation. See <code>ContributionHintIrTransformer</code> for more details.</p>"},{"location":"contributing/#typekey-and-contextualtypekey","title":"<code>TypeKey</code> and <code>ContextualTypeKey</code>","text":"<p><code>TypeKey</code> and <code>ContextualTypeKey</code> (and their FIR counterparts) deserve special mention. Most of the compiler\u2019s dependency graph analysis thinks in terms of these two types.</p> <p>A <code>TypeKey</code> is the canonical representations of specific binding, composed of a type and optional qualifier.</p> <p>A <code>ContextualTypeKey</code> can be thought up as a <code>TypeKey</code> with context of how it\u2019s used. This is useful for a few reasons:</p> <ul> <li>Allows Metro\u2019s compiler plugin to generate code accordingly for how the given <code>TypeKey</code> is used at runtime, for example wrapping in <code>Provider</code>, <code>Lazy</code>, etc.</li> <li>Allows dependency graph resolution to understand if the type is deferrable, which is useful in breaking dependency cycles.</li> </ul>"},{"location":"contributing/#misc-notes","title":"Misc Notes","text":"<ul> <li>IR code should cache eagerly.</li> <li>FIR code should cache carefully (remember it runs in the IDE!).</li> <li>FIR code should be defensive. It may run continuously in the IDE and not all information may be available to the compiler as the user has written it. If you\u2019ve ever written a custom lint check, your methodology should be similar.</li> <li>Inversely, IR code should be offensive. Assert expectations with clear error messages, report errors with useful error messages.</li> <li>FIR-generated declaration should use descriptive keys to declarations that can be referenced later in FIR and IR (as <code>origins</code>). See <code>Keys.kt</code> for FIR declarations and <code>Origins.kt</code> for their IR analogs.</li> </ul>"},{"location":"debugging/","title":"Debugging","text":"<p>One major downside to generating IR directly is that developers cannot step into generated source code with the debugger. This is an accepted trade-off with Metro (or any other compiler plugin).</p> <p>Metro does offer a <code>debug</code> option in its plugin options/Gradle extension that will print verbose Kotlin pseudocode for all generated IR classes. This can be further tuned to print just certain classes.</p> <pre><code>metro {\n  debug.set(true)\n}\n</code></pre> <p>In the future, we could possibly explore including information in IR to synthesize call stack information similar to coroutines, but will save that for if/when it\u2019s asked for.</p>"},{"location":"debugging/#reports","title":"Reports","text":"<p>Similar to Compose, Metro supports a <code>reportsDestination</code> property in its Gradle DSL and can output various graph reports to this destination if specified. This is very much a WIP, feedback is welcome!</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre>"},{"location":"dependency-graphs/","title":"Dependency Graphs","text":"<p>The primary entry points in Metro are dependency graphs. These are interfaces annotated with <code>@DependencyGraph</code> and created with <code>@DependencyGraph.Factory</code> interfaces. Graphs expose types from the object graph via accessor properties or functions.</p> <p>Tip</p> <p>These are synonymous with components and <code>@Component</code>/<code>@Component.Factory</code> in Dagger and kotlin-inject.</p> <p>Tip</p> <p>\u201cAccessors\u201d in Metro are synonymous with Dagger\u2019s provision methods.</p> <p>Accessors and member injections act as roots, from which the dependency graph is resolved. Dependencies can be provided via conventional <code>@Provides</code> functions in graphs or their supertypes, constructor-injected classes, or accessed from graph dependencies.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides\n  fun provideMessage(): String = \"Hello, world!\"\n}\n</code></pre> <p>Note the <code>@Provides</code> function must define an explicit return type.</p> <p>Simple graphs like this can be created via the <code>createGraph()</code> intrinsic.</p> <pre><code>val graph = createGraph&lt;AppGraph&gt;()\n</code></pre> <p>Graphs are relatively cheap and should be used freely.</p>"},{"location":"dependency-graphs/#inputs","title":"Inputs","text":"<p>Runtime inputs can be provided via a <code>@DependencyGraph.Factory</code> interface that returns the target graph. These parameters must be annotated with either <code>@Provides</code> or <code>@Includes</code>.</p>"},{"location":"dependency-graphs/#provides","title":"Provides","text":"<p>The simplest input is an instance parameter annotated with <code>@Provides</code>. This provides this instance as an available binding on the graph.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n</code></pre> <p>Provided parameters may be any type.</p> <p>Tip</p> <p>This is analogous to Dagger\u2019s <code>@BindsInstance</code>.</p>"},{"location":"dependency-graphs/#includes","title":"Includes","text":"<p><code>@Includes</code>-annotated parameters are treated as containers of available bindings. Metro will treat accessors of these types as usable dependencies.</p> <p>They are commonly other graph types whose\u2019 dependencies you want to consume via explicit API.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageGraph: MessageGraph): AppGraph\n  }\n\n  @DependencyGraph interface MessageGraph {\n    val message: String\n\n    @Provides fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre> <p><code>@Includes</code> instance dependencies do not need to be other graphs though! They can be any regular class type. They cannot be enums or annotation classes.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageProvider: MessageProvider): AppGraph\n  }\n\n  interface MessageProvider {\n    val message: String\n  }\n}\n</code></pre> <p>Warning</p> <p>Includes parameters cannot be injected from the graph.</p> <p>Binding Containers are a special type of <code>@Includes</code> type, see more in its section below.</p>"},{"location":"dependency-graphs/#creating-factories","title":"Creating factories","text":"<p>Graph factories can be created with the <code>createGraphFactory()</code> intrinsic.</p> <pre><code>val messageGraph =\n  createGraphFactory&lt;AppGraph.Factory&gt;()\n    .create(\"Hello, world!\")\n</code></pre>"},{"location":"dependency-graphs/#scoping","title":"Scoping","text":"<p>See Scopes for more details on scopes!</p> <p>Graphs may declare a <code>scope</code> (and optionally <code>additionalScopes</code> if there are more). Each of these declared scopes act as an implicit <code>@SingleIn</code> representation of that scope for aggregation.</p> <p>For example: <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre></p> <p>Is functionally equivalent to writing the below.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#graph-extensions","title":"Graph Extensions","text":"<p>Dependency graphs can be extended via graph extensions. As the name implies, graph extensions extend a parent graph they are declared for and contain a superset of bindings that includes both the parent graph(s) as well as their own. These are similar in functionality to Dagger\u2019s Subcomponents.</p> <p>Graph extensions must be either an interface or an abstract class and are annotated with <code>@GraphExtension</code>. They are created via <code>@GraphExtension.Factory</code> types.</p> <p>Metro\u2019s compiler plugin will build, validate, and implement this graph at compile-time when the parent graph is generated. This means that graph extensions are not available until the parent graph is generated.</p> <p>Graph extensions can be chained and implicitly inherit their parents\u2019 scopes.</p>"},{"location":"dependency-graphs/#creating-graph-extensions","title":"Creating Graph Extensions","text":"<p>You cannot create a graph extension independent of its parent graph, you may only access it via accessor on the parent graph. You can declare this in multiple ways:</p> <ul> <li>Declare an accessor on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraph: LoggedInGraph\n}\n</code></pre> <ul> <li>(If the extension has a creator) declare the creator on the parent graph directly.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val loggedInGraphFactory: LoggedInGraph.Factory\n}\n</code></pre> <ul> <li>(If the extension has a creator) make the parent graph implement the creator.</li> </ul> <pre><code>@GraphExtension\ninterface LoggedInGraph {\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph\ninterface AppGraph : LoggedInGraph.Factory\n</code></pre> <ul> <li>Contribute the factory to the parent graph via @ContributesTo. More on this below.</li> </ul> <pre><code>@GraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n  @ContributesTo(AppScope::class)\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#scoping_1","title":"Scoping","text":"<p>See Scopes for more details on scopes!</p> <p>Like DependencyGraph, graph extensions may declare a <code>scope</code> (and optionally <code>additionalScopes</code> if there are more). Each of these declared scopes act as an implicit <code>@SingleIn</code> representation of that scope. For example:</p> <pre><code>@GraphExtension(AppScope::class)\ninterface AppGraph\n</code></pre> <p>Is functionally equivalent to writing the below.</p> <pre><code>@SingleIn(AppScope::class)\n@GraphExtension(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#providers","title":"Providers","text":"<p>Like DependencyGraph, graph extensions may declare providers via <code>@Provides</code> and <code>@Binds</code> to provide dependencies into the graph.</p> <p>Creators can provide instance dependencies and other graphs as dependencies.</p> <pre><code>@GraphExtension\ninterface AppGraph {\n  val httpClient: HttpClient\n\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n</code></pre>"},{"location":"dependency-graphs/#creators","title":"Creators","text":"<p>See DependencyGraph\u2019s section on creators.</p>"},{"location":"dependency-graphs/#aggregation","title":"Aggregation","text":"<p>See DependencyGraph\u2019s section on aggregation.</p>"},{"location":"dependency-graphs/#contributed-graph-extensions","title":"Contributed Graph Extensions","text":"<p>Graph extensions may be contributed to a parent graph and its contribution merging will be deferred until the parent graph is generated.</p>"},{"location":"dependency-graphs/#the-problem","title":"The Problem","text":"<p>Imagine this module dependency tree:</p> <pre><code>        :app\n      /     \\\n     v       v\n  :login   :user-data\n</code></pre> <p><code>:app</code> defines the main dependency graph with <code>@DependencyGraph</code>. The <code>:login</code> module defines a graph extension for authenticated user flows, and <code>:user-data</code> provides some core functionality like <code>UserRepository</code>.</p> <p>If <code>:login</code> defines its own graph directly with <code>@DependencyGraph</code>, it won\u2019t see contributions from <code>:user-data</code> unless <code>:login</code> depends on it directly.</p>"},{"location":"dependency-graphs/#the-solution","title":"The Solution","text":"<p>Instead, <code>:login</code> can use <code>@GraphExtension(LoggedInScope::class)</code> + <code>@ContributesTo</code> on its associated factory to say: \u201cI want to contribute a new graph extension to a future <code>AppScope</code> parent graph.\u201d</p> <p>The graph extension will then be generated in <code>:app</code>, which already depends on both <code>:login</code> and <code>:user-data</code>. Now <code>UserRepository</code> can be injected in <code>LoggedInGraph</code>.</p> <pre><code>@GraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n\n  val userRepository: UserRepository\n\n  @ContributesTo(AppScope::class)\n  @GraphExtension.Factory\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n</code></pre> <p>In the <code>:app</code> module:</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre> <p>The generated code will modify <code>AppGraph</code> to implement <code>LoggedInGraph.Factory</code> and implement <code>createLoggedInGraph()</code> using a generated final <code>LoggedInGraphImpl</code> class that includes all contributed bindings, including <code>UserRepository</code> from <code>:user-data</code>.</p> <pre><code>interface AppGraph\n// modifications generated during compile-time\n  interface AppGraph : LoggedInGraph.Factory {\n\n  override fun createLoggedInGraph(): LoggedInGraph {\n    return LoggedInGraphImpl(this)\n  }\n\n  // Generated in IR\n  class $$MetroGraph : AppGraph {\n    class LoggedInGraphImpl(appGraph: $$MetroGraph) : LoggedInGraph {\n      // ...\n    }\n  }\n}\n</code></pre> <p>Finally, you can obtain a <code>LoggedInGraph</code> instance from <code>AppGraph</code> since it now implements <code>LoggedInGraph.Factory</code>:</p> <pre><code>// Using the asContribution() intrinsic\nval loggedInGraph = appGraph.asContribution&lt;LoggedInGraph.Factory&gt;().createLoggedInGraph()\n\n// Or if you have IDE support enabled\nval loggedInGraph = appGraph.createLoggedInGraph()\n</code></pre>"},{"location":"dependency-graphs/#graph-arguments","title":"Graph arguments","text":"<p>You can pass arguments to the graph via the factory:</p> <pre><code>@ContributesTo(AppScope::class)\n@GraphExtension.Factory\ninterface Factory {\n  fun create(@Provides userId: String): LoggedInGraph\n}\n</code></pre> <p>This maps to:</p> <pre><code>// Generated in IR\n@DependencyGraph(LoggedInScope::class)\nclass LoggedInGraphImpl(\n  parent: AppGraph,\n  @Provides userId: String\n): LoggedInGraph {\n  // ...\n}\n</code></pre> <p>In <code>AppGraph</code>, the generated factory method looks like:</p> <pre><code>// Generated in IR\noverride fun create(userId: String): LoggedInGraph {\n  return LoggedInGraphImpl(this, userId)\n}\n</code></pre> <p>Warning</p> <p>Abstract factory classes cannot be used as graph contributions.</p> <p>Contributed graphs may also be chained.</p>"},{"location":"dependency-graphs/#binding-containers","title":"Binding Containers","text":"<p>Binding containers are classes, objects, or interfaces annotated with <code>@BindingContainer</code> that contain binding declarations (<code>@Provides</code> or <code>@Binds</code>) but are not themselves complete dependency graphs. They\u2019re analogous to Dagger\u2019s <code>@Module</code> annotation and can be used in cases where defining bindings in an (extended) interface is unwieldy or not helpful.</p> <p>Unlike graphs and other <code>@Includes</code> types, their public accessors are not read. Only <code>@Binds</code> and <code>@Provides</code> declarations are read.</p> <p>Tip</p> <p>Binding containers can be seen as partial graphs and are intended to be reusable, composable units that are included in a complete graph.</p>"},{"location":"dependency-graphs/#including-via-includes-parameters","title":"Including via <code>@Includes</code> Parameters","text":"<p>The most flexible way to include binding containers is via <code>@Includes</code>-annotated parameters on graph factories.</p> <pre><code>@BindingContainer\nclass NetworkBindings(private val baseUrl: String) {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(baseUrl)\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val httpClient: HttpClient\n\n  @DependencyGraph.Factory\n  interface Factory {\n    fun create(@Includes networkBindings: NetworkBindings): AppGraph\n  }\n}\n</code></pre> <p>This allows you to bring any instance to the graph with its own internal logic.</p>"},{"location":"dependency-graphs/#including-via-dependencygraphbindingcontainers","title":"Including via <code>@DependencyGraph.bindingContainers</code>","text":"<p>For simple binding containers, you can declare them directly in the graph annotation:</p> <pre><code>@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>This method works for:</p> <ul> <li><code>object</code> classes</li> <li><code>interface</code> or <code>abstract class</code> types with only <code>@Binds</code> providers or companion object <code>@Provides</code> providers</li> <li>Simple classes with a public, no-arg constructor</li> </ul>"},{"location":"dependency-graphs/#chaining-binding-containers","title":"Chaining Binding Containers","text":"<p>Binding containers can include other binding containers using the <code>includes</code> parameter:</p> <pre><code>@BindingContainer\nobject CacheBindings {\n  @Provides fun provideHttpCache(): Cache = Cache()\n}\n\n@BindingContainer(includes = [CacheBindings::class])\nobject NetworkBindings {\n  @Provides fun provideHttpClient(cache: Cache): HttpClient = HttpClient(cache)\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>The transitive closure of all included binding containers will be included in the final consuming graph.</p>"},{"location":"dependency-graphs/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers can be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>They can also replace other contributed binding containers:</p> <pre><code>// In a test variant\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre> <p>Graphs may exclude contributed containers:</p> <pre><code>@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"dependency-graphs/#notes","title":"Notes","text":"<ul> <li>Companion objects, annotation classes, and enum classes/entries cannot be annotated with <code>@BindingContainer</code>.</li> <li>Provides within a binding container\u2019s companion object are automatically included.</li> <li>Enclosing classes of <code>@Binds</code> or <code>@Provides</code> providers don\u2019t need to be annotated with <code>@BindingContainer</code> for Metro to process them - the annotation is primarily for reference to <code>@DependencyGraph.Factory</code> and the ability to use <code>includes</code>.</li> <li>Binding containers may also be contributed.</li> <li>See #172 for more details.</li> </ul>"},{"location":"dependency-graphs/#dynamic-graphs","title":"Dynamic Graphs","text":"<p>Dynamic graphs are a powerful feature of the Metro compiler that allow for dynamically replacing bindings in a given graph. To use them, you can pass in a vararg set of binding containers to the <code>createDynamicGraph()</code> and <code>createDynamicGraphFactory()</code> intrinsics.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(): String = \"real\"\n}\n\nclass AppTest {\n  val testGraph = createDynamicGraph&lt;AppGraph&gt;(FakeBindings)\n\n  @Test\n  fun test() {\n    assertEquals(\"fake\", testGraph.message)\n  }\n\n  @BindingContainer\n  object FakeBindings {\n    @Provides fun provideMessage(): String = \"fake\"\n  }\n}\n</code></pre> <p>The compiler will dynamically generate a hidden graph impl within the enclosing class or file that is unique to the combination of input [containers] and target type [T].</p> <p>Constraints</p> <ul> <li>All containers must be instances (or objects) of binding containers.</li> <li>It\u2019s an error to pass no containers.</li> <li>All containers must be non-local, canonical classes. i.e., they must be something with a name!</li> <li>This overload may be called in a member function body, top-level function body, or property   initializer.</li> <li>The target [T] graph must be annotated with <code>@DependencyGraph</code> and must be a   valid graph on its own.</li> </ul> Implementation Notes <ul> <li>The bulk of this implementation is in <code>IrDynamicGraphGenerator</code>.</li> <li>The generated graph impl is a private nested (static) class of the enclosing class or file.</li> <li>This doesn\u2019t swap bindings in a real graph or use a real graph at all, instead tracking available dynamic bindings and preferring them when constructing a graph in <code>BindingGraphGenerator</code>.</li> </ul>"},{"location":"dependency-graphs/#general-implementation-notes","title":"General Implementation Notes","text":"<p>Dependency graph code gen is designed to largely match how Dagger components are generated.</p> <ul> <li>Internal graph validation uses Tarjan\u2019s algorithm + topological sort implementation.</li> <li>This runs in O(V+E) time</li> <li>The returned ordered list of bindings can be used to determine provider field generation order.</li> <li>Any binding whose order depends on one later in the returned order implicitly requires use of <code>DelegateFactory</code>.</li> <li>Dependencies are traversed from public accessors and <code>inject()</code> functions.</li> <li>Metro generates Provider Factory classes for each provider. These should be generated at the same time that the provider is compiled so that their factory classes. This is for two primary purposes:<ul> <li>They can be reused to avoid code duplication</li> <li>Metro can copy default values for provider values over to the generated factory to support optional dependencies. Since default values may refer to private references, we must generate these factories as nested classes.</li> </ul> </li> <li>Metro generates a graph impl class that holds all aggregated bindings and manages scoping.</li> <li>Scoped bindings are stored in provider fields backed by <code>DoubleCheck</code>.</li> <li>Reused unscoped providers instances are stored in reusable fields.</li> <li><code>@Provides</code> factory parameters are stored in a field backed by <code>InstanceFactory</code>.</li> <li>Multibindings create new collection instances every time.</li> <li>Multibinding providers are not accessible as standalone bindings.</li> <li>Graph extensions are implemented via a combination of things<ul> <li>Custom <code>MetroMetadata</code> is generated and serialized into Kotlin\u2019s <code>Metadata</code> annotations.</li> <li>Extendable parent graphs opt-in to generating this metadata. They write information about their available provider and instance fields, binds callable IDs, parent graphs, and provides callable IDs.</li> <li>Extendable parent graphs generate <code>_metroAccessor</code>-suffixed <code>internal</code> functions that expose instance fields and provider fields.</li> <li>Child graphs read this metadata and look up the relevant callable symbols, then incorporating these when building its own binding graph.</li> </ul> </li> </ul>"},{"location":"differences/","title":"Differences from other DI frameworks","text":"DaggerKotlin-InjectAnvilkotlin-inject-anvil <ul> <li><code>@Binds</code> and <code>@Provides</code> declarations can be added directly within graphs and their supertypes.<ul> <li><code>@BindingContainer</code> is the Metro equivalent of a Dagger <code>@Module</code> but it should rarely be used.</li> <li><code>@BindingContainer</code> cannot declare graph extensions in the way <code>@Module</code> can declare subcomponents. Use contributed graph extensions.</li> </ul> </li> <li>There is no Producers support.</li> <li>There is no Hilt support, though some features are similar in the same way that Anvil\u2019s features are similar.</li> <li>There is no <code>@Reusable</code>.</li> <li>There is no <code>@BindsOptionalOf</code>. Instead, Metro supports default optional dependencies.</li> <li>Metro can inject private properties, functions, and constructors.</li> <li>There is no <code>@BindsInstance</code>. Use <code>@Provides</code> on <code>@DependencyGraph.Factory</code> function parameters instead</li> <li>Component dependencies must be annotated with <code>@Includes</code>.</li> <li>Metro does not process Java code.</li> <li><code>@Multibinds</code> declarations are implemented in Metro graphs to return the declared multibinding.</li> <li>Empty multibindings are an error by default in Metro. To allow a multibinding to be empty, it must be declared with <code>@Multibinds(allowEmpty = true)</code>.</li> <li>Metro graph classes may not directly extend other graph classes. You should use graph extensions instead in Metro.</li> <li>Dagger technically allows this, but only accessors and injectors cross these boundaries.</li> <li>Metro prohibits scopes on <code>@Binds</code> declarations. Either use <code>@Provides</code> or move the scope to the source class type.</li> </ul> <ul> <li>typealiases are not treated as implicit qualifiers.</li> <li>Dependency graph classes cannot have primary constructors, their parameters must be defined as <code>@Provides</code> or graph parameters on a <code>@DependencyGraph.Factory</code> function like Dagger.</li> <li>Higher order functions cannot be used. Instead, use <code>Provider</code> and declared <code>@AssistedFactory</code>-annotated types.</li> <li>No need for use-site targets for most annotations.</li> <li>No need for <code>@get:Provides Impl.bind: Type get() = this</code> to achieve type bindings. See the docs on <code>@Binds</code>.</li> <li>Metro can inject private properties and functions.</li> <li>Metro does not support detached graph extensions the way kotlin-inject does. Instead, use graph extensions.</li> <li>Metro does not process Java code.</li> <li>Metro does not support assisted parameters in <code>@Provides</code> functions.</li> <li>Metro map multibindings use static map keys rather than aggregating via <code>Pair</code> contributions. More details on why can be found here.</li> </ul> <ul> <li>There is no <code>rank</code> in Metro\u2019s <code>@Contributes*</code> annotations.<ul> <li>Note that if Anvil interop is enabled, its <code>rank</code> properties are supported in interop.</li> </ul> </li> <li>There is no <code>ignoreQualifier</code> in Metro\u2019s <code>@Contributes*</code> annotations.<ul> <li>Note that if Anvil interop is enabled, its <code>ignoreQualifier</code> properties are supported in interop.</li> </ul> </li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> </ul> <ul> <li>There is no need for <code>@CreateComponent</code> or <code>expect fun createComponent()</code> functions.</li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>This is a list of frequently asked questions about Metro. Consider also searching the issue tracker and discussions section of the Metro repo for anything not covered here!</p>"},{"location":"faq/#compiler-plugins-are-not-a-stable-api-is-metro-safe-to-use","title":"Compiler plugins are not a stable API, is Metro safe to use?","text":"<p>This is a fair question! Metro will often require new companion releases for each Kotlin release. This is a part of life when using compiler plugins. That said, Kotlin does extensive beta/RC cycles that Metro will test against and turn around new releases within a day or two barring any unexpected circumstances (or vacation!)</p> <p>The harder issue is going to be IDE support, as the Kotlin IDE plugin branches independently from regular Kotlin releases. Right now the answer is \u201cYMMV\u201d, but we\u2019re exploring a couple solutions for this to ensure better stability.</p>"},{"location":"faq/#will-metro-add-support-for-hilt-features-or-hilt-interop","title":"Will Metro add support for Hilt features or Hilt interop?","text":"<p>Metro is largely inspired by Dagger and Anvil, but not Hilt. Hilt works in different ways and has different goals. Hilt is largely focused around supporting android components and relies heavily on subcomponents to achieve this.</p> <p>Some features overlap but just work differently in Metro:</p> <ul> <li>Instead of <code>@UninstallModules</code> and <code>@TestInstallIn</code>, Metro graphs can exclude aggregations and contributed bindings can replace other bindings.</li> <li>Hilt has support for injecting <code>ViewModel</code>s, but this is entirely doable without Hilt as well by just creating a multibinding. See the android-app sample for an example.</li> <li>Hilt has support for aggregation with <code>@InstallIn</code>, Metro uses <code>@Contributes*</code> annotations.</li> </ul> <p>Some features are focused around injecting Android framework components. There are two arguably better solutions to this and one not-better solution.</p> <ol> <li>(Not better) Expose injector functions on a graph to do member injection directly from the graph.</li> <li>(Better) Constructor-inject these types using <code>AppComponentFactory</code>. This does require minSdk 28. When Hilt was first released in 2020, this was a relatively new API. However, 2020 was a long time ago! minSdk 28+ is much more common today, making this much more feasible of a solution.</li> <li>(Best) Use an app architecture that better abstracts away the surrounding Android framework components, making them solely entry points.</li> </ol> <p>The rest of Hilt\u2019s features focus on gluing these pieces together and also supporting Java (which Metro doesn\u2019t support).</p>"},{"location":"faq/#why-doesnt-metro-support-reusable","title":"Why doesn\u2019t Metro support <code>@Reusable</code>?","text":"<p>Some technical context</p> <p><code>@Reusable</code> works almost identically in code gen as scoped types, it just uses <code>SingleCheck</code> instead of <code>DoubleCheck</code>. It\u2019s basically like using <code>lazy(NONE)</code> instead of <code>lazy(SYNCHRONIZED)</code>.</p> <p>A few different reasons Metro doesn\u2019t have it</p> <ul> <li>I think it risks being like <code>@Stable</code> in compose where people chase it for perceived performance benefits that they have not profiled or would not actualize if they did. Basically it becomes a premature optimization vector<ul> <li>Ron Shapiro (the author of it) even said you shouldn\u2019t use it or scoping in general [for performance reasons] unless you\u2019ve measured it: https://medium.com/@shapiro.rd/reusable-has-many-of-the-same-costs-as-singleton-c20b5d1ef308</li> </ul> </li> <li>Most people don\u2019t really know when to use it. It doesn\u2019t really strike a balance so much as blurs the line for limited value (see: the first bullet).</li> <li>It invites people to make unclear assumptions. It\u2019s pretty simple to assume something stateful is always a new instance or always the same scoped instance. It is harder to envision scenarios where you have stateful types where you don\u2019t care about knowing if it\u2019s shared or not. You could say this should only be for stateless types then, but then you\u2019re deciding\u2026<ul> <li>Do you want to limit instances? Just scope it</li> <li>Do you not care about limiting instances? Don\u2019t scope it</li> </ul> </li> <li>What\u2019s the expected behavior if you have a <code>@Reusable</code> type <code>Thing</code> and then request a <code>Lazy&lt;Thing&gt;</code> elsewhere? Currently, Metro <code>DoubleCheck.lazy(...)</code>\u2019s whatever binding provides it at the injection site, which would then defeat this. To undo that, Metro would need to introduce some means of indicating \u201cwhat kind\u201d of <code>Lazy</code> is needed, which just complicates things for the developer.</li> </ul>"},{"location":"faq/#why-doesnt-metro-support-kotlin-inject-style-intomap-bindings","title":"Why doesn\u2019t Metro support kotlin-inject-style <code>@IntoMap</code> bindings?","text":"<p>Some technical context</p> <p>kotlin-inject allows you to provide key/value pairs from an <code>@IntoMap</code> function rather than use <code>@MapKey</code> annotations.</p> <p>This allows some dynamism with keys but has some downsides. A few different reasons Metro doesn\u2019t use this approach</p> <ul> <li>Duplicate key checking becomes a runtime failure rather than compile-time.</li> <li>It breaks the ability to expose <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> unless you start manually managing <code>Provider</code> types yourself.</li> <li>You allocate and throw away a <code>Pair</code> instance each time it\u2019s called.</li> </ul>"},{"location":"faq/#how-can-i-replicate-hilts-hiltandroidtest","title":"How can I replicate Hilt\u2019s <code>@HiltAndroidTest</code>?","text":"<p>Some technical context</p> <p>Hilt\u2019s <code>@HiltAndroidTest</code> and associated rule allow tests to \u201creplace\u201d bindings in a target graph even if it\u2019s compiled in another project.</p> <p>Metro supports dynamic replacements via a similar feature called dynamic graphs.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#familiar-semantics","title":"Familiar semantics","text":"<p>Metro builds on top of established patterns from existing DI frameworks with familiar semantics like constructor injection, providers, multibindings, scopes, assisted injection, and intrinsics like Provider/Lazy.</p>"},{"location":"features/#compile-time-validation","title":"Compile-time validation","text":"<p>Like Dagger and KI, Metro validates your dependency graph at compile-time.</p>"},{"location":"features/#compile-time-firir-code-gen","title":"Compile-time FIR+IR code gen","text":"<p>Metro is implemented entirely as a Kotlin compiler plugin, primarily using FIR for error reporting and both FIR and IR for code gen. This affords significant build performance and wins compared to Dagger and KAPT/KSP in two ways:</p> <ul> <li>It avoids extra Kotlin compiler (frontend) invocations to analyze sources and generate new sources.</li> <li>It generates new code to FIR/IR directly, allowing it to be lowered directly into target platforms</li> </ul> <p>FIR/IR generation allows Metro to generate code directly into existing classes, which in turn allows it to do certain things that source-generation cannot. This includes:</p> <ul> <li>Private <code>@Provides</code> declarations.</li> <li>Injection of private member properties and functions.</li> <li>Copying + reuse of default value expressions for optional dependencies, even if they reference private APIs within the source class.</li> </ul>"},{"location":"features/#dagger-esque-code-gen-and-runtime","title":"Dagger-esque code gen and runtime","text":"<ul> <li>Metro\u2019s generated code is similar to Dagger: lean, limited duplication, and practical.</li> <li>Metro\u2019s runtime is similar to Dagger. This includes patterns like <code>DoubleCheck</code>, heavy use of factories, and an assumption that this is going to run in a large/modularized codebase.</li> </ul>"},{"location":"features/#kotlin-inject-esque-api","title":"Kotlin-Inject-esque API","text":"<p>Metro\u2019s user-facing API is similar to kotlin-inject: focused on simplicity and leaning into kotlin-language features.</p> <ul> <li>Top-level function injection</li> <li>Providers live in graph interfaces or supertypes</li> <li>Native support for optional dependencies via default parameter values</li> <li>Use of Kotlin\u2019s native <code>Lazy</code> type for lazy injections</li> </ul>"},{"location":"features/#anvil-esque-aggregation","title":"Anvil-esque aggregation","text":"<p>Like Anvil, Metro supports contributing types via aggregation with annotations like <code>@ContributesTo</code>, <code>@ContributesBinding</code>, etc.</p>"},{"location":"features/#multiplatform","title":"Multiplatform","text":"<p>Metro is multiplatform and supports most major Kotlin multiplatform targets.</p> <p>Warning</p> <p>Multi-module multiplatform targets cannot contribute dependencies (i.e. with <code>@Contributes*</code> annotations) from native targets until https://youtrack.jetbrains.com/issue/KT-75865.</p>"},{"location":"features/#ide-integration","title":"IDE Integration","text":"<p>Most errors are reported in FIR, which should (eventually) be visible in the K2 IDE plugin as well.</p>"},{"location":"features/#helpful-diagnostics","title":"Helpful diagnostics","text":"<p>Metro tries its best to give detailed-yet-readable error messages and diagnostics.</p> <pre><code>e: ExampleGraph.kt:8:3 [Metro/MissingBinding] Cannot find an @Inject constructor or @Provides-annotated function/property for: kotlin.Int\n\n    kotlin.Int is requested at\n        [test.ExampleGraph] test.ExampleGraph.int\n\nSimilar bindings:\n  - @Named(\"qualified\") Int (Different qualifier). Type: Provided. Source: ExampleGraph.kt:11:3\n  - Number (Supertype). Type: Provided. Source: ExampleGraph.kt:10:3\n  - Set&lt;Int&gt; (Multibinding). Type: Multibinding.\n</code></pre> <p>For more thorough debugging, Metro also has controls to enable debug logging controls and write graph reports to an output directory (configurable via the Gradle extension).</p>"},{"location":"features/#advanced-interop","title":"Advanced interop","text":"<p>Metro has advanced interop with existing DI tools.</p> <ul> <li>Metro supports component-level interop with Dagger and kotlin-inject. This means that Metro graphs can depend on Dagger and kotlin-inject components via <code>@Includes</code> dependencies.</li> <li>Metro supports defining user-defined alternatives for common annotations in addition to its first-party options. This allows easier introduction to codebases using annotations from existing DI frameworks.</li> <li>If Dagger interop is enabled, Metro can generate code that both interops with Dagger/Javax/Jakarta\u2019s types directly as well as reuse Dagger/Anvil\u2019s generated factories.</li> <li>If Anvil interop is enabled, Metro\u2019s compiler can interpret Anvil\u2019s <code>@ContributesMultibinding</code> and <code>boundType</code> APIs.</li> </ul>"},{"location":"generating-metro-code/","title":"Generating Metro Code","text":"<p>Java annotation processing and KSP both support multiple rounds of processing, allowing custom processors to generate new code with injection annotations that can be processed in later rounds. Anvil supported custom <code>CodeGenerator</code> implementations in K1 and anvil-ksp and kotlin-inject-anvil support specifying custom contributing annotations to allow them to intelligently defer processing to later rounds.</p> <p>Since Metro is implemented as a compiler plugin, asking users to write compiler plugins to interact with it would be a bit unwieldy. However, KSP processors that generate metro-annotated code work out of the box with it since they run before Metro\u2019s plugin does.</p> <p>If you have an existing KSP processor for a different framework, you could leverage it + custom annotations interop support described above to make them work out of the box with Metro.</p>"},{"location":"generating-metro-code/#origin-annotations","title":"Origin Annotations","text":"<p>When code generators create Metro-annotated types, they can use the <code>@Origin</code> annotation to link the generated type back to its source. This is particularly useful for contribution merging - when a source type is excluded or replaced in a <code>@DependencyGraph</code>, any generated types with <code>@Origin</code> pointing to it will also be excluded or replaced automatically.</p> <pre><code>// Source type\n@GenerateSomething\nclass UserRepository\n\n// Generated by your KSP processor\n@ContributesBinding(AppScope::class)\n@Origin(UserRepository::class)  // Links back to the source\nclass UserRepository_Impl : UserRepository\n</code></pre> <p>Now if <code>UserRepository</code> is excluded in a graph:</p> <pre><code>@DependencyGraph(\n  scope = AppScope::class,\n  excludes = [UserRepository::class]  // This also excludes UserRepository_Impl\n)\ninterface AppGraph\n</code></pre>"},{"location":"generating-metro-code/#custom-origin-annotations","title":"Custom Origin Annotations","text":"<p>You can configure Metro to recognize custom origin annotations through the Gradle plugin:</p> <pre><code>metro {\n  interop {\n    origin.add(\"com.example.GeneratedFrom\")\n  }\n}\n</code></pre> <p>The annotation must have a <code>KClass</code> parameter at index <code>0</code>.</p> <p>If using Anvil interop, kotlin-inject-anvil\u2019s <code>@Origin</code> annotation is automatically recognized.</p> <pre><code>metro {\n  interop {\n    includeAnvil(includeKotlinInjectAnvil = true)\n  }\n}\n</code></pre>"},{"location":"injection-types/","title":"Injection Types","text":"<p>Metro supports multiple common injection types.</p>"},{"location":"injection-types/#constructor-injection","title":"Constructor Injection","text":"<p>Most types should use constructor injection if possible. For this case, you can annotate either a class itself (if it has exactly one, primary constructor) or exactly one specific constructor.</p> <pre><code>@Inject\nclass ClassInjected\n\nclass SpecificConstructorInjection(val text: String) {\n  @Inject constructor(value: Int) : this(value.toString())\n}\n</code></pre> <p>Constructor-injected classes can be instantiated+managed entirely by Metro and encourages immutability.</p>"},{"location":"injection-types/#assisted-injection","title":"Assisted Injection","text":"<p>For types that require dynamic dependencies at instantiation, assisted injection can be used to supply these inputs. In this case - an injected constructor (or class with one constructor) must be annotated with <code>@AssistedInject</code>, assisted parameters annotated with <code>@Assisted</code>, and a factory interface or abstract class with one single abstract function that accepts these assisted parameters and returns the target class.</p> <pre><code>@AssistedInject\nclass HttpClient(\n  @Assisted val timeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeout: Duration): HttpClient\n  }\n}\n</code></pre> <p>Then, the <code>@AssistedFactory</code>-annotated type can be accessed from the dependency graph.</p> <pre><code>@Inject\nclass ApiClient(httpClientFactory: HttpClient.Factory) {\n  private val httpClient = httpClientFactory.create(30.seconds)\n}\n</code></pre> <p>Like Dagger, the <code>@Assisted</code> parameters can take optional <code>value</code> keys to disambiguate matching types.</p> <pre><code>@AssistedInject\nclass HttpClient(\n  @Assisted(\"connect\") val connectTimeout: Duration,\n  @Assisted(\"request\") val requestTimeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(\n      @Assisted(\"connect\") connectTimeout: Duration,\n      @Assisted(\"request\") requestTimeout: Duration,\n    ): HttpClient\n  }\n}\n</code></pre>"},{"location":"injection-types/#automatic-assisted-factory-generation","title":"Automatic Assisted Factory Generation","text":"<p>Metro supports automatic generation of assisted factories via opt-in compiler option. If enabled, Metro will automatically generate a default factory as a nested class within the injected type.</p> <pre><code>@AssistedInject\nclass HttpClient(\n  @Assisted timeoutDuration: Duration,\n  cache: Cache,\n) {\n  // Generated by Metro\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeoutDuration: Duration): HttpClient\n  }\n}\n</code></pre> <p>If a nested class called <code>Factory</code> is already present, Metro will do nothing.</p>"},{"location":"injection-types/#why-opt-in","title":"Why opt-in?","text":"<p>The main reason this is behind an opt-in option at the moment is because compiler plugin IDE support is rudimentary at best and currently requires enabling a custom registry flag. See the docs for how to enable IDE support.</p> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  generateAssistedFactories.set(true)\n}\n</code></pre>"},{"location":"injection-types/#member-injection","title":"Member Injection","text":"<p>Metro supports member injection to inject mutable properties or functions post-construction or into existing class instances.</p> <p>This can be useful for classes that cannot be constructor-injected, for example Android Activity classes (on older SDK versions) as well as constructor-injected classes that perhaps don\u2019t want or need to expose certain types directly in their constructors.</p> <p>Tip</p> <p>Unlike Dagger and kotlin-inject, injected members in Metro can be <code>private</code>.</p> <p>Note</p> <p>Member function injection does not (currently) support default values.</p> <pre><code>class ProfileActivity : Activity() {\n  // Property injection\n  @Inject private lateinit var db: UserDatabase\n\n  @Inject private var notifications: Notifications? = null\n\n  // Function injection\n  @Inject private fun injectUser(user: User) {\n    // ...\n  }\n}\n</code></pre> <p>Like Dagger, these classes can be injected via multiple avenues.</p>"},{"location":"injection-types/#1-in-constructor-injected-types-inject-annotated-members-are-injected-automatically","title":"1. In constructor-injected types, <code>@Inject</code>-annotated members are injected automatically.","text":"<pre><code>// Injection with constructor injection\n@Inject\nclass ProfileInjector(\n  // ...\n) {\n  // Automatically injected during constructor injection\n  @Inject private fun injectUser(value: String) {\n    // ...\n  }\n}\n</code></pre> <p>In these cases, Metro will automatically inject these members automatically and immediately after instantiation during constructor injection.</p>"},{"location":"injection-types/#2-exposing-a-fun-injecttarget-profileactivity-function-on-the-graph","title":"2. Exposing a <code>fun inject(target: ProfileActivity)</code> function on the graph","text":"<pre><code>// Graph inject() functions\n@DependencyGraph\ninterface AppGraph {\n  // ...\n\n  fun inject(target: ProfileActivity)\n}\n\n// Somewhere else\nval graph = createGraph&lt;AppGraph&gt;()\ngraph.inject(profileActivity)\n</code></pre> <p>With this option, you can call <code>graph.inject(target)</code> on the instance with members you wish to inject.</p>"},{"location":"injection-types/#3-requesting-a-membersinjector-instance-from-the-dependency-graph","title":"3. Requesting a <code>MembersInjector</code> instance from the dependency graph.","text":"<pre><code>// Injection with MembersInjector\n@Inject\nclass ProfileInjector(\n  private val injector: MembersInjector&lt;ProfileActivity&gt;\n) {\n  fun performInjection(activity: ProfileActivity) {\n    injector.inject(activity)\n  }\n}\n</code></pre> <p>Like Dagger, option #3 is accomplished via <code>MembersInjector</code> interface at runtime and in code gen. This should be reserved for advanced use cases.</p> Implementation Notes <ul> <li>Property accessors don\u2019t use <code>get</code>/<code>set</code> names in <code>inject{name}()</code> function names.</li> <li>MembersInjector classes are generated as nested classes, allowing private member access.<ul> <li>This includes parent classes\u2019 private members (!!)</li> </ul> </li> <li>optional dependencies are not supported for injected member functions currently, but may be possible in the future.</li> </ul>"},{"location":"injection-types/#top-level-function-injection","title":"Top-level Function Injection","text":"<p>Like KI, Metro supports top-level function injection (behind an opt-in compiler option). The primary use case for this is composable functions and standalone applications that run from <code>main</code> functions.</p> <pre><code>@Inject\nfun App(message: String) {\n  // ...\n}\n</code></pre> <p>To do this, Metro\u2019s FIR plugin will generate a concrete type that acts as a bridge for this function.</p> <pre><code>@Inject\nclass AppClass(\n  private val message: Provider&lt;String&gt;\n) {\n  operator fun invoke() {\n    App(message())\n  }\n}\n</code></pre> <p>Because it\u2019s generated in FIR, this type will be user-visible in the IDE and can then be referenced in a graph.</p> <p>Note that this feature requires enabling third party FIR plugins in the IDE to fully work. It will compile without it, but generated wrapper classes will be red/missing in the IDE.</p> <p>Note</p> <p>The generated class is called <code>&lt;function name&gt;</code> + <code>Class</code> because of a limitation in the Kotlin compiler. TODO Link issue?</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val app: AppClass\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n\n// Usage\nval app = createGraphFactory&lt;AppGraph.Factory&gt;()\n  .create(\"Hello, world!\")\n  .app\n\n// Run the app\napp()\n</code></pre> <p>To add assisted parameters, use <code>@Assisted</code> on the parameters in the function description. These will be propagated accordingly.</p> <pre><code>@Inject\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval app = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Run the app\napp(\"Hello, world!\")\n</code></pre> <p>This is particularly useful for Compose, and <code>@Composable</code> functions will be copied over accordingly.</p> <pre><code>@Inject\n@Composable\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  @Composable\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval App = createGraph&lt;AppGraph&gt;().app\n\n// Call it in composition\nsetContent {\n  App(\"Hello, world!\")\n}\n</code></pre> <p>Similarly, if the injected function is a <code>suspend</code> function, the <code>suspend</code> keyword will be ported to the generated <code>invoke()</code> function too.</p>"},{"location":"injection-types/#context-parameters","title":"Context parameters","text":"<p>Top-level injected functions also support context parameters. Both regular and context parameters may be assisted.</p> <p>Any assisted context parameters will be carried as context parameters to the generated class\u2019s <code>invoke()</code> function.</p> SourceGenerated <pre><code>@Inject\n@Composable\ncontext(@Assisted sharedTransitionScope: SharedTransitionScope)\nfun ClockWidget(\n  clock: Clock, // injected\n  @Assisted modifier: Modifier, // assisted inject\n) {\n  // ...\n}\n</code></pre> <pre><code>@Inject\nclass ClockWidgetClass(private val clock: Provider&lt;Clock&gt;) {\n  @Composable\n  context(sharedTransitionScope: SharedTransitionScope)\n  operator fun invoke(modifier: Modifier) {\n    ClockWidget(clock(), modifier)\n  }\n}\n</code></pre>"},{"location":"injection-types/#why-opt-in_1","title":"Why opt-in?","text":"<p>There are two reasons this is behind an opt-in option at the moment.</p> <ol> <li>Generating top-level declarations in Kotlin compiler plugins (in FIR specifically) is not    currently compatible with incremental compilation.</li> <li>IDE support is rudimentary at best and currently requires enabling a custom registry flag.    See the docs for how to enable IDE support.</li> </ol> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  enableTopLevelFunctionInjection.set(true)\n}\n</code></pre> Implementation Notes <ul> <li>This is fairly different from kotlin-inject\u2019s typealias approach. This is necessary because Metro doesn\u2019t use higher order function types or typealiases as qualifiers.</li> <li>Since the compose-compiler\u2019s IR transformer may run before Metro\u2019s, we check for this during implementation body generation and look up the transformed target composable function as needed.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Metro is primarily applied via its companion Gradle plugin.</p> <pre><code>plugins {\n  kotlin(\"multiplatform\") // or jvm, android, etc\n  id(\"dev.zacsweers.metro\")\n}\n</code></pre> <p>\u2026and that\u2019s it! This will add metro\u2019s runtime dependencies and do all the necessary compiler plugin wiring.</p> <p>If applying in other build systems, apply it however that build system conventionally applies Kotlin compiler plugins. For example with Bazel:</p> <pre><code>load(\"@rules_kotlin//kotlin:core.bzl\", \"kt_compiler_plugin\")\nload(\"@rules_kotlin//kotlin:jvm.bzl\", \"kt_jvm_library\")\n\nkt_compiler_plugin(\n    name = \"metro_plugin\",\n    compile_phase = True,\n    id = \"dev.zacsweers.metro.compiler\",\n    options = {\n        \"enabled\": \"true\",\n        \"debug\": \"false\",\n    },\n    deps = [\n        \"@maven//:dev_zacsweers_metro_compiler\",\n    ],\n)\n\nkt_jvm_library(\n    name = \"sample\",\n    # The SampleGraph class is annotated with @DependencyGraph\n    srcs = [\"SampleGraph.kt\"],\n    plugins = [\n        \":metro_plugin\",\n    ],\n    deps = [\n        \"@maven//:dev_zacsweers_metro_runtime_jvm\",\n    ],\n)\n</code></pre>"},{"location":"installation/#ide-support","title":"IDE Support","text":"<p>The K2 Kotlin IntelliJ plugin supports running third party FIR plugins in the IDE, but this feature is hidden behind a flag. Some Metro features can take advantage of this, namely diagnostic reporting directly in the IDE and some opt-in features to see generated declarations. </p> <p>To enable it, do the following:</p> <ol> <li>Enable K2 Mode for the Kotlin IntelliJ plugin.</li> <li>Open the Registry</li> <li>Set the <code>kotlin.k2.only.bundled.compiler.plugins.enabled</code> entry to <code>false</code>.</li> </ol> <p>Note that support is unstable and subject to change.</p>"},{"location":"interop/","title":"Interop","text":""},{"location":"interop/#annotations","title":"Annotations","text":"<p>Metro supports user-defined annotations for common annotations. This means that a user doesn\u2019t necessarily have to use Metro\u2019s annotations if they\u2019re introducing it to an existing codebase. Support varies depending on the annotation\u2019s use case.</p> <p>Compile-only annotations are mostly supported. This includes the following:</p> <ul> <li><code>@AssistedFactory</code></li> <li><code>@AssistedInject</code></li> <li><code>@Assisted</code></li> <li><code>@BindsInstance</code></li> <li><code>@Binds</code></li> <li><code>@ContributesBinding</code></li> <li><code>@ContributesTo</code></li> <li><code>@DependencyGraph.Factory</code></li> <li><code>@DependencyGraph</code></li> <li><code>@ElementsIntoSet</code></li> <li><code>@Inject</code></li> <li><code>@IntoMap</code></li> <li><code>@IntoSet</code></li> <li><code>@MapKey</code></li> <li><code>@Module</code></li> <li><code>@Multibinds</code></li> <li><code>@Provides</code></li> <li><code>@Qualifier</code></li> <li><code>@Scope</code></li> </ul> <p>These are configurable via Metro\u2019s Gradle extension.</p> <pre><code>metro {\n  interop {\n    assisted.add(\"dagger/assisted/Assisted\")\n  }\n}\n</code></pre> <p>For Dagger and KI specifically, there are convenience helper functions.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n    includeKotlinInject()\n    includeAnvil()\n  }\n}\n</code></pre> <p><code>@DependencyGraph</code> is replaceable but your mileage may vary if you use Anvil or modules, since Metro\u2019s annotation unifies Anvil\u2019s <code>@MergeComponent</code> functionality and doesn\u2019t support modules.</p> <p>Similarly, <code>@ContributesBinding</code> is replaceable but there are not direct analogues for Anvil\u2019s <code>@ContributesMultibinding</code> or kotlin-inject-anvil\u2019s <code>@ContributesBinding(multibinding = \u2026)</code> as these annotations are implemented as <code>@ContributesInto*</code> annotations in Metro.</p> <p><code>binding</code> in Metro uses a more flexible mechanism to support generics, but interop with Anvil\u2019s <code>boundType: KClass&lt;*&gt;</code> property is supported.</p>"},{"location":"interop/#components","title":"Components","text":"<p>Metro graphs can interop with components generated by Dagger and Kotlin-Inject. These work exclusively through their public accessors and can be depended on like any other graph dependency.</p> <pre><code>@DependencyGraph\ninterface MetroGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(\n      @Includes daggerComponent: DaggerComponent\n    ): MetroGraph\n  }\n}\n\n@dagger.Component\ninterface DaggerComponent {\n  val message: String\n\n  @dagger.Component.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): DaggerComponent\n  }\n}\n</code></pre> <p>Conversely, kotlin-inject and Dagger components can also depend on Metro graphs.</p> <pre><code>@DependencyGraph\ninterface MessageGraph {\n  val message: String\n\n  // ...\n}\n\n// Dagger\n@Component(dependencies = [MessageGraph::class])\ninterface DaggerComponent {\n  val message: String\n\n  @Component.Factory\n  fun interface Factory {\n    fun create(messageGraph: MessageGraph): DaggerComponent\n  }\n}\n\n// kotlin-inject\n@Component\nabstract class KotlinInjectComponent(\n  @Component val messageGraph: MessageGraph\n) {\n  abstract val message: String\n}\n</code></pre>"},{"location":"interop/#runtime","title":"Runtime","text":"<p>Enabling dagger interop also enables more advanced runtime interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code>/<code>Lazy</code> types.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n  }\n}\n</code></pre> <p>This specifically enables two features.</p> <ol> <li>Interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code> and <code>Lazy</code> runtime intrinsics.</li> <li>Interop with generated Dagger factories for constructor-injected classes, assisted-injected classes, and Dagger modules. This means that an upstream class or module that was processed with the dagger compiler and has a generated Java factory class can be natively reused by Metro.</li> </ol> <p>Note this also automatically adds an extra <code>interop-dagger</code> dependency to support this scenario.</p> <p>Enabling this feature also enables interop with Dagger\u2019s <code>@BindsOptionalOf</code> annotation.</p>"},{"location":"interop/#diagnostics","title":"Diagnostics","text":"<p>When interoping with annotations that are written in Kotlin and have parameters, it may be unsafe to rely on positional arguments. Metro\u2019s own annotations often have the same indices, but not always! If you want to be super safe, you can enable the <code>interopAnnotationsNamedArgSeverity</code> to <code>WARN</code> or <code>ERROR</code> to report diagnostics for positional arguments in any custom annotations that Metro is configured to look at.</p> <p>Why only Kotlin annotations?</p> <p>This is because the Kotlin compiler doesn\u2019t support positional arguments for annotations that are written in Java.</p>"},{"location":"metro-intrinsics/","title":"Metro Intrinsics","text":"<p>Like Dagger, Metro supports injection of bindings wrapped in intrinsic types. Namely - <code>Provider</code> and <code>Lazy</code>. These are useful for deferring creation/initialization of dependencies. These only need to be requested at the injection site, Metro\u2019s code gen will generate all the necessary stitching to fulfill that request.</p>"},{"location":"metro-intrinsics/#provider","title":"<code>Provider</code>","text":"<p><code>Provider</code> is like Dagger\u2019s <code>Provider</code> \u2014 it is a simple interface who\u2019s <code>invoke()</code> call returns a new instance every time. If the underlying binding is scoped, then the same (scoped) instance is returned every time <code>invoke()</code> is called.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Provider&lt;Cache&gt;) {\n  fun createCache() {\n    val cache = cacheProvider()\n  }\n}\n</code></pre>"},{"location":"metro-intrinsics/#lazy","title":"<code>Lazy</code>","text":"<p><code>Lazy</code> is Kotlin\u2019s standard library <code>Lazy</code>. It lazily computes a value the first time it\u2019s evaluated and is thread-safe.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Lazy&lt;Cache&gt;) {\n  fun createCache() {\n    // The value is computed once and cached after\n    val cache = cacheProvider.value\n  }\n}\n</code></pre> <p>Note that <code>Lazy</code> is different from scoping in that it is confined to the scope of the injected type, rather than the component instance itself. There is functionally no difference between injecting a <code>Provider</code> or <code>Lazy</code> of a scoped binding. A <code>Lazy</code> of a scoped binding can still be useful to defer initialization. The underlying implementation in Metro\u2019s <code>DoubleCheck</code> prevents double memoization in this case.</p> <p>Why doesn\u2019t <code>Provider</code> just use a property like <code>Lazy</code>?</p> <p>A property is appropriate for <code>Lazy</code> because it fits the definition of being a computed value that is idempotent for repeat calls. Metro opts to make its <code>Provider</code> use an <code>invoke()</code> function because it does not abide by that contract.</p>"},{"location":"metro-intrinsics/#providers-of-lazy","title":"Providers of Lazy","text":"<p>Metro supports combining <code>Provider</code> and <code>Lazy</code> to inject <code>Provider&lt;Lazy&lt;T&gt;&gt;</code>. On unscoped bindings this means the provider will return a new deferrable computable value (i.e. a new Lazy). Meanwhile <code>Lazy&lt;Provider&lt;T&gt;&gt;</code> is meaningless and not supported.</p>"},{"location":"multiplatform/","title":"Multiplatform","text":"<p>Should Just Work\u2122\ufe0f! The runtime and code gen have been implemented to be entirely platform-agnostic so far.</p> <p>There is one issue in the repo right now where the compiler appears to have a bug with generated FIR declarations where it doesn\u2019t deserialize them correctly on non-JVM targets. Waiting for feedback from JB.</p> <p>When mixing contributions between common and platform-specific source sets, you must define your final <code>@DependencyGraph</code> in the platform-specific code. This is because a graph defined in commonMain wouldn\u2019t have full visibility of contributions from platform-specific types. A good pattern for this is to define your canonical graph in commonMain without a <code>@DependencyGraph</code> annotation and then a <code>{Platform}{Graph}</code> type in the platform source set that extends it and does have the <code>@DependencyGraph</code>. Metro automatically exposes bindings of the base graph type on the graph for any injections that need it.</p> <pre><code>// In commonMain\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n\n// In jvmMain\n@DependencyGraph\ninterface JvmAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(Netty)\n}\n\n// In androidMain\n@DependencyGraph\ninterface AndroidAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(OkHttp)\n}\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>Metro strives to be a performant solution with minimal overhead at build-time and generating fast, efficient code at runtime. As build performance is the primary consideration for most developers considering this, most of this doc will be focused on that.</p>"},{"location":"performance/#build-performance","title":"Build Performance","text":"<p>Metro\u2019s compiler plugin is designed to be fast. Running as a compiler plugin allows it to: - Avoid generating new sources that need to be compiled - Avoid running KSP/KAPT - Generate IR that lowers directly into target platforms - Hook directly into kotlinc\u2019s IC APIs.</p> <p>In a straightforward migration, it improves ABI-changing build performance from 30-70%.</p>"},{"location":"performance/#benchmarking","title":"Benchmarking","text":"<p>To benchmark against Anvil-KSP, Dagger (KSP or KAPT), and Kotlin-Inject (+ Anvil), there is a benchmark directory with a generator script. There are more details in its README, but in short it generates a nontrivial multi-module project (default is 500 modules but is configurable) and benchmarks with gradle-profiler.</p> <p>Summary</p> <p>Results as of Metro <code>0.3.7</code>, Anvil-KSP <code>0.4.1</code>, Dagger <code>2.56.2</code>, and Kotlin-Inject <code>0.8.0</code> with kotlin-inject-anvil <code>0.1.6</code> are as follows.</p> <p>(Median times in seconds)</p> Metro Anvil KSP Anvil Kapt Kotlin-Inject ABI 5.3s 40.5s (+663%) 25.3s (+377%) 10.3s (+94%) Non-ABI 2.6s 3.8s (+45%) 7.1s (+171%) 3.3s (+26%) Graph processing 6.9s 28.9s (+318%) 8.7s (+25%) 11s (+59%)"},{"location":"performance/#modes","title":"Modes","text":"<ul> <li>Metro: Purely running metro</li> <li>Anvil KSP: Running dagger-ksp with anvil-ksp for contribution merging.</li> <li>Anvil KAPT: Running dagger with kapt with anvil-ksp for contribution merging.</li> <li>Kotlin Inject: Running kotlin-inject + kotlin-inject-anvil for contribution merging.</li> </ul>"},{"location":"performance/#abi-change","title":"ABI Change","text":"<p>This benchmark makes ABI-breaking source changes in a lower level module. This is where Metro shines the most.</p> <p></p>"},{"location":"performance/#non-abi-change","title":"Non-ABI Change","text":"<p>This benchmark makes non-ABI-breaking source changes in a lower level module. The differences are less significant here as KSP is quite good at compilation avoidance now too. The outlier here is KAPT, which still has to run stub gen + apt and cannot fully avoid it.</p> <p></p>"},{"location":"performance/#raw-graphcomponent-processing","title":"Raw Graph/Component Processing","text":"<p>This benchmark reruns the top-level merging graph/component where all the downstream contributions are merged. This also builds the full dependency graph and any contributed graph extensions/subcomponents.</p> <p>Metro again shines here. Dagger-KSP seems to have a bottleneck that disproportionately affects it here too.</p> <p></p>"},{"location":"performance/#real-world-results","title":"Real-World Results","text":"<p>Below are some results from real-world projects, shared with the developers\u2019 permission.</p> <p>Gabriel Ittner from Freeletics</p> <p>I\u2019ve got Metro working on our code base now using the Kotlin 2.2.0 preview</p> <p>Background numbers</p> <ul> <li>551 modules total</li> <li>105 modules using Anvil KSP \u27a1\ufe0f migrated to pure Metro</li> <li>154 modules using Anvil KSP + other KSP processor \u27a1\ufe0f Metro + other KSP processor</li> <li>1 module using Dagger KAPT \u27a1\ufe0f migrated to pure Metro</li> </ul> <p>Build performance</p> <ul> <li>Clean builds without build cache are 12 percentage points faster</li> <li>Any app module change ~50% faster (this is the one place that had kapt and it\u2019s mostly empty other than generating graphs/components)</li> <li>ABI changes in other modules ~ 40% - 55% faster</li> <li>non ABI changes in other modules unchanged or minimally faster</li> </ul> <p>Madis Pink from emulator.wtf</p> <p>I got our monorepo migrated over from anvil, it sliced off one third of our Gradle tasks and <code>./gradlew classes</code> from clean is ~4x faster</p> <p>Kevin Chiu from BandLab</p> <p>We migrated our main project at BandLab to metro, finally!</p> <p>Some context about our project:</p> <ul> <li>We use Dagger + Anvil KSP</li> <li>929 modules, 89 of them are running Dagger compiler (KAPT) to process components</li> <li>7 KSP processors</li> </ul> Build Dagger + Anvil KSP Metro (\u0394) UiKit ABI change (Incremental) 59.7 s 26.9 s (55% faster) Root ABI change (Incremental) 95.7 s 48.1 s (49.8% faster) Root non-ABI change (Incremental) 70.9 s 38.9 s (45.2% faster) Clean build 327 s 288 s (11.7% faster)"},{"location":"performance/#reporting","title":"Reporting","text":"<p>If you want to investigate the performance of different stages of Metro\u2019s compiler pipeline, you can enable reporting in the Gradle DSL.</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre> <p>Among the reports written there, there will also be a trace log that dumps a simple trace of the different stages.</p> <pre><code>[ExampleGraph] \u25b6 Transform dependency graph\n  \u25b6 Build DependencyGraphNode\n  \u25c0 Build DependencyGraphNode (xx ms)\n  \u25b6 Implement creator functions\n  \u25c0 Implement creator functions (xx ms)\n  \u25b6 Build binding graph\n  \u25c0 Build binding graph (xx ms)\n  \u25b6 Validate binding graph\n    \u25b6 Check self-cycles\n    \u25c0 Check self-cycles (xx ms)\n    \u25b6 Validate graph\n      \u25b6 seal graph\n        \u25b6 Populate bindings\n        \u25c0 Populate bindings (xx ms)\n        \u25b6 Build adjacency list\n        \u25c0 Build adjacency list (xx ms)\n        \u25b6 Sort and validate\n          \u25b6 Topo sort\n            \u25b6 Compute SCCs\n            \u25c0 Compute SCCs (xx ms)\n            \u25b6 Check for cycles\n            \u25c0 Check for cycles (xx ms)\n            \u25b6 Build component DAG\n            \u25c0 Build component DAG (xx ms)\n            \u25b6 Topo sort component DAG\n            \u25c0 Topo sort component DAG (xx ms)\n            \u25b6 Expand components\n            \u25c0 Expand components (xx ms)\n          \u25c0 Topo sort (xx ms)\n        \u25c0 Sort and validate (xx ms)\n        \u25b6 Compute binding indices\n        \u25c0 Compute binding indices (xx ms)\n      \u25c0 seal graph (xx ms)\n      \u25b6 check empty multibindings\n      \u25c0 check empty multibindings (xx ms)\n      \u25b6 check for absent bindings\n      \u25c0 check for absent bindings (xx ms)\n    \u25c0 Validate graph (xx ms)\n  \u25c0 Validate binding graph (xx ms)\n  \u25b6 Transform metro graph\n    \u25b6 Collect bindings\n    \u25c0 Collect bindings (xx ms)\n    \u25b6 Implement overrides\n    \u25c0 Implement overrides (xx ms)\n  \u25c0 Transform metro graph (xx ms)\n[ExampleGraph] \u25c0 Transform dependency graph (xx ms)\n</code></pre>"},{"location":"performance/#runtime-performance","title":"Runtime Performance","text":"<p>Metro\u2019s compiler generates Dagger-style factory classes for every injection site.</p> <p>The same factory classes are reused across modules and downstream builds, so there\u2019s no duplicated glue code or runtime discovery cost.</p> <p>Because the full dependency graph is wired at compile-time, each binding is accessed through a direct field reference in the generated code. No reflection, no hashmap lookups, no runtime service locator hops, etc.</p>"},{"location":"provides/","title":"<code>@Provides</code>","text":"<p>Providers can be defined in graphs or supertypes that graphs extend. Defining them in supertypes allows for them to be reused across multiple graphs and organize providers into logic groups. This is similar to how modules in Dagger work.</p> <pre><code>interface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface AppGraph : NetworkProviders\n</code></pre> <p>Provider functions should be <code>private</code> by default and are automatically transformed to be private by the Metro compiler. This means you can write a provider function with no explicit (or public) visibility and it will be made private by Metro at compile-time.</p> <p>Provider properties cannot be private yet due to KT-76257, but may be supported in the future.</p> <p>Providers may also be declared in binding Containers.</p> <p>Tip</p> <p>It\u2019s recommended to not call providers from each other.</p>"},{"location":"provides/#overrides","title":"Overrides","text":"<p>It is an error to override providers declarations. While it can be enticing for testing reasons to try to replicate Dagger 1\u2019s module overrides, it quickly becomes difficult to reason about in code gen.</p> <ul> <li>What if you override with sub/supertypes?</li> <li>What if your override\u2019s implementation needs different dependencies?</li> </ul> <p>To the testing end, it is recommended to instead leverage the <code>DependencyGraph.excludes</code> + <code>ContributesTo.replaces</code> APIs in merging.</p> <pre><code>// Don't do this pattern!\ninterface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface TestAppGraph : NetworkProviders {\n  // This will fail to compile\n  override fun provideHttpClient(): HttpClient = TestHttpClient()\n}\n</code></pre>"},{"location":"provides/#companion-providers","title":"Companion Providers","text":"<p>Providers can alternatively be implemented in <code>companion object</code>s for staticization.</p> <pre><code>interface MessageGraph {\n  val message: String\n  companion object {\n    @Provides\n    private fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre> Implementation Notes <p>private interface functions are not usually visible to downstream compilations in IR. To work around this, Metro will use a new API in Kotlin 2.1.20 to add custom metadata to the parent class to denote these private providers\u2019 existence and where to find them.</p>"},{"location":"samples/","title":"Metro Samples","text":"<p>The samples directory contains various sample projects demonstrating different use cases and integrations for Metro.</p>"},{"location":"samples/#android-app","title":"android-app","text":"<p>A simple Android sample app that demonstrates using Metro to constructor-inject Android framework components like <code>Activity</code>, <code>Fragment</code>, and <code>ViewModel</code> with multibindings.</p>"},{"location":"samples/#circuit-app","title":"circuit-app","text":"<p>A multiplatform sample that demonstrates using Metro with Circuit and Jetpack Compose.</p>"},{"location":"samples/#interop","title":"interop","text":"<p>Various demonstrating interop between Metro and other dependency injection frameworks.</p>"},{"location":"samples/#multi-module-test","title":"multi-module-test","text":"<p>A sample + integration test demonstrating Metro in a multi-module project structure with.</p> <p>This sample shows how Metro handles dependencies across module boundaries and component hierarchies.</p>"},{"location":"samples/#weather-app","title":"weather-app","text":"<p>A simple command-line weather app that demonstrates basic Metro usage.</p>"},{"location":"scopes/","title":"Scopes","text":"<p>Like Dagger and KI, Metro supports scopes to limit instances of types on the dependency graph. A scope is any annotation annotated with <code>@Scope</code>, with a convenience <code>@SingleIn</code> scope available in Metro\u2019s runtime.</p> <p>Scopes must be applied to either the injected class or the provider function providing that binding. They must also match the graph that they are used in.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\nabstract class AppGraph {\n  private var counter = 0\n\n  abstract val count: Int\n\n  @SingleIn(AppScope::class) @Provides fun provideCount() = counter++\n}\n</code></pre> <p>In the above example, multiple calls to <code>AppGraph.count</code> will always return 0 because the returned value from <code>provideCount()</code> will be cached in the <code>AppGraph</code> instance the first time it\u2019s called.</p> <p>It is an error for an unscoped graph to access scoped bindings.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>It is also an error for a scoped graph to access scoped bindings whose scope does not match.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(UserScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>Like Dagger, graphs can have multiple scopes that they support.</p> <pre><code>@Scope annotation class Singleton\n\n@Singleton\n@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is ok\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre>"},{"location":"validation-and-error-reporting/","title":"Validation &amp; Error Reporting","text":"<p>Common programmer/usage errors are implemented in FIR. This should allow errors to appear directly in the IDE, offering the best and fastest feedback loop for developers writing their code.</p> <p>TODO IDE screenshot example</p> <p>Dependency graph validation is performed at the per-graph level. Metro seeks to report binding validation errors at least on par with Dagger, if not better.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/DependencyCycle] Found a dependency cycle:\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n    kotlin.String is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideDouble(..., string)\n    kotlin.Double is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideInt(..., double)\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n</code></pre> <p>Binding errors take learnings from Dagger and report fully qualified references that IDEs like IntelliJ can usually autolink.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/GraphDependencyCycle] Dependency graph dependency cycle detected! The below graph depends on itself.\n    test.CharSequenceGraph is requested at\n        [test.CharSequenceGraph] test.CharSequenceGraph.Factory.create()\n</code></pre> <p>Note that binding graph resolution currently only happens in the compiler IR backend, but maybe someday we can move this to FIR to get errors in the IDE.</p>"}]}