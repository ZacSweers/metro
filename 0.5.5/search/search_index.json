{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude87 Metro","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Metro is a compile-time dependency injection framework that draws heavy inspiration from Dagger, Anvil, and Kotlin-Inject. It seeks to unify their best features under one, cohesive solution while adding a few new features and implemented as a compiler plugin.</p>"},{"location":"#why-another-di-framework","title":"Why another DI framework?","text":"<p>It\u2019s felt for some time like the Kotlin community has been waiting for a library at the intersection of these different tools and features. Different tools exist for parts of these, but there\u2019s not yet been a unified solution that checks all these boxes, leaves behind some of these tools\u2019 limitations, and embraces newer features that native compiler plugins offer.</p> <p>In short, Metro stands on the shoulders of giants. It doesn\u2019t try to reinvent the wheel, it does try to make those wheels work better together.</p> <p>Note</p> <p>I\u2019m aware of the XKCD comic \ud83d\ude42, I think Metro offers a compelling feature set with interop hooks that make it easy to integrate with an existing codebase.</p>"},{"location":"#installation","title":"Installation","text":"<p>Apply the gradle plugin.</p> <pre><code>plugins {\n  id(\"dev.zacsweers.metro\") version \"x.y.z\"\n}\n</code></pre> <p>And that\u2019s it! The default configuration will add the multiplatform <code>runtime</code> artifact (which has annotations you can use) and wire it all automatically.</p> <p>You can configure custom behaviors with APIs on the <code>metro</code> DSL extension.</p> <pre><code>metro {\n  // Defines whether or not metro is enabled. Useful if you want to gate this behind a dynamic\n  // build configuration.\n  enabled = true // Default\n\n  // Enable (extremely) verbose debug logging\n  debug = false // Default\n\n  // See the kdoc on MetroPluginExtension for full details\n}\n</code></pre> <p>Snapshots of the development version are available in Sonatype\u2019s <code>snapshots</code> repository.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>The compiler plugin itself supports all multiplatform project types. The first-party annotations artifact is also multiplatform and supports all common JVM, JS, and native targets.</p> <p>Contribution hint generation is not currently supported on native or Wasm targets until KT-58886 is resolved. They do work within the same compilation though.</p>"},{"location":"#caveats","title":"Caveats","text":"<ul> <li>Kotlin compiler plugins are not a stable API! Compiled outputs from this plugin should be stable, but usage in newer versions of kotlinc are not guaranteed to be stable. That said, Metro will strive to make matching releases available quickly and test against Kotlin prereleases eagerly.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Special thanks to the many people that helped advise and offer feedback on Metro\u2019s design and implementation.</p> <ul> <li>Brian Norman</li> <li>Ralf Wondratschek</li> <li>Jesse Wilson</li> <li>Dany Santiago</li> <li>Eva Tatarka</li> <li>Bill Phillips</li> <li>Bryan Stern</li> <li>James Barr</li> <li>and many more!</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>Copyright (C) 2025 Zac Sweers\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"adoption/","title":"Adoption Strategies","text":"<p>If adopting Metro into an existing codebase, you can use a few different strategies.</p> <ol> <li>First, add the Metro Gradle plugin and runtime deps. The plugin id is <code>dev.zacsweers.metro</code>, runtime is <code>dev.zacsweers.metro:runtime</code>. The Gradle Plugin should add the runtime automatically, but it\u2019s there just in case!</li> <li>Apply the Gradle plugin to your relevant project(s).</li> </ol> From DaggerFrom kotlin-inject"},{"location":"adoption/#precursor-steps","title":"Precursor steps","text":"<p>Compiler options you should enable in Dagger</p> <p>Dagger has some compiler options you should enable and get working first to make it easier to move to Metro.</p> <ul> <li>useBindingGraphFix <ul> <li>The issue it fixes is something that Metro catches as well.</li> </ul> </li> <li>fullBindingGraphValidation<ul> <li>Metro performs full binding graph validation.</li> </ul> </li> <li>ignoreProvisionKeyWildcards</li> </ul> <p>K2 Migration</p> <p>If you are migrating from square/anvil, you likely are also going to have to migrate to Kotlin K2 as a part of this. If you want to split that effort up, you can consider migrating to anvil-ksp first. This would move fully over to KSP and K2 first, then you can resume here.</p>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level","title":"Option 1: Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on Dagger components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is also good if you just want to do a simple, isolated introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations","title":"Option 2: Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from Dagger/Anvil. Here is an example for enabling that in Gradle.</p> <ol> <li>Remove the dagger-compiler/anvil plugin (but keep their runtime deps).</li> <li>Enable interop with the Metro gradle plugin</li> </ol> <pre><code>metro {\n  interop {\n    includeDagger()\n    includeAnvil() // If using Anvil\n  }\n}\n</code></pre> <p>Most things will Just Work\u2122, but you will still possibly need to do some manual migrations.</p> <ul> <li>If you use <code>KClass</code> and <code>Class</code> interchangeably in your graph, Metro distinguishes between these and you\u2019ll need to move fully over to one or the other, likely <code>KClass</code>.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>If you use <code>@ContributesSubcomponent</code>, you\u2019ll need to update their factories to use <code>@ContributesGraphExtension.Factory</code>.</li> <li>If you use <code>@MergeComponent</code> with <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>Not necessary if coming from anvil-ksp.</li> <li>Migrate <code>@BindsInstance</code> to <code>@Provides</code>. Metro consolidated these to just one annotation.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul> <p>You can also remove any <code>@JvmSuppressWildcard</code> annotations, these are ignored in Metro.</p>"},{"location":"adoption/#option-3-full-migration","title":"Option 3: Full migration","text":"<ul> <li>Remove the Dagger and anvil runtimes.</li> <li>Replace all Dagger/anvil annotations with Metro equivalents.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> <li>Migrate from javax/jakarta <code>Provider</code> and <code>dagger.Lazy</code> APIs to Metro\u2019s <code>Provider</code> and the stdlib\u2019s <code>Lazy</code> APIs.</li> </ul>"},{"location":"adoption/#precursor-steps_1","title":"Precursor steps","text":"<ol> <li>Remove the kotlin-inject(-anvil) dependencies (but keep their runtime deps if you use option 1 below!).</li> <li>Migrate to <code>@AssistedFactory</code> if you haven\u2019t already.</li> </ol>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level_1","title":"Option 1: Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on kotlin-inject components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is also good if you want to do a simple, isolated introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations_1","title":"Option 2: Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from kotlin-inject/kotlin-inject-anvil. Here is an example for enabling that in Gradle.</p> <ol> <li>Remove the kotlin-inject and kotlin-inject-anvil KSP processors (but keep their runtime deps).</li> <li>Enable interop with the Metro Gradle plugin</li> </ol> <pre><code>metro {\n  interop {\n    includeKotlinInject()\n    includeAnvil() // If using kotlin-inject-anvil\n  }\n}\n</code></pre> <p>You will still possibly need to do some manual migrations, namely providers.</p> <ul> <li>Any map multibindings need to migrate to use map keys.</li> <li>Any higher order function injection will need to switch to using Metro\u2019s <code>Provider</code> API.</li> <li>Any higher order assisted function injection will need to switch to using <code>@AssistedFactory</code>-annotated factories.</li> <li>If you use <code>@MergeComponent</code> + <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"adoption/#option-3-full-migration_1","title":"Option 3: Full migration","text":"<ul> <li>Any map multibindings need to migrate to use map keys.</li> <li>Any higher order function injection will need to switch to using Metro\u2019s <code>Provider</code> API.</li> <li>Any higher order assisted function injection will need to switch to using <code>@AssistedFactory</code>-annotated factories.</li> <li>Remove the kotlin-inject and kotlin-inject-anvil runtimes.</li> <li>Replace all kotlin-inject/kotlin-inject-anvil annotations with Metro equivalents.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"aggregation/","title":"Aggregation (aka \u2018Anvil\u2019)","text":"<p>Metro supports Anvil-style aggregation in graphs via <code>@ContributesTo</code> and <code>@ContributesBinding</code> annotations. As aggregation is a first-class citizen of Metro\u2019s API, there is no <code>@MergeComponent</code> annotation like in Anvil. Instead, <code>@DependencyGraph</code> defines which contribution scope it supports directly.</p> <pre><code>@DependencyGraph(scope = AppScope::class)\ninterface AppGraph\n</code></pre> <p>When a graph declares a <code>scope</code>, all contributions to that scope are aggregated into the final graph implementation in code gen.</p> <p>If a graph supports multiple scopes, use <code>additionalScopes</code>.</p> <pre><code>@DependencyGraph(\n  AppScope::class,\n  additionalScopes = [LoggedOutScope::class]\n)\ninterface AppGraph\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@DependencyGraph</code> supports excluding contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(\n  scope = AppScope::class,\n  excludes = [RealNetworkProviders::class]\n)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class)\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesto","title":"@ContributesTo","text":"<p>This annotation is used to contribute graph interfaces to the target scope to be merged in at graph-processing time to the final merged graph class as another supertype.</p> <pre><code>@ContributesTo(AppScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesTo(AppScope::class)\n@ContributesTo(LoggedInScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@ContributesBinding</code> (as well as the other <code>@Contributes*</code> annotations) supports replacing other contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class, replaces = [RealNetworkProviders::class])\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesbinding","title":"@ContributesBinding","text":"<p>This annotation is used to contribute injected classes to a target scope as a given bound type.</p> <p>The below example will contribute the <code>CacheImpl</code> class as a <code>Cache</code> type to <code>AppScope</code>.</p> <pre><code>@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For simple cases where there is a single supertype, that type is implicitly used as the bound type. If your bound type is qualified, for the implicit case you can put the qualifier on the class.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For classes with multiple supertypes or advanced cases where you want to bind an ancestor type, you can explicitly define this via <code>binding</code> parameter.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Whoa, is that a function call in an annotation argument? Nope! <code>binding</code> is just a decapitalized class in this case, intentionally designed for readability. It\u2019s an adjective in this context and the functional syntax better conveys that.</p> <p>Note that the bound type is defined as the type argument to <code>@ContributesBinding</code>. This allows for the bound type to be generic and is validated in FIR.</p> <p>Qualifier annotations can also be specified on the <code>binding</code> type parameter and will take precedence over any qualifiers on the class itself.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;@Named(\"cache\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;AnotherType&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Contributions may be <code>object</code> classes. In this event, Metro will automatically provide the object instance in its binding.</p>"},{"location":"aggregation/#contributesintosetcontributesintomap","title":"@ContributesIntoSet/@ContributesIntoMap","text":"<p>To contribute into a multibinding, use the <code>@ContributesIntoSet</code> or <code>@ContributesIntoMap</code> annotations as needed.</p> <pre><code>@ContributesIntoSet(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>Same rules around qualifiers and <code>binding()</code> apply in this scenario</p> <p>To contribute into a Map multibinding, the map key annotation must be specified on the class or <code>binding</code> type argument.</p> <pre><code>// Will be contributed into a Map multibinding with @StringKey(\"Networking\")\n@ContributesIntoMap(AppScope::class)\n@StringKey(\"Networking\")\n@Inject\nclass CacheImpl(...) : Cache\n\n// Or if using binding\n@ContributesIntoMap(\n  scope = AppScope::class,\n  binding = binding&lt;@StringKey(\"Networking\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>This annotation is also repeatable and can be used to contribute to multiple scopes, multiple bound types, and multiple map keys.</p>"},{"location":"aggregation/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers (see Binding Containers) can also be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"aggregation/#replacing-contributed-binding-containers","title":"Replacing Contributed Binding Containers","text":"<p>Similar to other contribution types, binding containers can replace other contributed binding containers:</p> <pre><code>// In production\n@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n// In tests\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre>"},{"location":"aggregation/#excluding-contributed-binding-containers","title":"Excluding Contributed Binding Containers","text":"<p>Graphs can exclude specific contributed binding containers:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface TestAppGraph {\n  // NetworkBindings will not be included\n}\n</code></pre> <p>Info</p> <p>Currently, contributed binding containers cannot replace non-contributed-container types (i.e. <code>@ContributesBinding</code> classes) yet.</p>"},{"location":"aggregation/#contributesgraphextension","title":"<code>@ContributesGraphExtension</code>","text":"<p><code>@ContributesGraphExtension</code> is a specialized type of graph that is contributed to some parent scope. Its generation is deferred until the parent graph interface is merged.</p> <p>See Dependency Graphs for motivation and documentation.</p>"},{"location":"aggregation/#implementation-notes","title":"Implementation notes","text":"<p>This leans on Kotlin\u2019s ability to put generic type parameters on annotations. That in turn allows for both generic bound types and to contribute map bindings to multiple map keys.</p> <p>Because it\u2019s a first-party feature, there\u2019s no need for intermediary \u201cmerged\u201d components like kotlin-inject-anvil and anvil-ksp do.</p> <p>Generated contributing interfaces are generated to the <code>metro.hints</code> package and located during graph supertype generation in FIR downstream. Any contributed bindings are implemented as <code>@Binds</code> (\u00b1 IntoSet/IntoMap/etc) annotated properties.</p>"},{"location":"bindings/","title":"Bindings","text":""},{"location":"bindings/#qualifiers","title":"Qualifiers","text":"<p>Like Dagger and KI, Metro supports qualifier annotations to allow disambiguation of types. These are applied at injection and provision sites. A qualifier annotation is any annotation annotated with <code>@Qualifier</code>. For convenience, there is an included <code>@Named</code> qualifier available in Metro\u2019s runtime that can be used too.</p> <p>A \u201ctype key\u201d in Metro is composed of a concrete type and (if any) qualifier annotation attached to it.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val int: Int\n  @Named(\"named\") val namedInt: Int\n\n  @Provides\n  fun provideInt(): Int = 3\n\n  @Provides\n  @Named(\"named\")\n  fun provideNamedInt(): Int = 4\n}\n</code></pre>"},{"location":"bindings/#binds","title":"@Binds","text":"<p>In many cases, a developer may have an implementation type on the graph that they want to expose as just its supertype.</p> <p>Like Dagger, Metro supports this with <code>@Binds</code>.</p> <p>For these cases, an abstract provider can be specified with the following conditions.</p> <ul> <li>It must be abstract</li> <li>It must define one extension receiver that is a subtype of its provided type</li> </ul> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: Message\n\n  // Bind MessageImpl as Message\n  @Binds val MessageImpl.bind: Message\n\n  @Provides\n  fun provideText(): String = \"Hello, world!\"\n}\n\n@Inject\nclass MessageImpl(val text: String) : Message\n</code></pre> <p>If you want to limit access to these from your API, you can make these declarations <code>private</code> and just return <code>this</code>. Note it\u2019s still important to annotate them with <code>@Binds</code> so that the Metro compiler understands its intent! Otherwise, it\u2019s an error to implement these declarations.</p> <p><code>@Binds</code> declarations can also declare multibinding annotations.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val messages: Message\n\n  @Binds @IntoSet val MessageImpl.bind: Message\n}\n</code></pre> <p><code>@Binds</code> declarations may also be declared in binding Containers.</p> <p>Note</p> <p>In theory, you can implement a provider with a getter that replicates this (similar to how kotlin-inject uses <code>@get:Provider</code> + <code>this</code>), but this will be an error in FIR because Metro can generate more efficient code at compile-time if you use <code>@Binds</code>. This is because Metro can avoid calling the function entirely and just use this information at compile-time to optimize the generated code.</p>"},{"location":"bindings/#multibindings","title":"Multibindings","text":"<p>Like Dagger and KI, Metro supports <code>Set</code> and <code>Map</code> multibindings. Multibindings are collections of bindings of a common type. Multibindings are implicitly declared by the existence of providers annotated with <code>@IntoSet</code>, <code>@IntoMap</code>, or <code>@ElementsIntoSet</code>.</p> <pre><code>@DependencyGraph\ninterface SetMultibinding {\n  // contains a set of [1, 2, 3, 4]\n  val ints: Set&lt;Int&gt;\n\n  @Provides @IntoSet fun provideInt1() = 1\n\n  @Provides @IntoSet fun provideInt2() = 2\n\n  @Provides\n  @ElementsIntoSet\n  fun provideInts() = setOf(3, 4)\n}\n</code></pre> <p>Map multibindings use <code>@IntoMap</code> and require a map key annotation. Map keys are any annotation annotated with <code>@MapKey</code>. Metro\u2019s runtime includes a number of common ones like <code>@ClassKey</code> and <code>@StringKey</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  // contains a map of {1:1, 2:2}\n  val ints: Map&lt;Int, Int&gt;\n\n  @Provides\n  @IntoMap\n  @IntKey(1)\n  fun provideInt1() = 1\n\n  @Provides\n  @IntoMap\n  @MapKey(2)\n  fun provideInt2() = 2\n}\n</code></pre> <p>Alternatively, they can be declared with an <code>@Multibinds</code>-annotated accessor property/function in a component. This member will be implemented by the Metro compiler and is useful for scenarios where the multibinding may be empty.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinds\n  val ints: Map&lt;Int, Int&gt;\n}\n</code></pre> <p>Multibinding collections are immutable at runtime and cannot be defined as mutable at request sites.</p> <p>Map multibindings support injecting map providers, where the value type can be wrapped in <code>Provider</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinds\n  val ints: Map&lt;Int, Provider&lt;Int&gt;&gt;\n}\n</code></pre> <p>Unlike Dagger, empty multibindings in Metro are a compile error by default. Empty multibindings are allowed but must be opted into via <code>@Multibinds(allowEmpty = true)</code>.</p>"},{"location":"bindings/#implementation-notes","title":"Implementation notes","text":"<p>Metro takes inspiration from Guice in handling these in the binding graph. Since they cannot be added directly to the graph as-is (otherwise they would cause duplicate binding errors), a synthetic <code>@MultibindingElement</code> qualifier annotation is generated for them at compile-time to disambiguate them. These are user-invisible but allows them to participate directly in graph validation like any other dependency. Metro then just adds these bindings as dependencies to <code>Binding.Multibinding</code> types.</p>"},{"location":"bindings/#optional-dependencies","title":"Optional Dependencies","text":"<p>Metro supports optional dependencies by leaning on Kotlin\u2019s native support for default parameter values. These are checked at injection sites and are allowed to be missing from the dependency graph when performing a lookup at validation/code-gen time.</p> <p>The below example would, since there is no <code>Int</code> binding provided, provide a message of <code>Count: -1</code>.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(count: Int = -1) = \"Count: $count\"\n}\n</code></pre> <p>Dagger supports a similar feature via <code>@BindsOptionalOf</code>, but requires a separate declaration of this optional dependency to the graph.</p> <p>KI supports the same feature.</p>"},{"location":"bindings/#nullability","title":"Nullability","text":"<p>As nullability is a first-class concept in Kotlin, Metro supports it too. Bindings in Metro graphs may be nullable, but it\u2019s important to understand how Metro treats them!</p> <p>In short, Metro will treat nullable types as different type keys than their non-nullable analogues. That is to say, <code>String</code> and <code>String?</code> are treated as distinct types in Metro.</p> <p>Furthermore, a <code>String</code> binding cannot satisfy a <code>String?</code> automatically. You may however <code>@Binds</code> a <code>String</code> to a <code>String?</code> and Metro will treat it as a valid binding.</p> <pre><code>@DependencyGraph(Unit::class, isExtendable = true)\ninterface ExampleGraph {\n  val int: Int\n  val nullableInt: Int?\n\n  @Provides\n  fun provideInt(): Int = 1\n\n  @Binds\n  val Int.bindAsNullable: Int?\n}\n</code></pre>"},{"location":"bindings/#implementation-notes_1","title":"Implementation notes","text":"<p>While kotlin-inject can support this by simply invoking functions with omitted arguments, Metro has to support this in generated factories.</p> <p>To accomplish this, Metro will slightly modify how generated provider/constructor injection factory classes look compared to Dagger. Since we are working in IR, we can copy the default value expressions from the source function/constructor to the factory\u2019s newInstance and create() functions. This in turn allows calling generated graphs to simply omit absent binding arguments from their creation calls. This is a tried and tested pattern used by other first party plugins, namely kotlinx-serialization.</p> <p>There are a few cases that need to be handled here:</p> <ul> <li>Expressions may reference previous parameters or instance members. To support this, we\u2019ll transform them in IR to point at new parameters in those functions.</li> <li>Expressions may reference private instance members. To support this, Metro factories are generated as nested classes within the source class or graph.<ul> <li>This does depart from how dagger factories work, but if we ever wanted to have some sort of interop for that we could always generate bridging factory classes in the places dagger expects later.</li> </ul> </li> <li>Parameters in <code>create()</code> need to be wrapped in <code>Provider</code> calls. This means that for cases where they back-reference other parameters, those will need to be transformed into <code>invoke()</code> calls on those providers too.</li> </ul>"},{"location":"compatibility/","title":"Kotlin Compatibility","text":"<p>The Kotlin compiler plugin API is not a stable API, so not every version of Metro will work with every version of the Kotlin compiler.</p> Kotlin version Metro version 2.2.0 0.4.0 - 2.1.21 0.3.1 - 0.3.8 2.1.20 0.1.2 - 0.3.0"},{"location":"debugging/","title":"Debugging","text":"<p>One major downside to generating IR directly is that developers cannot step into generated source code with the debugger. This is an accepted trade-off with Metro (or any other compiler plugin).</p> <p>Metro does offer a <code>debug</code> option in its plugin options/Gradle extension that will print verbose Kotlin pseudocode for all generated IR classes. This can be further tuned to print just certain classes.</p> <pre><code>metro {\n  debug.set(true)\n}\n</code></pre> <p>In the future, we could possibly explore including information in IR to synthesize call stack information similar to coroutines, but will save that for if/when it\u2019s asked for.</p>"},{"location":"debugging/#reports","title":"Reports","text":"<p>Similar to Compose, Metro supports a <code>reportsDestination</code> property in its Gradle DSL and can output various graph reports to this destination if specified. This is very much a WIP, feedback is welcome!</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre>"},{"location":"dependency-graphs/","title":"Dependency Graphs","text":"<p>The primary entry points in Metro are dependency graphs. These are interfaces annotated with <code>@DependencyGraph</code> and created with <code>@DependencyGraph.Factory</code> interfaces. Graphs expose types from the object graph via accessor properties or functions.</p> <p>Tip</p> <p>These are synonymous with components and <code>@Component</code>/<code>@Component.Factory</code> in Dagger and kotlin-inject.</p> <p>Tip</p> <p>\u201cAccessors\u201d in Metro are synonymous with Dagger\u2019s provision methods.</p> <p>Accessors and member injections act as roots, from which the dependency graph is resolved. Dependencies can be provided via conventional <code>@Provides</code> functions in graphs or their supertypes, constructor-injected classes, or accessed from graph dependencies.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides\n  fun provideMessage(): String = \"Hello, world!\"\n}\n</code></pre> <p>Note the <code>@Provides</code> function must define an explicit return type.</p> <p>Simple graphs like this can be created via the <code>createGraph()</code> intrinsic.</p> <pre><code>val graph = createGraph&lt;AppGraph&gt;()\n</code></pre> <p>Graphs are relatively cheap and should be used freely.</p>"},{"location":"dependency-graphs/#inputs","title":"Inputs","text":"<p>Runtime inputs can be provided via a <code>@DependencyGraph.Factory</code> interface that returns the target graph. These parameters must be annotated with exactly one of <code>@Provides</code>, <code>@Includes</code>, or <code>@Extends</code>.</p>"},{"location":"dependency-graphs/#provides","title":"Provides","text":"<p>The simplest input is an instance parameter annotated with <code>@Provides</code>. This provides this instance as an available binding on the graph.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n</code></pre> <p>Provided parameters may be any type.</p> <p>Tip</p> <p>This is analogous to Dagger\u2019s <code>@BindsInstance</code>.</p>"},{"location":"dependency-graphs/#includes","title":"Includes","text":"<p><code>@Includes</code>-annotated parameters are treated as containers of available bindings. Metro will treat accessors of these types as usable dependencies.</p> <p>They are commonly other graph types whose\u2019 dependencies you want to consume via explicit API.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageGraph: MessageGraph): AppGraph\n  }\n\n  @DependencyGraph interface MessageGraph {\n    val message: String\n\n    @Provides fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre> <p><code>@Includes</code> instance dependencies do not need to be other graphs though! They can be any regular class type. They cannot be enums or annotation classes.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageProvider: MessageProvider): AppGraph\n  }\n\n  interface MessageProvider {\n    val message: String\n  }\n}\n</code></pre> <p>Warning</p> <p>Includes parameters cannot be injected from the graph.</p> <p>Binding Containers are a special type of <code>@Includes</code> type, see more in its section below.</p>"},{"location":"dependency-graphs/#extends","title":"Extends","text":"<p><code>@Extends</code>-annotated parameters are for extending parent graphs. See Graph Extensions at the bottom of this doc for more information.</p>"},{"location":"dependency-graphs/#creating-factories","title":"Creating factories","text":"<p>Graph factories can be created with the <code>createGraphFactory()</code> intrinsic.</p> <pre><code>val messageGraph =\n  createGraphFactory&lt;AppGraph.Factory&gt;()\n    .create(\"Hello, world!\")\n</code></pre>"},{"location":"dependency-graphs/#scoping","title":"Scoping","text":"<p>See Scopes for more details on scopes!</p> <p>Graphs may declare a <code>scope</code> (and optionally <code>additionalScopes</code> if there are more). Each of these declared scopes act as an implicit <code>@SingleIn</code> representation of that scope for aggregation.</p> <p>For example: <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre></p> <p>Is functionally equivalent to writing the below.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#graph-extensions","title":"Graph Extensions","text":"<p>Dependency graphs can be marked as extendable to allow child graphs to extend them. These are similar in functionality to Dagger\u2019s <code>Subcomponents</code> but are detached in nature like in kotlin-inject.</p> <p>A graph must opt itself into extension in via <code>@DependencyGraph(..., isExtendable = true)</code>, which will make the Metro compiler generate extra metadata for downstream child graphs.</p> <p>Then, a child graph can add an <code>@Extends</code>-annotated parameter to its creator to extend that graph.</p> <pre><code>@DependencyGraph(isExtendable = true)\ninterface AppGraph {\n  @Provides fun provideHttpClient(): HttpClient { ... }\n}\n\n@DependencyGraph\ninterface UserGraph {\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Extends appGraph: AppGraph): UserGraph\n  }\n}\n</code></pre> <p>Child graphs then contain a superset of bindings they can inject, including both their bindings and their parents\u2019. Graph extensions can be chained as well.</p> <p>Child graphs also implicitly inherit their parents\u2019 scopes.</p> <p>Hoisting unused scoped class injections in parent graphs</p> <p>In some cases, there are scoped bindings that are unused in the parent graph but are used in child graphs. Due to the detached nature of graph extensions, these bindings by default end up scoped to the child. To enforce that these bindings are scoped and held by the parent, Metro generates hints for these classes and discovers them during graph processing by default. You can disable this via the <code>enableScopedInjectClassHints</code> property in the Gradle DSL.</p> <p>See https://github.com/ZacSweers/metro/issues/377 for more details.</p>"},{"location":"dependency-graphs/#contributed-graph-extensions","title":"Contributed Graph Extensions","text":"<p><code>@ContributesGraphExtension</code> is a specialized type of graph that is contributed to some parent scope. Its generation is deferred until the parent graph interface is merged.</p>"},{"location":"dependency-graphs/#the-problem","title":"The Problem","text":"<p>Imagine this module dependency tree:</p> <pre><code>        :app\n      /     \\\n     v       v\n  :login   :user-data\n</code></pre> <p><code>:app</code> defines the main dependency graph with <code>@DependencyGraph</code>. The <code>:login</code> module defines a graph extension for authenticated user flows, and <code>:user-data</code> provides some core functionality like <code>UserRepository</code>.</p> <p>If <code>:login</code> defines its own graph directly with <code>@DependencyGraph</code>, it won\u2019t see contributions from <code>:user-data</code> unless <code>:login</code> depends on it directly.</p>"},{"location":"dependency-graphs/#the-solution","title":"The Solution","text":"<p>Instead, <code>:login</code> can use <code>@ContributesGraphExtension(LoggedInScope::class)</code> + an associated <code>@ContributesGraphExtension.Factory(AppScope::class)</code> to say: \u201cI want to contribute a new graph extension to a future <code>AppScope</code> parent graph.\u201d</p> <p>The graph extension will then be generated in <code>:app</code>, which already depends on both <code>:login</code> and <code>:user-data</code>. Now <code>UserRepository</code> can be injected in <code>LoggedInGraph</code>.</p> <pre><code>@ContributesGraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n\n  val userRepository: UserRepository\n\n  @ContributesGraphExtension.Factory(AppScope::class)\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n</code></pre> <p>In the <code>:app</code> module:</p> <pre><code>@DependencyGraph(AppScope::class, isExtendable = true)\ninterface AppGraph\n</code></pre> <p>The generated code will modify <code>AppGraph</code> to implement <code>LoggedInGraph.Factory</code> and implement <code>createLoggedInGraph()</code> using a generated final <code>$$ContributedLoggedInGraph</code> class that includes all contributed bindings, including <code>UserRepository</code> from <code>:user-data</code>.</p> <pre><code>interface AppGraph \n  // modifications generated during compile-time\n  : LoggedInGraph.Factory {\n  override fun createLoggedInGraph(): LoggedInGraph {\n    return $$ContributedLoggedInGraph(this)\n  }\n\n  // Generated in IR\n  @DependencyGraph(LoggedInScope::class)\n  class LoggedInGraph$$MetroGraph(appGraph: AppGraph) : LoggedInGraph {\n    // ...\n  }\n}\n</code></pre> <p>Finally, you can obtain a <code>LoggedInGraph</code> instance from <code>AppGraph</code> since it now implements <code>LoggedInGraph.Factory</code>:</p> <pre><code>// Using the asContribution() intrinsic\nval loggedInGraph = appGraph.asContribution&lt;LoggedInGraph.Factory&gt;().createLoggedInGraph()\n\n// Or if you have IDE support enabled\nval loggedInGraph = appGraph.createLoggedInGraph()\n</code></pre>"},{"location":"dependency-graphs/#graph-arguments","title":"Graph arguments","text":"<p>You can pass arguments to the graph via the factory:</p> <pre><code>@ContributesGraphExtension.Factory(AppScope::class)\ninterface Factory {\n  fun create(@Provides userId: String): LoggedInGraph\n}\n</code></pre> <p>This maps to:</p> <pre><code>// Generated in IR\n@DependencyGraph(LoggedInScope::class)\nclass $$ContributedLoggedInGraph(\n  @Extends parent: AppGraph,\n  @Provides userId: String\n): LoggedInGraph {\n  // ...\n}\n</code></pre> <p>In <code>AppGraph</code>, the generated factory method looks like:</p> <pre><code>// Generated in IR\noverride fun create(userId: String): LoggedInGraph {\n  return LoggedInGraph$$MetroGraph(this, userId)\n}\n</code></pre> <p>Warning</p> <p>Abstract factory classes cannot be used as graph contributions.</p> <p>Contributed graphs may also be chained, but note that <code>@ContributesGraphExtension.isExtendable</code> must be true to do so!</p>"},{"location":"dependency-graphs/#binding-containers","title":"Binding Containers","text":"<p>Binding containers are classes, objects, or interfaces annotated with <code>@BindingContainer</code> that contain binding declarations (<code>@Provides</code> or <code>@Binds</code>) but are not themselves complete dependency graphs. They\u2019re analogous to Dagger\u2019s <code>@Module</code> annotation and can be used in cases where defining bindings in an (extended) interface is unwieldy or not helpful.</p> <p>Unlike graphs and other <code>@Includes</code> types, their public accessors are not read. Only <code>@Binds</code> and <code>@Provides</code> declarations are read.</p> <p>Tip</p> <p>Binding containers can be seen as partial graphs and are intended to be reusable, composable units that are included in a complete graph.</p>"},{"location":"dependency-graphs/#including-via-includes-parameters","title":"Including via <code>@Includes</code> Parameters","text":"<p>The most flexible way to include binding containers is via <code>@Includes</code>-annotated parameters on graph factories.</p> <pre><code>@BindingContainer\nclass NetworkBindings(private val baseUrl: String) {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(baseUrl)\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val httpClient: HttpClient\n\n  @DependencyGraph.Factory\n  interface Factory {\n    fun create(@Includes networkBindings: NetworkBindings): AppGraph\n  }\n}\n</code></pre> <p>This allows you to bring any instance to the graph with its own internal logic.</p>"},{"location":"dependency-graphs/#including-via-dependencygraphbindingcontainers","title":"Including via <code>@DependencyGraph.bindingContainers</code>","text":"<p>For simple binding containers, you can declare them directly in the graph annotation:</p> <pre><code>@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>This method works for:</p> <ul> <li><code>object</code> classes</li> <li><code>interface</code> or <code>abstract class</code> types with only <code>@Binds</code> providers or companion object <code>@Provides</code> providers</li> <li>Simple classes with a public, no-arg constructor</li> </ul>"},{"location":"dependency-graphs/#chaining-binding-containers","title":"Chaining Binding Containers","text":"<p>Binding containers can include other binding containers using the <code>includes</code> parameter:</p> <pre><code>@BindingContainer\nobject CacheBindings {\n  @Provides fun provideHttpCache(): Cache = Cache()\n}\n\n@BindingContainer(includes = [CacheBindings::class])\nobject NetworkBindings {\n  @Provides fun provideHttpClient(cache: Cache): HttpClient = HttpClient(cache)\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>The transitive closure of all included binding containers will be included in the final consuming graph.</p>"},{"location":"dependency-graphs/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers can be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>They can also replace other contributed binding containers:</p> <pre><code>// In a test variant\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre> <p>Graphs may exclude contributed containers:</p> <pre><code>@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"dependency-graphs/#notes","title":"Notes","text":"<ul> <li>Companion objects, annotation classes, and enum classes/entries cannot be annotated with <code>@BindingContainer</code>.</li> <li>Provides within a binding container\u2019s companion object are automatically included.</li> <li>Enclosing classes of <code>@Binds</code> or <code>@Provides</code> providers don\u2019t need to be annotated with <code>@BindingContainer</code> for Metro to process them - the annotation is primarily for reference to <code>@DependencyGraph.Factory</code> and the ability to use <code>includes</code>.</li> <li>Binding containers may also be contributed.</li> <li>See #172 for more details.</li> </ul>"},{"location":"dependency-graphs/#implementation-notes","title":"Implementation Notes","text":"<p>Dependency graph code gen is designed to largely match how Dagger components are generated.</p> <ul> <li>Internal graph validation uses Tarjan\u2019s algorithm + topological sort implementation.</li> <li>This runs in O(V+E) time</li> <li>The returned ordered list of bindings can be used to determine provider field generation order.</li> <li>Any binding whose order depends on one later in the returned order implicitly requires use of <code>DelegateFactory</code>.</li> <li>Dependencies are traversed from public accessors and <code>inject()</code> functions.</li> <li>Metro generates Provider Factory classes for each provider. These should be generated at the same time that the provider is compiled so that their factory classes. This is for two primary purposes:<ul> <li>They can be reused to avoid code duplication</li> <li>Metro can copy default values for provider values over to the generated factory to support optional bindings. Since default values may refer to private references, we must generate these factories as nested classes.</li> </ul> </li> <li>Metro generates a graph impl class that holds all aggregated bindings and manages scoping.</li> <li>Scoped bindings are stored in provider fields backed by <code>DoubleCheck</code>.</li> <li>Reused unscoped providers instances are stored in reusable fields.</li> <li><code>@Provides</code> factory parameters are stored in a field backed by <code>InstanceFactory</code>.</li> <li>Multibindings create new collection instances every time.</li> <li>Multibinding providers are not accessible as standalone bindings.</li> <li>Graph extensions are implemented via a combination of things<ul> <li>Custom <code>MetroMetadata</code> is generated and serialized into Kotlin\u2019s <code>Metadata</code> annotations.</li> <li>Extendable parent graphs opt-in to generating this metadata. They write information about their available provider and instance fields, binds callable IDs, parent graphs, and provides callable IDs.</li> <li>Extendable parent graphs generate <code>_metroAccessor</code>-suffixed <code>internal</code> functions that expose instance fields and provider fields.</li> <li>Child graphs read this metadata and look up the relevant callable symbols, then incorporating these when building its own binding graph.</li> </ul> </li> </ul>"},{"location":"differences/","title":"Differences from other DI frameworks","text":"DaggerKotlin-InjectAnvilkotlin-inject-anvil <ul> <li><code>@Binds</code> and <code>@Provides</code> declarations can be added directly within graphs and their supertypes.<ul> <li><code>@BindingContainer</code> is the Metro equivalent of a Dagger <code>@Module</code> but it should rarely be used.</li> <li><code>@BindingContainer</code> cannot declare graph extensions in the way <code>@Module</code> can declare subcomponents. Use <code>@ContributesGraphExtension</code>.</li> </ul> </li> <li>There is no Producers support.</li> <li>There is no Hilt support, though some features are similar in the same way that Anvil\u2019s features are similar.</li> <li>There is no <code>@Reusable</code>.</li> <li>There is no <code>@BindsOptionalOf</code>. Instead, Metro supports default optional dependencies.</li> <li>There is no <code>@Subcomponent</code>. Instead, Metro uses graph extensions.</li> <li>Metro can inject private properties and functions.</li> <li>There is no <code>@BindsInstance</code>. Use <code>@Provides</code> on <code>@DependencyGraph.Factory</code> function parameters instead</li> <li>Component dependencies must be annotated with <code>@Includes</code>.</li> <li>Metro does not process Java code.</li> <li><code>@Multibinds</code> declarations are implemented in Metro graphs to return the declared multibinding.</li> <li>Empty multibindings are an error by default in Metro. To allow a multibinding to be empty, it must be declared with <code>@Multibinds(allowEmpty = true)</code>.</li> <li>Metro graph classes may not directly extend other graph classes. You should use <code>@Extends</code> instead in Metro.</li> <li>Dagger technically allows this, but only accessors and injectors cross these boundaries.</li> </ul> <ul> <li>typealiases are not treated as implicit qualifiers.</li> <li>Dependency graph classes cannot have primary constructors, their parameters must be defined as <code>@Provides</code> or graph parameters on a <code>@DependencyGraph.Factory</code> function like Dagger.</li> <li>Higher order functions cannot be used. Instead, use <code>Provider</code> and declared <code>@AssistedFactory</code>-annotated types.</li> <li>No need for use-site targets for most annotations.</li> <li>No need for <code>@get:Provides Impl.bind: Type get() = this</code> to achieve type bindings. See the docs on <code>@Binds</code>.</li> <li>Metro can inject private properties and functions.</li> <li>When extending parent graphs, they must be annotated with <code>@Extends</code> in the child graph\u2019s creator.</li> <li>Metro does not process Java code.</li> <li>Metro does not support assisted parameters in <code>@Provides</code> functions.</li> <li>Metro map multibindings use static map keys rather than aggregating via <code>Pair</code> contributions. More details on why can be found here.</li> </ul> <ul> <li>There is no <code>rank</code> in Metro\u2019s <code>@Contributes*</code> annotations.<ul> <li>Note that if Anvil interop is enabled, its <code>rank</code> properties are supported in interop.</li> </ul> </li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> </ul> <ul> <li>There is no need for <code>@CreateComponent</code> or <code>expect fun createComponent()</code> functions.</li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>This is a list of frequently asked questions about Metro. Consider also searching the issue tracker and discussions section of the Metro repo for anything not covered here!</p>"},{"location":"faq/#compiler-plugins-are-not-a-stable-api-is-metro-safe-to-use","title":"Compiler plugins are not a stable API, is Metro safe to use?","text":"<p>This is a fair question! Metro will often require new companion releases for each Kotlin release. This is a part of life when using compiler plugins. That said, Kotlin does extensive beta/RC cycles that Metro will test against and turn around new releases within a day or two barring any unexpected circumstances (or vacation!)</p> <p>The harder issue is going to be IDE support, as the Kotlin IDE plugin branches independently from regular Kotlin releases. Right now the answer is \u201cYMMV\u201d, but we\u2019re exploring a couple solutions for this to ensure better stability.</p>"},{"location":"faq/#will-metro-add-support-for-hilt-features-or-hilt-interop","title":"Will Metro add support for Hilt features or Hilt interop?","text":"<p>Metro is largely inspired by Dagger and Anvil, but not Hilt. Hilt works in different ways and has different goals. Hilt is largely focused around supporting android components and relies heavily on subcomponents to achieve this.</p> <p>Some features overlap but just work differently in Metro:</p> <ul> <li>Instead of <code>@UninstallModules</code> and <code>@TestInstallIn</code>, Metro graphs can exclude aggregations and contributed bindings can replace other bindings.</li> <li>Hilt has support for injecting <code>ViewModel</code>s, but this is entirely doable without Hilt as well by just creating a multibinding. See the android-app sample for an example.</li> <li>Hilt has support for aggregation with <code>@InstallIn</code>, Metro uses <code>@Contributes*</code> annotations.</li> </ul> <p>Some features are focused around injecting Android framework components. There are two arguably better solutions to this and one not-better solution.</p> <ol> <li>(Not better) Expose injector functions on a graph to do member injection directly from the graph.</li> <li>(Better) Constructor-inject these types using <code>AppComponentFactory</code>. This does require minSdk 28. When Hilt was first released in 2020, this was a relatively new API. However, 2020 was a long time ago! minSdk 28+ is much more common today, making this much more feasible of a solution.</li> <li>(Best) Use an app architecture that better abstracts away the surrounding Android framework components, making them solely entry points.</li> </ol> <p>The rest of Hilt\u2019s features focus on gluing these pieces together and also supporting Java (which Metro doesn\u2019t support).</p>"},{"location":"faq/#why-doesnt-metro-support-reusable","title":"Why doesn\u2019t Metro support <code>@Reusable</code>?","text":"<p>Some technical context</p> <p><code>@Reusable</code> works almost identically in code gen as scoped types, it just uses <code>SingleCheck</code> instead of <code>DoubleCheck</code>. It\u2019s basically like using <code>lazy(NONE)</code> instead of <code>lazy(SYNCHRONIZED)</code>.</p> <p>A few different reasons Metro doesn\u2019t have it</p> <ul> <li>I think it risks being like <code>@Stable</code> in compose where people chase it for perceived performance benefits that they have not profiled or would not actualize if they did. Basically it becomes a premature optimization vector<ul> <li>Ron Shapiro (the author of it) even said you shouldn\u2019t use it or scoping in general [for performance reasons] unless you\u2019ve measured it: https://medium.com/@shapiro.rd/reusable-has-many-of-the-same-costs-as-singleton-c20b5d1ef308</li> </ul> </li> <li>Most people don\u2019t really know when to use it. It doesn\u2019t really strike a balance so much as blurs the line for limited value (see: the first bullet).</li> <li>It invites people to make unclear assumptions. It\u2019s pretty simple to assume something stateful is always a new instance or always the same scoped instance. It is harder to envision scenarios where you have stateful types where you don\u2019t care about knowing if it\u2019s shared or not. You could say this should only be for stateless types then, but then you\u2019re deciding\u2026<ul> <li>Do you want to limit instances? Just scope it</li> <li>Do you not care about limiting instances? Don\u2019t scope it</li> </ul> </li> <li>What\u2019s the expected behavior if you have a <code>@Reusable</code> type <code>Thing</code> and then request a <code>Lazy&lt;Thing&gt;</code> elsewhere? Currently, Metro <code>DoubleCheck.lazy(...)</code>\u2019s whatever binding provides it at the injection site, which would then defeat this. To undo that, Metro would need to introduce some means of indicating \u201cwhat kind\u201d of <code>Lazy</code> is needed, which just complicates things for the developer.</li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#familiar-semantics","title":"Familiar semantics","text":"<p>Metro builds on top of established patterns from existing DI frameworks with familiar semantics like constructor injection, providers, multibindings, scopes, assisted injection, and intrinsics like Provider/Lazy.</p>"},{"location":"features/#compile-time-validation","title":"Compile-time validation","text":"<p>Like Dagger and KI, Metro validates your dependency graph at compile-time.</p>"},{"location":"features/#compile-time-firir-code-gen","title":"Compile-time FIR+IR code gen","text":"<p>Metro is implemented entirely as a Kotlin compiler plugin, primarily using FIR for error reporting and both FIR and IR for code gen. This affords significant build performance and wins compared to Dagger and KAPT/KSP in two ways:</p> <ul> <li>It avoids extra Kotlin compiler (frontend) invocations to analyze sources and generate new sources.</li> <li>It generates new code to FIR/IR directly, allowing it to be lowered directly into target platforms</li> </ul> <p>FIR/IR generation allows Metro to generate code directly into existing classes, which in turn allows it to do certain things that source-generation cannot. This includes:</p> <ul> <li>Private <code>@Provides</code> declarations.</li> <li>Injection of private member properties and functions.</li> <li>Copying + reuse of default value expressions for optional dependencies, even if they reference private APIs within the source class.</li> </ul>"},{"location":"features/#dagger-esque-code-gen-and-runtime","title":"Dagger-esque code gen and runtime","text":"<ul> <li>Metro\u2019s generated code is similar to Dagger: lean, limited duplication, and practical.</li> <li>Metro\u2019s runtime is similar to Dagger. This includes patterns like <code>DoubleCheck</code>, heavy use of factories, and an assumption that this is going to run in a large/modularized codebase.</li> </ul>"},{"location":"features/#kotlin-inject-esque-api","title":"Kotlin-Inject-esque API","text":"<p>Metro\u2019s user-facing API is similar to kotlin-inject: focused on simplicity and leaning into kotlin-language features.</p> <ul> <li>Top-level function injection</li> <li>Providers live in graph interfaces or supertypes</li> <li>Native support for optional bindings via default parameter values</li> <li>Use of Kotlin\u2019s native <code>Lazy</code> type for lazy injections</li> </ul>"},{"location":"features/#anvil-esque-aggregation","title":"Anvil-esque aggregation","text":"<p>Like Anvil, Metro supports contributing types via aggregation with annotations like <code>@ContributesTo</code>, <code>@ContributesBinding</code>, etc.</p>"},{"location":"features/#multiplatform","title":"Multiplatform","text":"<p>Metro is multiplatform and supports most major Kotlin multiplatform targets.</p> <p>Warning</p> <p>Multi-module multiplatform targets cannot contribute dependencies (i.e. with <code>@Contributes*</code> annotations) from native targets until https://youtrack.jetbrains.com/issue/KT-75865.</p>"},{"location":"features/#ide-integration","title":"IDE Integration","text":"<p>Most errors are reported in FIR, which should (eventually) be visible in the K2 IDE plugin as well.</p>"},{"location":"features/#helpful-diagnostics","title":"Helpful diagnostics","text":"<p>Metro tries its best to give detailed-yet-readable error messages and diagnostics.</p> <pre><code>e: ExampleGraph.kt:8:3 [Metro/MissingBinding] Cannot find an @Inject constructor or @Provides-annotated function/property for: kotlin.Int\n\n    kotlin.Int is requested at\n        [test.ExampleGraph] test.ExampleGraph.int\n\nSimilar bindings:\n  - @Named(\"qualified\") Int (Different qualifier). Type: Provided. Source: ExampleGraph.kt:11:3\n  - Number (Supertype). Type: Provided. Source: ExampleGraph.kt:10:3\n  - Set&lt;Int&gt; (Multibinding). Type: Multibinding.\n</code></pre> <p>For more thorough debugging, Metro also has controls to enable debug logging controls and write graph reports to an output directory (configurable via the Gradle extension).</p>"},{"location":"features/#advanced-interop","title":"Advanced interop","text":"<p>Metro has advanced interop with existing DI tools.</p> <ul> <li>Metro supports component-level interop with Dagger and kotlin-inject. This means that Metro graphs can depend on Dagger and kotlin-inject components via <code>@Includes</code> dependencies.</li> <li>Metro supports defining user-defined alternatives for common annotations in addition to its first-party options. This allows easier introduction to codebases using annotations from existing DI frameworks.</li> <li>If Dagger interop is enabled, Metro can generate code that both interops with Dagger/Javax/Jakarta\u2019s types directly as well as reuse Dagger/Anvil\u2019s generated factories.</li> <li>If Anvil interop is enabled, Metro\u2019s compiler can interpret Anvil\u2019s <code>@ContributesMultibinding</code> and <code>boundType</code> APIs.</li> </ul>"},{"location":"generating-metro-code/","title":"Generating Metro Code","text":"<p>Java annotation processing and KSP both support multiple rounds of processing, allowing custom processors to generate new code with injection annotations that can be processed in later rounds. Anvil supported custom <code>CodeGenerator</code> implementations in K1 and anvil-ksp and kotlin-inject-anvil support specifying custom contributing annotations to allow them to intelligently defer processing to later rounds.</p> <p>Since Metro is implemented as a compiler plugin, asking users to write compiler plugins to interact with it would be a bit unwieldy. However, KSP processors that generate metro-annotated code work out of the box with it since they run before Metro\u2019s plugin does.</p> <p>If you have an existing KSP processor for a different framework, you could leverage it + custom annotations interop support described above to make them work out of the box with Metro.</p>"},{"location":"injection-types/","title":"Injection Types","text":"<p>Metro supports multiple common injection types.</p>"},{"location":"injection-types/#constructor-injection","title":"Constructor Injection","text":"<p>Most types should use constructor injection if possible. For this case, you can annotate either a class itself (if it has exactly one, primary constructor) or exactly one specific constructor.</p> <pre><code>@Inject\nclass ClassInjected\n\nclass SpecificConstructorInjection(val text: String) {\n  @Inject constructor(value: Int) : this(value.toString())\n}\n</code></pre> <p>Constructor-injected classes can be instantiated+managed entirely by Metro and encourages immutability.</p>"},{"location":"injection-types/#assisted-injection","title":"Assisted Injection","text":"<p>For types that require dynamic dependencies at instantiation, assisted injection can be used to supply these inputs. In this case - an injected constructor (or class with one constructor) must be annotated with <code>@Inject</code>, assisted parameters annotated with <code>@Assisted</code>, and a factory interface or abstract class with one single abstract function that accepts these assisted parameters and returns the target class.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted val timeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeout: Duration): HttpClient\n  }\n}\n</code></pre> <p>Then, the <code>@AssistedFactory</code>-annotated type can be accessed from the dependency graph.</p> <pre><code>@Inject\nclass ApiClient(httpClientFactory: HttpClient.Factory) {\n  private val httpClient = httpClientFactory.create(30.seconds)\n}\n</code></pre> <p>Like Dagger, the <code>@Assisted</code> parameters can take optional <code>value</code> keys to disambiguate matching types.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted(\"connect\") val connectTimeout: Duration,\n  @Assisted(\"request\") val requestTimeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(\n      @Assisted(\"connect\") connectTimeout: Duration,\n      @Assisted(\"request\") requestTimeout: Duration,\n    ): HttpClient\n  }\n}\n</code></pre>"},{"location":"injection-types/#automatic-assisted-factory-generation","title":"Automatic Assisted Factory Generation","text":"<p>Metro supports automatic generation of assisted factories via opt-in compiler option. If enabled, Metro will automatically generate a default factory as a nested class within the injected type.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted timeoutDuration: Duration,\n  cache: Cache,\n) {\n  // Generated by Metro\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeoutDuration: Duration): HttpClient\n  }\n}\n</code></pre> <p>If a nested class called <code>Factory</code> is already present, Metro will do nothing.</p>"},{"location":"injection-types/#why-opt-in","title":"Why opt-in?","text":"<p>The main reason this is behind an opt-in option at the moment is because compiler plugin IDE support is rudimentary at best and currently requires enabling a custom registry flag. See the docs for how to enable IDE support.</p> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  generateAssistedFactories.set(true)\n}\n</code></pre>"},{"location":"injection-types/#member-injection","title":"Member Injection","text":"<p>Metro supports member injection to inject mutable properties or functions post-construction or into existing class instances.</p> <p>This can be useful for classes that cannot be constructor-injected, for example Android Activity classes (on older SDK versions) as well as constructor-injected classes that perhaps don\u2019t want or need to expose certain types directly in their constructors.</p> <p>Tip</p> <p>Unlike Dagger and kotlin-inject, injected members in Metro can be <code>private</code>.</p> <p>Note</p> <p>Member function injection does not (currently) support default values.</p> <pre><code>class ProfileActivity : Activity() {\n  // Property injection\n  @Inject private lateinit var db: UserDatabase\n\n  @Inject private var notifications: Notifications? = null\n\n  // Function injection\n  @Inject private fun injectUser(user: User) {\n    // ...\n  }\n}\n</code></pre> <p>Like Dagger, these classes can be injected via multiple avenues.</p>"},{"location":"injection-types/#1-in-constructor-injected-types-inject-annotated-members-are-injected-automatically","title":"1. In constructor-injected types, <code>@Inject</code>-annotated members are injected automatically.","text":"<pre><code>// Injection with constructor injection\n@Inject\nclass ProfileInjector(\n  // ...\n) {\n  // Automatically injected during constructor injection\n  @Inject private fun injectUser(value: String) {\n    // ...\n  }\n}\n</code></pre> <p>In these cases, Metro will automatically inject these members automatically and immediately after instantiation during constructor injection.</p>"},{"location":"injection-types/#2-exposing-a-fun-injecttarget-profileactivity-function-on-the-graph","title":"2. Exposing a <code>fun inject(target: ProfileActivity)</code> function on the graph","text":"<pre><code>// Graph inject() functions\n@DependencyGraph\ninterface AppGraph {\n  // ...\n\n  fun inject(target: ProfileActivity)\n}\n\n// Somewhere else\nval graph = createGraph&lt;AppGraph&gt;()\ngraph.inject(profileActivity)\n</code></pre> <p>With this option, you can call <code>graph.inject(target)</code> on the instance with members you wish to inject.</p>"},{"location":"injection-types/#3-requesting-a-membersinjector-instance-from-the-dependency-graph","title":"3. Requesting a <code>MembersInjector</code> instance from the dependency graph.","text":"<pre><code>// Injection with MembersInjector\n@Inject\nclass ProfileInjector(\n  private val injector: MembersInjector&lt;ProfileActivity&gt;\n) {\n  fun performInjection(activity: ProfileActivity) {\n    injector.inject(activity)\n  }\n}\n</code></pre> <p>Like Dagger, option #3 is accomplished via <code>MembersInjector</code> interface at runtime and in code gen. This should be reserved for advanced use cases.</p>"},{"location":"injection-types/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Property accessors don\u2019t use <code>get</code>/<code>set</code> names in <code>inject{name}()</code> function names.</li> <li>MembersInjector classes are generated as nested classes, allowing private member access.<ul> <li>This includes parent classes\u2019 private members (!!)</li> </ul> </li> <li>Optional bindings are not supported for injected member functions currently, but may be possible in the future.</li> </ul>"},{"location":"injection-types/#top-level-function-injection","title":"Top-level Function Injection","text":"<p>Like KI, Metro supports top-level function injection (behind an opt-in compiler option). The primary use case for this is composable functions and standalone applications that run from <code>main</code> functions.</p> <pre><code>@Inject\nfun App(message: String) {\n  // ...\n}\n</code></pre> <p>To do this, Metro\u2019s FIR plugin will generate a concrete type that acts as a bridge for this function.</p> <pre><code>@Inject\nclass AppClass(\n  private val message: Provider&lt;String&gt;\n) {\n  operator fun invoke() {\n    App(message())\n  }\n}\n</code></pre> <p>Because it\u2019s generated in FIR, this type will be user-visible in the IDE and can then be referenced in a graph.</p> <p>Note that this feature requires enabling third party FIR plugins in the IDE to fully work. It will compile without it, but generated wrapper classes will be red/missing in the IDE.</p> <p>Note</p> <p>The generated class is called <code>&lt;function name&gt;</code> + <code>Class</code> because of a limitation in the Kotlin compiler. TODO Link issue?</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val app: AppClass\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n\n// Usage\nval app = createGraphFactory&lt;AppGraph.Factory&gt;()\n  .create(\"Hello, world!\")\n  .app\n\n// Run the app\napp()\n</code></pre> <p>To add assisted parameters, use <code>@Assisted</code> on the parameters in the function description. These will be propagated accordingly.</p> <pre><code>@Inject\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval app = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Run the app\napp(\"Hello, world!\")\n</code></pre> <p>This is particularly useful for Compose, and <code>@Composable</code> functions will be copied over accordingly.</p> <pre><code>@Inject\n@Composable\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  @Composable\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval App = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Call it in composition\nsetContent {\n  App(\"Hello, world!\")\n}\n</code></pre> <p>Similarly, if the injected function is a <code>suspend</code> function, the <code>suspend</code> keyword will be ported to the generated <code>invoke()</code> function too.</p>"},{"location":"injection-types/#why-opt-in_1","title":"Why opt-in?","text":"<p>There are two reasons this is behind an opt-in option at the moment.</p> <ol> <li>Generating top-level declarations in Kotlin compiler plugins (in FIR specifically) is not    currently compatible with incremental compilation.</li> <li>IDE support is rudimentary at best and currently requires enabling a custom registry flag.    See the docs for how to enable IDE support.</li> </ol> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  enableTopLevelFunctionInjection.set(true)\n}\n</code></pre>"},{"location":"injection-types/#implementation-notes_1","title":"Implementation notes","text":"<ul> <li>This is fairly different from kotlin-inject\u2019s typealias approach. This is necessary because Metro doesn\u2019t use higher order function types or typealiases as qualifiers.</li> <li>Since the compose-compiler\u2019s IR transformer may run before Metro\u2019s, we check for this during implementation body generation and look up the transformed target composable function as needed.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Metro is primarily applied via its companion Gradle plugin.</p> <pre><code>plugins {\n  kotlin(\"multiplatform\") // or jvm, android, etc\n  id(\"dev.zacsweers.metro\")\n}\n</code></pre> <p>\u2026and that\u2019s it! This will add metro\u2019s runtime dependencies and do all the necessary compiler plugin wiring.</p> <p>If applying in other build systems, apply it however that build system conventionally applies Kotlin compiler plugins. For example with Bazel:</p> <pre><code>load(\"@rules_kotlin//kotlin:core.bzl\", \"kt_compiler_plugin\")\nload(\"@rules_kotlin//kotlin:jvm.bzl\", \"kt_jvm_library\")\n\nkt_compiler_plugin(\n    name = \"metro_plugin\",\n    compile_phase = True,\n    id = \"dev.zacsweers.metro.compiler\",\n    options = {\n        \"enabled\": \"true\",\n        \"debug\": \"false\",\n    },\n    deps = [\n        \"@maven//:dev_zacsweers_metro_compiler\",\n    ],\n)\n\nkt_jvm_library(\n    name = \"sample\",\n    # The SampleGraph class is annotated with @DependencyGraph\n    srcs = [\"SampleGraph.kt\"],\n    plugins = [\n        \":metro_plugin\",\n    ],\n    deps = [\n        \"@maven//:dev_zacsweers_metro_runtime_jvm\",\n    ],\n)\n</code></pre>"},{"location":"installation/#ide-support","title":"IDE Support","text":"<p>The K2 Kotlin IntelliJ plugin supports running third party FIR plugins in the IDE, but this feature is hidden behind a flag. Some Metro features can take advantage of this, namely diagnostic reporting directly in the IDE and some opt-in features to see generated declarations. </p> <p>To enable it, do the following:</p> <ol> <li>Enable K2 Mode for the Kotlin IntelliJ plugin.</li> <li>Open the Registry</li> <li>Set the <code>kotlin.k2.only.bundled.compiler.plugins.enabled</code> entry to <code>false</code>.</li> </ol> <p>Note that support is unstable and subject to change.</p>"},{"location":"interop/","title":"Interop","text":""},{"location":"interop/#annotations","title":"Annotations","text":"<p>Metro supports user-defined annotations for common annotations. This means that a user doesn\u2019t necessarily have to use Metro\u2019s annotations if they\u2019re introducing it to an existing codebase. Support varies depending on the annotation\u2019s use case.</p> <p>Compile-only annotations are mostly supported. This includes the following:</p> <ul> <li><code>@AssistedFactory</code></li> <li><code>@AssistedInject</code></li> <li><code>@Assisted</code></li> <li><code>@BindsInstance</code></li> <li><code>@Binds</code></li> <li><code>@ContributesBinding</code></li> <li><code>@ContributesTo</code></li> <li><code>@DependencyGraph.Factory</code></li> <li><code>@DependencyGraph</code></li> <li><code>@ElementsIntoSet</code></li> <li><code>@Inject</code></li> <li><code>@IntoMap</code></li> <li><code>@IntoSet</code></li> <li><code>@MapKey</code></li> <li><code>@Module</code></li> <li><code>@Multibinds</code></li> <li><code>@Provides</code></li> <li><code>@Qualifier</code></li> <li><code>@Scope</code></li> </ul> <p>These are configurable via Metro\u2019s Gradle extension.</p> <pre><code>metro {\n  interop {\n    assisted.add(\"dagger/assisted/Assisted\")\n  }\n}\n</code></pre> <p>For Dagger and KI specifically, there are convenience helper functions.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n    includeKotlinInject()\n    includeAnvil()\n  }\n}\n</code></pre> <p><code>@DependencyGraph</code> is replaceable but your mileage may vary if you use Anvil or modules, since Metro\u2019s annotation unifies Anvil\u2019s <code>@MergeComponent</code> functionality and doesn\u2019t support modules.</p> <p>Similarly, <code>@ContributesBinding</code> is replaceable but there are not direct analogues for Anvil\u2019s <code>@ContributesMultibinding</code> or kotlin-inject-anvil\u2019s <code>@ContributesBinding(multibinding = \u2026)</code> as these annotations are implemented as <code>@ContributesInto*</code> annotations in Metro.</p> <p><code>binding</code> in Metro uses a more flexible mechanism to support generics, but interop with Anvil\u2019s <code>boundType: KClass&lt;*&gt;</code> property is supported.</p>"},{"location":"interop/#components","title":"Components","text":"<p>Metro graphs can interop with components generated by Dagger and Kotlin-Inject. These work exclusively through their public accessors and can be depended on like any other graph dependency.</p> <pre><code>@DependencyGraph\ninterface MetroGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(\n      @Includes daggerComponent: DaggerComponent\n    ): MetroGraph\n  }\n}\n\n@dagger.Component\ninterface DaggerComponent {\n  val message: String\n\n  @dagger.Component.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): DaggerComponent\n  }\n}\n</code></pre> <p>Conversely, kotlin-inject and Dagger components can also depend on Metro graphs.</p> <pre><code>@DependencyGraph\ninterface MessageGraph {\n  val message: String\n\n  // ...\n}\n\n// Dagger\n@Component(dependencies = [MessageGraph::class])\ninterface DaggerComponent {\n  val message: String\n\n  @Component.Factory\n  fun interface Factory {\n    fun create(messageGraph: MessageGraph): DaggerComponent\n  }\n}\n\n// kotlin-inject\n@Component\nabstract class KotlinInjectComponent(\n  @Component val messageGraph: MessageGraph\n) {\n  abstract val message: String\n}\n</code></pre>"},{"location":"interop/#runtime","title":"Runtime","text":"<p>Enabling dagger interop also enables more advanced runtime interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code>/<code>Lazy</code> types.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n  }\n}\n</code></pre> <p>This specifically enables two features.</p> <ol> <li>Interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code> and <code>Lazy</code> runtime intrinsics.</li> <li>Interop with generated Dagger factories for constructor-injected and assisted-injected classes. This means that an upstream class that was processed with the dagger compiler and has a generated Java factory class for a constructor injected class can be reused by Metro natively.</li> </ol> <p>Note this also automatically adds an extra <code>interop-dagger</code> dependency to support this scenario.</p>"},{"location":"metro-intrinsics/","title":"Metro Intrinsics","text":"<p>Like Dagger, Metro supports injection of bindings wrapped in intrinsic types. Namely - <code>Provider</code> and <code>Lazy</code>. These are useful for deferring creation/initialization of dependencies. These only need to be requested at the injection site, Metro\u2019s code gen will generate all the necessary stitching to fulfill that request.</p>"},{"location":"metro-intrinsics/#provider","title":"<code>Provider</code>","text":"<p><code>Provider</code> is like Dagger\u2019s <code>Provider</code> \u2014 it is a simple interface who\u2019s <code>invoke()</code> call returns a new instance every time. If the underlying binding is scoped, then the same (scoped) instance is returned every time <code>invoke()</code> is called.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Provider&lt;Cache&gt;) {\n  fun createCache() {\n    val cache = cacheProvider()\n  }\n}\n</code></pre>"},{"location":"metro-intrinsics/#lazy","title":"<code>Lazy</code>","text":"<p><code>Lazy</code> is Kotlin\u2019s standard library <code>Lazy</code>. It lazily computes a value the first time it\u2019s evaluated and is thread-safe.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Lazy&lt;Cache&gt;) {\n  fun createCache() {\n    // The value is computed once and cached after\n    val cache = cacheProvider.value\n  }\n}\n</code></pre> <p>Note that <code>Lazy</code> is different from scoping in that it is confined to the scope of the injected type, rather than the component instance itself. There is functionally no difference between injecting a <code>Provider</code> or <code>Lazy</code> of a scoped binding. A <code>Lazy</code> of a scoped binding can still be useful to defer initialization. The underlying implementation in Metro\u2019s <code>DoubleCheck</code> prevents double memoization in this case.</p> <p>Why doesn\u2019t <code>Provider</code> just use a property like <code>Lazy</code>?</p> <p>A property is appropriate for <code>Lazy</code> because it fits the definition of being a computed value that is idempotent for repeat calls. Metro opts to make its <code>Provider</code> use an <code>invoke()</code> function because it does not abide by that contract.</p>"},{"location":"metro-intrinsics/#providers-of-lazy","title":"Providers of Lazy","text":"<p>Metro supports combining <code>Provider</code> and <code>Lazy</code> to inject <code>Provider&lt;Lazy&lt;T&gt;&gt;</code>. On unscoped bindings this means the provider will return a new deferrable computable value (i.e. a new Lazy). Meanwhile <code>Lazy&lt;Provider&lt;T&gt;&gt;</code> is meaningless and not supported.</p>"},{"location":"multiplatform/","title":"Multiplatform","text":"<p>Should Just Work\u2122\ufe0f! The runtime and code gen have been implemented to be entirely platform-agnostic so far.</p> <p>There is one issue in the repo right now where the compiler appears to have a bug with generated FIR declarations where it doesn\u2019t deserialize them correctly on non-JVM targets. Waiting for feedback from JB.</p> <p>When mixing contributions between common and platform-specific source sets, you must define your final <code>@DependencyGraph</code> in the platform-specific code. This is because a graph defined in commonMain wouldn\u2019t have full visibility of contributions from platform-specific types. A good pattern for this is to define your canonical graph in commonMain without a <code>@DependencyGraph</code> annotation and then a <code>{Platform}{Graph}</code> type in the platform source set that extends it and does have the <code>@DependencyGraph</code>. Metro automatically exposes bindings of the base graph type on the graph for any injections that need it.</p> <pre><code>// In commonMain\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n\n// In jvmMain\n@DependencyGraph\ninterface JvmAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(Netty)\n}\n\n// In androidMain\n@DependencyGraph\ninterface AndroidAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(OkHttp)\n}\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>Metro strives to be a performant solution with minimal overhead at build-time and generating fast, efficient code at runtime. As build performance is the primary consideration for most developers considering this, most of this doc will be focused on that.</p>"},{"location":"performance/#build-performance","title":"Build Performance","text":"<p>Metro\u2019s compiler plugin is designed to be fast. Running as a compiler plugin allows it to: - Avoid generating new sources that need to be compiled - Avoid running KSP/KAPT - Generate IR that lowers directly into target platforms - Hook directly into kotlinc\u2019s IC APIs.</p> <p>In a straightforward migration, it improves ABI-changing build performance from 30-70%.</p>"},{"location":"performance/#benchmarking","title":"Benchmarking","text":"<p>To benchmark against Anvil-KSP, Dagger (KSP or KAPT), and Kotlin-Inject (+ Anvil), there is a benchmark directory with a generator script. There are more details in its README, but in short it generates a nontrivial multi-module project (default is 500 modules but is configurable) and benchmarks with gradle-profiler.</p> <p>Summary</p> <p>Results as of Metro <code>0.3.7</code>, Anvil-KSP <code>0.4.1</code>, Dagger <code>2.56.2</code>, and Kotlin-Inject <code>0.8.0</code> with kotlin-inject-anvil <code>0.1.6</code> are as follows.</p> <p>(Median times in seconds)</p> Metro Anvil KSP Anvil Kapt Kotlin-Inject ABI 5.3s 40.5s (+663%) 25.3s (+377%) 10.3s (+94%) Non-ABI 2.6s 3.8s (+45%) 7.1s (+171%) 3.3s (+26%) Graph processing 6.9s 28.9s (+318%) 8.7s (+25%) 11s (+59%)"},{"location":"performance/#modes","title":"Modes","text":"<ul> <li>Metro: Purely running metro</li> <li>Anvil KSP: Running dagger-ksp with anvil-ksp for contribution merging.</li> <li>Anvil KAPT: Running dagger with kapt with anvil-ksp for contribution merging.</li> <li>Kotlin Inject: Running kotlin-inject + kotlin-inject-anvil for contribution merging.</li> </ul>"},{"location":"performance/#abi-change","title":"ABI Change","text":"<p>This benchmark makes ABI-breaking source changes in a lower level module. This is where Metro shines the most.</p> <p></p>"},{"location":"performance/#non-abi-change","title":"Non-ABI Change","text":"<p>This benchmark makes non-ABI-breaking source changes in a lower level module. The differences are less significant here as KSP is quite good at compilation avoidance now too. The outlier here is KAPT, which still has to run stub gen + apt and cannot fully avoid it.</p> <p></p>"},{"location":"performance/#raw-graphcomponent-processing","title":"Raw Graph/Component Processing","text":"<p>This benchmark reruns the top-level merging graph/component where all the downstream contributions are merged. This also builds the full dependency graph and any contributed graph extensions/subcomponents.</p> <p>Metro again shines here. Dagger-KSP seems to have a bottleneck that disproportionately affects it here too.</p> <p></p>"},{"location":"performance/#real-world-results","title":"Real-World Results","text":"<p>Below are some results from real-world projects, shared with the developers\u2019 permission.</p> <p>Gabriel Ittner from Freeletics</p> <p>I\u2019ve got Metro working on our code base now using the Kotlin 2.2.0 preview</p> <p>Background numbers</p> <ul> <li>551 modules total</li> <li>105 modules using Anvil KSP \u27a1\ufe0f migrated to pure Metro</li> <li>154 modules using Anvil KSP + other KSP processor \u27a1\ufe0f Metro + other KSP processor</li> <li>1 module using Dagger KAPT \u27a1\ufe0f migrated to pure Metro</li> </ul> <p>Build performance</p> <ul> <li>Clean builds without build cache are 12 percentage points faster</li> <li>Any app module change ~50% faster (this is the one place that had kapt and it\u2019s mostly empty other than generating graphs/components)</li> <li>ABI changes in other modules ~ 40% - 55% faster</li> <li>non ABI changes in other modules unchanged or minimally faster</li> </ul> <p>Madis Pink from emulator.wtf</p> <p>I got our monorepo migrated over from anvil, it sliced off one third of our Gradle tasks and <code>./gradlew classes</code> from clean is ~4x faster</p> <p>Kevin Chiu from BandLab</p> <p>We migrated our main project at BandLab to metro, finally!</p> <p>Some context about our project:</p> <ul> <li>We use Dagger + Anvil KSP</li> <li>929 modules, 89 of them are running Dagger compiler (KAPT) to process components</li> <li>7 KSP processors</li> </ul> Build Dagger + Anvil KSP Metro (\u0394) UiKit ABI change (Incremental) 59.7 s 26.9 s (55% faster) Root ABI change (Incremental) 95.7 s 48.1 s (49.8% faster) Root non-ABI change (Incremental) 70.9 s 38.9 s (45.2% faster) Clean build 327 s 288 s (11.7% faster)"},{"location":"performance/#reporting","title":"Reporting","text":"<p>If you want to investigate the performance of different stages of Metro\u2019s compiler pipeline, you can enable reporting in the Gradle DSL.</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre> <p>Among the reports written there, there will also be a trace log that dumps a simple trace of the different stages.</p> <pre><code>[ExampleGraph] \u25b6 Transform dependency graph\n  \u25b6 Build DependencyGraphNode\n  \u25c0 Build DependencyGraphNode (xx ms)\n  \u25b6 Implement creator functions\n  \u25c0 Implement creator functions (xx ms)\n  \u25b6 Build binding graph\n  \u25c0 Build binding graph (xx ms)\n  \u25b6 Validate binding graph\n    \u25b6 Check self-cycles\n    \u25c0 Check self-cycles (xx ms)\n    \u25b6 Validate graph\n      \u25b6 seal graph\n        \u25b6 Populate bindings\n        \u25c0 Populate bindings (xx ms)\n        \u25b6 Build adjacency list\n        \u25c0 Build adjacency list (xx ms)\n        \u25b6 Sort and validate\n          \u25b6 Topo sort\n            \u25b6 Compute SCCs\n            \u25c0 Compute SCCs (xx ms)\n            \u25b6 Check for cycles\n            \u25c0 Check for cycles (xx ms)\n            \u25b6 Build component DAG\n            \u25c0 Build component DAG (xx ms)\n            \u25b6 Topo sort component DAG\n            \u25c0 Topo sort component DAG (xx ms)\n            \u25b6 Expand components\n            \u25c0 Expand components (xx ms)\n          \u25c0 Topo sort (xx ms)\n        \u25c0 Sort and validate (xx ms)\n        \u25b6 Compute binding indices\n        \u25c0 Compute binding indices (xx ms)\n      \u25c0 seal graph (xx ms)\n      \u25b6 check empty multibindings\n      \u25c0 check empty multibindings (xx ms)\n      \u25b6 check for absent bindings\n      \u25c0 check for absent bindings (xx ms)\n    \u25c0 Validate graph (xx ms)\n  \u25c0 Validate binding graph (xx ms)\n  \u25b6 Transform metro graph\n    \u25b6 Collect bindings\n    \u25c0 Collect bindings (xx ms)\n    \u25b6 Implement overrides\n    \u25c0 Implement overrides (xx ms)\n  \u25c0 Transform metro graph (xx ms)\n[ExampleGraph] \u25c0 Transform dependency graph (xx ms)\n</code></pre>"},{"location":"performance/#runtime-performance","title":"Runtime Performance","text":"<p>Metro\u2019s compiler generates Dagger-style factory classes for every injection site.</p> <p>The same factory classes are reused across modules and downstream builds, so there\u2019s no duplicated glue code or runtime discovery cost.</p> <p>Because the full dependency graph is wired at compile-time, each binding is accessed through a direct field reference in the generated code. No reflection, no hashmap lookups, no runtime service locator hops, etc.</p>"},{"location":"provides/","title":"<code>@Provides</code>","text":"<p>Providers can be defined in graphs or supertypes that graphs extend. Defining them in supertypes allows for them to be reused across multiple graphs and organize providers into logic groups. This is similar to how modules in Dagger work.</p> <pre><code>interface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface AppGraph : NetworkProviders\n</code></pre> <p>Provider functions should be <code>private</code> by default and are automatically transformed to be private by the Metro compiler. This means you can write a provider function with no explicit (or public) visibility and it will be made private by Metro at compile-time.</p> <p>Provider properties cannot be private yet due to KT-76257, but may be supported in the future.</p> <p>Providers may also be declared in binding Containers.</p> <p>Tip</p> <p>It\u2019s recommended to not call providers from each other.</p>"},{"location":"provides/#overrides","title":"Overrides","text":"<p>It is an error to override providers declarations. While it can be enticing for testing reasons to try to replicate Dagger 1\u2019s module overrides, it quickly becomes difficult to reason about in code gen.</p> <ul> <li>What if you override with sub/supertypes?</li> <li>What if your override\u2019s implementation needs different dependencies?</li> </ul> <p>To the testing end, it is recommended to instead leverage the <code>DependencyGraph.excludes</code> + <code>ContributesTo.replaces</code> APIs in merging.</p> <pre><code>// Don't do this pattern!\ninterface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface TestAppGraph : NetworkProviders {\n  // This will fail to compile\n  override fun provideHttpClient(): HttpClient = TestHttpClient()\n}\n</code></pre>"},{"location":"provides/#companion-providers","title":"Companion Providers","text":"<p>Providers can alternatively be implemented in <code>companion object</code>s for staticization.</p> <pre><code>interface MessageGraph {\n  val message: String\n  companion object {\n    @Provides\n    private fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre>"},{"location":"provides/#implementation-notes","title":"Implementation Notes","text":"<p>private interface functions are not usually visible to downstream compilations in IR. To work around this, Metro will use a new API in Kotlin 2.1.20 to add custom metadata to the parent class to denote these private providers\u2019 existence and where to find them.</p>"},{"location":"scopes/","title":"Scopes","text":"<p>Like Dagger and KI, Metro supports scopes to limit instances of types on the dependency graph. A scope is any annotation annotated with <code>@Scope</code>, with a convenience <code>@SingleIn</code> scope available in Metro\u2019s runtime.</p> <p>Scopes must be applied to either the injected class or the provider function providing that binding. They must also match the graph that they are used in.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\nabstract class AppGraph {\n  private var counter = 0\n\n  abstract val count: Int\n\n  @SingleIn(AppScope::class) @Provides fun provideCount() = counter++\n}\n</code></pre> <p>In the above example, multiple calls to <code>AppGraph.count</code> will always return 0 because the returned value from <code>provideCount()</code> will be cached in the <code>AppGraph</code> instance the first time it\u2019s called.</p> <p>It is an error for an unscoped graph to access scoped bindings.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>It is also an error for a scoped graph to access scoped bindings whose scope does not match.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(UserScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>Like Dagger, graphs can have multiple scopes that they support.</p> <pre><code>@Scope annotation class Singleton\n\n@Singleton\n@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is ok\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre>"},{"location":"validation-and-error-reporting/","title":"Validation &amp; Error Reporting","text":"<p>Common programmer/usage errors are implemented in FIR. This should allow errors to appear directly in the IDE, offering the best and fastest feedback loop for developers writing their code.</p> <p>TODO IDE screenshot example</p> <p>Dependency graph validation is performed at the per-graph level. Metro seeks to report binding validation errors at least on par with Dagger, if not better.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/DependencyCycle] Found a dependency cycle:\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n    kotlin.String is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideDouble(..., string)\n    kotlin.Double is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideInt(..., double)\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n</code></pre> <p>Binding errors take learnings from Dagger and report fully qualified references that IDEs like IntelliJ can usually autolink.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/GraphDependencyCycle] Dependency graph dependency cycle detected! The below graph depends on itself.\n    test.CharSequenceGraph is requested at\n        [test.CharSequenceGraph] test.CharSequenceGraph.Factory.create()\n</code></pre> <p>Note that binding graph resolution currently only happens in the compiler IR backend, but maybe someday we can move this to FIR to get errors in the IDE.</p>"}]}