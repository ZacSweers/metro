{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\ude89 Metro","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Metro is a compile-time dependency injection framework that draws heavy inspiration from Dagger, Anvil, and Kotlin-Inject. It seeks to unify their best features under one, cohesive solution while adding a few new features and implemented as a compiler plugin.</p>"},{"location":"#why-another-di-framework","title":"Why another DI framework?","text":"<p>It\u2019s felt for some time like the Kotlin community has been waiting for a library at the intersection of these different tools and features. Different tools exist for parts of these, but there\u2019s not yet been a unified solution that checks all these boxes, leaves behind some of these tools\u2019 limitations, and embraces newer features that native compiler plugins offer.</p> <p>In short, Metro stands on the shoulders of giants. It doesn\u2019t try to reinvent the wheel, it does try to make those wheels work better together.</p> <p>Note</p> <p>I\u2019m aware of the XKCD comic \ud83d\ude42, I think Metro offers a compelling feature set with interop hooks that make it easy to integrate with an existing codebase.</p>"},{"location":"#installation","title":"Installation","text":"<p>Apply the gradle plugin.</p> <pre><code>plugins {\n  id(\"dev.zacsweers.metro\") version \"x.y.z\"\n}\n</code></pre> <p>And that\u2019s it! The default configuration will add the multiplatform <code>runtime</code> artifact (which has annotations you can use) and wire it all automatically.</p> <p>You can configure custom behaviors with APIs on the <code>metro</code> DSL extension.</p> <pre><code>metro {\n  // Defines whether or not metro is enabled. Useful if you want to gate this behind a dynamic\n  // build configuration.\n  enabled = true // Default\n\n  // Enable (extremely) verbose debug logging\n  debug = false // Default\n\n  // See the kdoc on MetroPluginExtension for full details\n}\n</code></pre> <p>Snapshots of the development version are available in Sonatype\u2019s <code>snapshots</code> repository.</p>"},{"location":"#supported-platforms","title":"Supported platforms","text":"<p>The compiler plugin itself supports all multiplatform project types. The first-party annotations artifact is also multiplatform and supports all common JVM, JS, and native targets.</p> <p>Contribution hint generation is not currently supported on native or Wasm targets until KT-58886 is resolved. They do work within the same compilation though.</p>"},{"location":"#caveats","title":"Caveats","text":"<ul> <li>Kotlin compiler plugins are not a stable API! Compiled outputs from this plugin should be stable, but usage in newer versions of kotlinc are not guaranteed to be stable. That said, Metro will strive to make matching releases available quickly and test against Kotlin prereleases eagerly.</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Special thanks to the many people that helped advise and offer feedback on Metro\u2019s design and implementation.</p> <ul> <li>Brian Norman</li> <li>Ralf Wondratschek</li> <li>Jesse Wilson</li> <li>Dany Santiago</li> <li>Eva Tatarka</li> <li>Bill Phillips</li> <li>Bryan Stern</li> <li>James Barr</li> <li>and many more!</li> </ul>"},{"location":"#license","title":"License","text":"<pre><code>Copyright (C) 2025 Zac Sweers\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n   https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"adoption/","title":"Adoption Strategies","text":"<p>If adopting Metro into an existing codebase, you can use a few different strategies.</p> <ol> <li>First, add the Metro Gradle plugin and runtime deps. The plugin id is <code>dev.zacsweers.metro</code>, runtime is <code>dev.zacsweers.metro:runtime</code>. The Gradle Plugin should add the runtime automatically, but it\u2019s there just in case!</li> <li>Apply the Gradle plugin to your relevant project(s).</li> </ol>"},{"location":"adoption/#into-a-dagger-codebase","title":"Into a Dagger codebase","text":"<p>First, remove the dagger-compiler/anvil plugin (but keep their runtime deps if you use option 1 below!).</p>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level","title":"Option 1 - Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on Dagger components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is good if you want to do a very simple introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations","title":"Option 2 - Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from Dagger/Anvil. Here is an example for enabling that in Gradle.</p> <p>You will still possibly need to do some manual migrations.</p> <ul> <li>If you use <code>@MergeComponent</code> + <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>Migrate <code>@BindsInstance</code> to <code>@Provides</code>. Metro consolidated these to just one annotation.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"adoption/#option-3-full-migration","title":"Option 3 - Full migration","text":"<ul> <li>Remove the Dagger and anvil runtimes.</li> <li>Replace all Dagger/anvil annotations with Metro equivalents.</li> <li>If you use subcomponents, you\u2019ll have to switch to Graph extensions.</li> <li>Update references to generated <code>Dagger*Component</code> calls to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"adoption/#into-a-kotlin-inject-codebase","title":"Into a kotlin-inject codebase","text":"<p>First, remove the kotlin-inject(-anvil) dependencies (but keep their runtime deps if you use option 1 below!).</p> <p>Second, migrate to <code>@AssistedFactory</code> if you haven\u2019t already.</p>"},{"location":"adoption/#option-1-interop-at-the-componentgraph-level_1","title":"Option 1 - Interop at the component/graph level","text":"<p>This option is good if you only want to use Metro for new code. Metro graphs can depend on kotlin-inject components (as <code>@Includes</code> parameters) and vice versa. Here is an example project that does this.</p> <p>This option is good if you want to do a very simple introduction of Metro in one part of your codebase, such as a smaller modularized feature or library.</p>"},{"location":"adoption/#option-2-migrate-existing-usages-reuse-your-existing-annotations_1","title":"Option 2 - Migrate existing usages + reuse your existing annotations","text":"<p>If you want the least amount of splash as possible, you can tell Metro to reuse your annotations from kotlin-inject/kotlin-inject-anvil. Here is an example for enabling that in Gradle.</p> <p>You will still possibly need to do some manual migrations, namely providers.</p> <ul> <li>Any higher order function injection will need to switch to using Metro\u2019s <code>Provider</code> API.</li> <li>Any higher order assisted function injection will need to switch to using <code>@AssistedFactory</code>-annotated factories.</li> <li>If you use <code>@MergeComponent</code> + <code>@Component</code>, it\u2019ll be easier if you just migrate those interfaces to <code>@DependencyGraph</code> since they\u2019re combined in there now.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"adoption/#option-3-full-migration_1","title":"Option 3 - Full migration","text":"<ul> <li>Remove the kotlin-inject and Anvil runtimes.</li> <li>Replace all kotlin-inject/anvil annotations with Metro equivalents.</li> <li>If you use <code>@Component</code> parameters for graph extensions, you\u2019ll have to switch to Graph extensions. This will primarily entail annotating the parameter with <code>@Nested</code> and marking the parent graph as extendable.</li> <li>Update calls to generated <code>SomeComponent::class.create(...)</code> functions to use metro\u2019s <code>createGraph</code>/<code>createGraphFactory</code> APIs.</li> </ul>"},{"location":"aggregation/","title":"Aggregation (aka \u2018Anvil\u2019)","text":"<p>Metro supports Anvil-style aggregation in graphs via <code>@ContributesTo</code> and <code>@ContributesBinding</code> annotations. As aggregation is a first-class citizen of Metro\u2019s API, there is no <code>@MergeComponent</code> annotation like in Anvil. Instead, <code>@DependencyGraph</code> defines which contribution scope it supports directly.</p> <pre><code>@DependencyGraph(scope = AppScope::class)\ninterface AppGraph\n</code></pre> <p>When a graph declares a <code>scope</code>, all contributions to that scope are aggregated into the final graph implementation in code gen.</p> <p>If a graph supports multiple scopes, use <code>additionalScopes</code>.</p> <pre><code>@DependencyGraph(\n  AppScope::class,\n  additionalScopes = [LoggedOutScope::class]\n)\ninterface AppGraph\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@DependencyGraph</code> supports excluding contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(\n  scope = AppScope::class,\n  excludes = [RealNetworkProviders::class]\n)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class)\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre>"},{"location":"aggregation/#contributesto","title":"@ContributesTo","text":"<p>This annotation is used to contribute graph interfaces to the target scope to be merged in at graph-processing time to the final merged graph class as another supertype.</p> <pre><code>@ContributesTo(AppScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesTo(AppScope::class)\n@ContributesTo(LoggedInScope::class)\ninterface NetworkProviders {\n  @Provides fun provideHttpClient(): HttpClient\n}\n</code></pre> <p>Similar to kotlin-inject-anvil, <code>@ContributesBinding</code> (as well as the other <code>@Contributes*</code> annotations) supports replacing other contributions by class. This is useful for cases like tests, where you may want to contribute a test/fake implementation that supersedes the \u201creal\u201d graph.</p> <pre><code>@DependencyGraph(AppScope::class)\ninterface TestAppGraph\n\n@ContributesTo(AppScope::class, replaces = [RealNetworkProviders::class])\ninterface TestNetworkProviders {\n  @Provides fun provideHttpClient(): TestHttpClient\n}\n</code></pre> <p>Warning</p> <p><code>@Contributes*.replaces</code> cannot replace classes in the same compilation as the graph that is merging them.</p>"},{"location":"aggregation/#contributesbinding","title":"@ContributesBinding","text":"<p>This annotation is used to contribute injected classes to a target scope as a given bound type.</p> <p>The below example will contribute the <code>CacheImpl</code> class as a <code>Cache</code> type to <code>AppScope</code>.</p> <pre><code>@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For simple cases where there is a single supertype, that type is implicitly used as the bound type. If your bound type is qualified, for the implicit case you can put the qualifier on the class.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>For classes with multiple supertypes or advanced cases where you want to bind an ancestor type, you can explicitly define this via <code>binding</code> parameter.</p> <pre><code>@Named(\"cache\")\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Whoa, is that a function call in an annotation argument? Nope! <code>binding</code> is just a decapitalized class in this case, intentionally designed for readability. It\u2019s an adjective in this context and the functional syntax better conveys that.</p> <p>Note that the bound type is defined as the type argument to <code>@ContributesBinding</code>. This allows for the bound type to be generic and is validated in FIR.</p> <p>Qualifier annotations can also be specified on the <code>binding</code> type parameter and will take precedence over any qualifiers on the class itself.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;@Named(\"cache\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>This annotation is repeatable and can be used to contribute to multiple scopes.</p> <pre><code>@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;Cache&gt;()\n)\n@ContributesBinding(\n  scope = AppScope::class,\n  binding = binding&lt;AnotherType&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache, AnotherType\n</code></pre> <p>Tip</p> <p>Contributions may be <code>object</code> classes. In this event, Metro will automatically provide the object instance in its binding.</p>"},{"location":"aggregation/#contributesintosetcontributesintomap","title":"@ContributesIntoSet/@ContributesIntoMap","text":"<p>To contribute into a multibinding, use the <code>@ContributesIntoSet</code> or <code>@ContributesIntoMap</code> annotations as needed.</p> <pre><code>@ContributesIntoSet(AppScope::class)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>Same rules around qualifiers and <code>binding()</code> apply in this scenario</p> <p>To contribute into a Map multibinding, the map key annotation must be specified on the class or <code>binding</code> type argument.</p> <pre><code>// Will be contributed into a Map multibinding with @StringKey(\"Networking\")\n@ContributesIntoMap(AppScope::class)\n@StringKey(\"Networking\")\n@Inject\nclass CacheImpl(...) : Cache\n\n// Or if using binding\n@ContributesIntoMap(\n  scope = AppScope::class,\n  binding = binding&lt;@StringKey(\"Networking\") Cache&gt;()\n)\n@Inject\nclass CacheImpl(...) : Cache\n</code></pre> <p>This annotation is also repeatable and can be used to contribute to multiple scopes, multiple bound types, and multiple map keys.</p>"},{"location":"aggregation/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers (see Binding Containers) can also be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"aggregation/#replacing-contributed-binding-containers","title":"Replacing Contributed Binding Containers","text":"<p>Similar to other contribution types, binding containers can replace other contributed binding containers:</p> <pre><code>// In production\n@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n// In tests\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre>"},{"location":"aggregation/#excluding-contributed-binding-containers","title":"Excluding Contributed Binding Containers","text":"<p>Graphs can exclude specific contributed binding containers:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface TestAppGraph {\n  // NetworkBindings will not be included\n}\n</code></pre> <p>Info</p> <p>Currently, contributed binding containers cannot replace non-contributed-container types (i.e. <code>@ContributesBinding</code> classes) yet.</p>"},{"location":"aggregation/#contributesgraphextension","title":"<code>@ContributesGraphExtension</code>","text":"<p>Not yet implemented. Please share design feedback in #165!</p>"},{"location":"aggregation/#implementation-notes","title":"Implementation notes","text":"<p>This leans on Kotlin\u2019s ability to put generic type parameters on annotations. That in turn allows for both generic bound types and to contribute map bindings to multiple map keys.</p> <p>Because it\u2019s a first-party feature, there\u2019s no need for intermediary \u201cmerged\u201d components like kotlin-inject-anvil and anvil-ksp do.</p> <p>Generated contributing interfaces are generated to the <code>metro.hints</code> package and located during graph supertype generation in FIR downstream. Any contributed bindings are implemented as <code>@Binds</code> (\u00b1 IntoSet/IntoMap/etc) annotated properties.</p>"},{"location":"bindings/","title":"Bindings","text":""},{"location":"bindings/#qualifiers","title":"Qualifiers","text":"<p>Like Dagger and KI, Metro supports qualifier annotations to allow disambiguation of types. These are applied at injection and provision sites. A qualifier annotation is any annotation annotated with <code>@Qualifier</code>. For convenience, there is an included <code>@Named</code> qualifier available in Metro\u2019s runtime that can be used too.</p> <p>A \u201ctype key\u201d in Metro is composed of a concrete type and (if any) qualifier annotation attached to it.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val int: Int\n  @Named(\"named\") val namedInt: Int\n\n  @Provides\n  fun provideInt(): Int = 3\n\n  @Provides\n  @Named(\"named\")\n  fun provideNamedInt(): Int = 4\n}\n</code></pre>"},{"location":"bindings/#binds","title":"@Binds","text":"<p>In many cases, a developer may have an implementation type on the graph that they want to expose as just its supertype.</p> <p>Like Dagger, Metro supports this with <code>@Binds</code>.</p> <p>For these cases, an abstract provider can be specified with the following conditions.</p> <ul> <li>It must be abstract</li> <li>It must define one extension receiver that is a subtype of its provided type</li> </ul> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: Message\n\n  // Bind MessageImpl as Message\n  @Binds val MessageImpl.bind: Message\n\n  @Provides\n  fun provideText(): String = \"Hello, world!\"\n}\n\n@Inject\nclass MessageImpl(val text: String) : Message\n</code></pre> <p>If you want to limit access to these from your API, you can make these declarations <code>private</code> @Provides and just return <code>this</code>.</p> <p><code>@Binds</code> declarations can also declare multibinding annotations.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val messages: Message\n\n  @Binds @IntoSet val MessageImpl.bind: Message\n}\n</code></pre> <p><code>@Binds</code> declarations may also be declared in binding Containers.</p> <p>Note</p> <p>In theory, you can implement a provider with a getter that replicates this (similar to how kotlin-inject uses <code>@get:Provider</code> + <code>this</code>), but this will be an error in FIR because Metro can generate more efficient code at compile-time if you use <code>@Binds</code>. This is because Metro can avoid calling the function entirely and just use this information at compile-time to optimize the generated code.</p>"},{"location":"bindings/#multibindings","title":"Multibindings","text":"<p>Like Dagger and KI, Metro supports <code>Set</code> and <code>Map</code> multibindings. Multibindings are collections of bindings of a common type. Multibindings are implicitly declared by the existence of providers annotated with <code>@IntoSet</code>, <code>@IntoMap</code>, or <code>@ElementsIntoSet</code>.</p> <pre><code>@DependencyGraph\ninterface SetMultibinding {\n  // contains a set of [1, 2, 3, 4]\n  val ints: Set&lt;Int&gt;\n\n  @Provides @IntoSet fun provideInt1() = 1\n\n  @Provides @IntoSet fun provideInt2() = 2\n\n  @Provides\n  @ElementsIntoSet\n  fun provideInts() = setOf(3, 4)\n}\n</code></pre> <p>Map multibindings use <code>@IntoMap</code> and require a map key annotation. Map keys are any annotation annotated with <code>@MapKey</code>. Metro\u2019s runtime includes a number of common ones like <code>@ClassKey</code> and <code>@StringKey</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  // contains a map of {1:1, 2:2}\n  val ints: Map&lt;Int, Int&gt;\n\n  @Provides\n  @IntoMap\n  @IntKey(1)\n  fun provideInt1() = 1\n\n  @Provides\n  @IntoMap\n  @MapKey(2)\n  fun provideInt2() = 2\n}\n</code></pre> <p>Alternatively, they can be declared with an <code>@Multibinds</code>-annotated accessor property/function in a component. This member will be implemented by the Metro compiler and is useful for scenarios where the multibinding may be empty.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinding\n  val ints: Map&lt;Int, Int&gt;\n}\n</code></pre> <p>Multibinding collections are immutable at runtime and cannot be defined as mutable at request sites.</p> <p>Map multibindings support injecting map providers, where the value type can be wrapped in <code>Provider</code>.</p> <pre><code>@DependencyGraph\ninterface MapMultibinding {\n  @Multibinding\n  val ints: Map&lt;Int, Provider&lt;Int&gt;&gt;\n}\n</code></pre> <p>Unlike Dagger, empty multibindings in Metro are a compile error by default. Empty multibindings are allowed but must be opted into via <code>@Multibinds(allowEmpty = true)</code>.</p>"},{"location":"bindings/#implementation-notes","title":"Implementation notes","text":"<p>Metro takes inspiration from Guice in handling these in the binding graph. Since they cannot be added directly to the graph as-is (otherwise they would cause duplicate binding errors), a synthetic <code>@MultibindingElement</code> qualifier annotation is generated for them at compile-time to disambiguate them. These are user-invisible but allows them to participate directly in graph validation like any other dependency. Metro then just adds these bindings as dependencies to <code>Binding.Multibinding</code> types.</p>"},{"location":"bindings/#optional-dependencies","title":"Optional Dependencies","text":"<p>Metro supports optional dependencies by leaning on Kotlin\u2019s native support for default parameter values. These are checked at injection sites and are allowed to be missing from the dependency graph when performing a lookup at validation/code-gen time.</p> <p>The below example would, since there is no <code>Int</code> binding provided, provide a message of <code>Count: -1</code>.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides fun provideMessage(count: Int = -1) = \"Count: $count\"\n}\n</code></pre> <p>Dagger supports a similar feature via <code>@BindsOptionalOf</code>, but requires a separate declaration of this optional dependency to the graph.</p> <p>KI supports the same feature.</p>"},{"location":"bindings/#nullability","title":"Nullability","text":"<p>As nullability is a first-class concept in Kotlin, Metro supports it too. Bindings in Metro graphs may be nullable, but it\u2019s important to understand how Metro treats them!</p> <p>In short, Metro will treat nullable types as different type keys than their non-nullable analogues. That is to say, <code>String</code> and <code>String?</code> are treated as distinct types in Metro.</p> <p>Furthermore, a <code>String</code> binding cannot satisfy a <code>String?</code> automatically. You may however <code>@Binds</code> a <code>String</code> to a <code>String?</code> and Metro will treat it as a valid binding.</p> <pre><code>@DependencyGraph(Unit::class, isExtendable = true)\ninterface ExampleGraph {\n  val int: Int\n  val nullableInt: Int?\n\n  @Provides\n  fun provideInt(): Int = 1\n\n  @Binds\n  val Int.bindAsNullable: Int?\n}\n</code></pre>"},{"location":"bindings/#implementation-notes_1","title":"Implementation notes","text":"<p>While kotlin-inject can support this by simply invoking functions with omitted arguments, Metro has to support this in generated factories.</p> <p>To accomplish this, Metro will slightly modify how generated provider/constructor injection factory classes look compared to Dagger. Since we are working in IR, we can copy the default value expressions from the source function/constructor to the factory\u2019s newInstance and create() functions. This in turn allows calling generated graphs to simply omit absent binding arguments from their creation calls. This is a tried and tested pattern used by other first party plugins, namely kotlinx-serialization.</p> <p>There are a few cases that need to be handled here:</p> <ul> <li>Expressions may reference previous parameters or instance members. To support this, we\u2019ll transform them in IR to point at new parameters in those functions.</li> <li>Expressions may reference private instance members. To support this, Metro factories are generated as nested classes within the source class or graph.<ul> <li>This does depart from how dagger factories work, but if we ever wanted to have some sort of interop for that we could always generate bridging factory classes in the places dagger expects later.</li> </ul> </li> <li>Parameters in <code>create()</code> need to be wrapped in <code>Provider</code> calls. This means that for cases where they back-reference other parameters, those will need to be transformed into <code>invoke()</code> calls on those providers too.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#050","title":"0.5.0","text":"<p>2025-07-14</p> <ul> <li>New: Experimental support for \u201cbinding containers\u201d via <code>@BindingContainer</code>. See their docs for more details.</li> <li>New: Add <code>keys-scopedProviderFields-*.txt</code> and <code>keys-providerFields-*.txt</code> reports to see generated field reports for graphs.</li> <li>Enhancement: Remove <code>Any</code> constraint from <code>binding&lt;T&gt;()</code>, allowing bindings to satisfy nullable variants.</li> <li>Enhancement: Add diagnostic to check for scoped <code>@Binds</code> declarations. These are simple pipes and should not have scope annotations.</li> <li>Enhancement: Move graph dependency cycle checks to earlier in validation.</li> <li>Enhancement: When using Dagger interop, default <code>allowEmpty</code> to true when using Dagger\u2019s <code>@Multibinds</code> annotation.</li> <li>Enhancement: Make Dagger interop providers/lazy instances a <code>dagger.internal.Provider</code> internally for better compatibility with Dagger internals. Some dagger-generated code assumes this type at runtime.</li> <li>Enhancement: Support javax/jakarta <code>Provider</code> types as multibinding Map value types when Dagger interop is enabled.</li> <li>Enhancement: Completely skip processing local and enum classes as they\u2019re irrelevant to Metro\u2019s compiler.</li> <li>Enhancement: When reporting <code>@Binds</code> declarations in binding stacks, report the original declaration rather than inherited fake overrides.</li> <li>Enhancement: Add interop support for kotlin-inject\u2019s <code>@AssistedFactory</code> annotations.</li> <li>Enhancement: Add diagnostic to check for graph classes directly extending other graph classes. You should use <code>@Extends</code>.</li> <li>Enhancement: Add diagnostic to check for <code>@Assisted</code> parameters in provides functions.</li> <li>Enhancement: Add diagnostic to check duplicate <code>@Provides</code> declaration names in the same class.</li> <li>Fix: Within (valid) cycles, topographically sort bindings within the cycle. Previously these would fall back to a deterministic-but-wrong alphabetical sort.</li> <li>Fix: Handle enum entry arguments to qualifier, scope, and map key annotations.</li> <li>Fix: Report the original location of declarations in fake overrides in error reporting.</li> <li>Fix: Handle default values on provides parameters with absent bindings during graph population.</li> <li>Fix: Don\u2019t try to read private accessors of <code>@Includes</code> parameters.</li> <li>Fix: Don\u2019t quietly stub accessors for missing <code>Binding.Provided</code> bindings.</li> <li>Fix: Check constructor-annotated injections when discovering scoped classes in parent graphs.</li> <li>Fix: Fix <code>BaseDoubleCheck.isInitialized()</code>.</li> <li>Fix: Gracefully fall back to <code>MessageCollector</code> for graph seal and contributed graph errors on sourceless declarations.</li> <li>Fix: Fix supporting overloads of binds functions from parent graphs or external supertypes.</li> <li>Fix: Fix generating binding functions with names that contain dashes.</li> <li>Fix: Treat interop\u2019d Dagger/Anvil/KI components as implicitly extendable.</li> <li>Fix: Record lookups of <code>@Binds</code> declarations for IC.</li> <li>Fix: Record lookups of generated class factories and their constructor signatures for IC.</li> </ul> <p>Special thanks to @kevinguitar, @gabrielittner, @chrisbanes, @yschimke, and @ajarl for contributing to this release!</p>"},{"location":"changelog/#040","title":"0.4.0","text":"<p>2025-06-23</p> <ul> <li>New: Injected constructors may now be private. This can be useful for scenarios where you want <code>@Inject</code>-annotated constructors to only be invokable by Metro\u2019s generated code.</li> <li>New: If reporting is enabled, write unused bindings diagnostics to <code>keys-unused-*.txt</code>.</li> <li>New: Support for generic assisted injection.</li> <li>New: Support for generic member injection.</li> <li>New: Add diagnostic to prohibit type parameters on injected member functions.</li> <li>Enhancement: Enable child graphs to depend on parent-scoped dependencies that are unused and not referenced in the parent scope. This involves generating hints for scoped <code>@Inject</code> classes and is gated on a new Metro option <code>enableScopedInjectClassHints</code>, which is enabled by default.</li> <li>Enhancement: Check for context parameters in top-level function injection checker.</li> <li>Enhancement: Store member injection info in metro metadata to slightly optimize member injection code gen.</li> <li>Enhancement: Avoid writing providers fields in graphs for unused bindings.</li> <li>Enhancement: Improve missing binding trace originating from root member injectors.</li> <li>Fix: Fix support for generic injected constructor parameters.</li> <li>Fix: Fix support for repeated contributes annotations by moving contribution binding function generation to IR.</li> <li>Fix: Ensure scope/qualifier annotation changes on constructor-injected classes dirty consuming graphs in incremental compilation.</li> <li>Fix: Report member injection dependencies when looking up constructor-injected classes during graph population.</li> <li>Fix: Disable IR hint generation on JS targets too, as these now have the same limitation as native/WASM targets in Kotlin 2.2. Pending upstream support for generating top-level FIR declarations in KT-75865.</li> <li>Fix: Ensure private provider function annotations are propagated across compilation boundaries.</li> <li>Fix: Substitute copied FIR type parameter symbols with symbols from their target functions.</li> <li>Fix: Improved support for generic member injection.</li> <li>Fix: Propagate qualifiers on graph member injector functions.</li> <li>Fix: Fix support for requesting <code>MembersInjector</code> types.</li> <li>[internal] Report IR errors through <code>IrDiagnosticReporter</code>.</li> <li>[internal] Significantly refactor + simplify IR parameter handling.</li> <li>Fix publishing Apple native targets in snapshots.</li> <li>Update to Kotlin <code>2.2.0</code>.</li> <li>Update Gradle plugin to target Kotlin language version to <code>1.9</code> (requires Gradle 8.3+).</li> </ul> <p>Special thanks to @kevinguitar, @gabrielittner, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#038","title":"0.3.8","text":"<p>2025-06-16</p> <ul> <li>Enhancement: Disambiguate <code>MetroContribution</code> class names based on scope to better support IC when changing scopes.</li> <li>Enhancement: Minimize deferred types when breaking cycles.</li> <li>Fix: Disallow injection of <code>Lazy&lt;T&gt;</code> where <code>T</code> is an <code>@AssistedFactory</code>-annotated class.</li> <li>Fix: Don\u2019t short-circuit assisted injection validation if only an accessor exists.</li> <li>Fix: Allow cycles of assisted factories to their target classes.</li> <li>Update shaded okio to <code>3.13.0</code>.</li> <li>Update atomicfu to <code>0.28.0</code>.</li> </ul> <p>Special thanks to @kevinguitar, @bnorm, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#037","title":"0.3.7","text":"<p>2025-06-08</p> <ul> <li>Fix: Record lookups of generated static member inject functions for IC.</li> <li>Fix: Dedupe merged overrides of <code>@Includes</code> accessors.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#036","title":"0.3.6","text":"<p>2025-06-06</p> <ul> <li>New: Add new <code>Provider.map</code>, <code>Provider.flatMap</code>, <code>Provider.zip</code>, and <code>Provider.memoize</code> utility APIs.</li> <li>Enhancement: Improve graph validation performance by avoiding unnecessary intermediate sorts (again).</li> <li>Enhancement: Fail eagerly with a clear error message if <code>languageVersion</code> is too old.</li> <li>Enhancement: Validate improperly depending on assisted-injected classes directly at compile-time.</li> <li>Fix: Support constructing nested function return types for provider functions.</li> <li>Fix: Propagate <code>@Include</code> bindings from parent graphs to extension graphs.</li> <li>Fix: Reparent copied lambda default values in IR.</li> <li>[internal] Make internal renderings of <code>IrType</code> more deterministic.</li> </ul> <p>Special thanks to @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#035","title":"0.3.5","text":"<p>2025-05-31</p> <ul> <li>New: Implement top-level function injection checkers.</li> <li>Change: Disallow top-level function injections to be scoped.</li> <li>Fix: Support type parameters with <code>where</code> bounds.</li> <li>Fix: Support injected class type parameters with any bounds.</li> <li>Fix: Support generic graph factory interfaces.</li> <li>Fix: In the presence of multiple contributing annotations to the same scope, ensure only hint function/file is generated.</li> <li>Fix: Improve shading to avoid packaging in stdlib and other dependency classes.</li> <li>Fix: Revert #483 as it broke some cases we haven\u2019t been able to debug yet.</li> </ul> <p>Special thanks to @gabrielittner and @kevinguitar for contributing to this release!</p>"},{"location":"changelog/#034","title":"0.3.4","text":"<p>2025-05-27</p> <ul> <li>Enhancement: Use a simple numbered (but deterministic) naming for contributed graph classes to avoid long class names.</li> <li>Enhancement: Improve graph validation performance by avoiding unnecessary intermediate sorts.</li> <li>Enhancement: Move binding validation into graph validation step.</li> <li>Enhancement: Avoid unnecessary BFS graph walk in provider field collection.</li> <li>Fix: Fix provider field populating missing types that previously seen types dependent on.</li> </ul> <p>Special thanks to @ChristianKatzmann and @madisp for contributing to this release!</p>"},{"location":"changelog/#033","title":"0.3.3","text":"<p>2025-05-26</p> <ul> <li>Enhancement: Don\u2019t unnecessarily wrap <code>Provider</code> graph accessors.</li> <li>Enhancement: Allow multiple contributed graphs to the same parent graph.</li> <li>Fix: Don\u2019t unnecessarily recompute bindings for roots when populating graphs.</li> <li>Fix: Better handle generic assisted factory interfaces.</li> <li>Fix: Use fully qualified names when generating hint files to avoid collisions.</li> <li>Fix: Support provides functions with capitalized names.</li> <li>Fix: Prohibit consuming <code>Provider&lt;Lazy&lt;...&gt;&gt;</code> graph accessors.</li> <li>[internal] Migrate to new IR <code>parameters</code>/<code>arguments</code>/<code>typeArguments</code> compiler APIs.</li> </ul> <p>Special thanks to @gabrielittner for contributing to this release!</p>"},{"location":"changelog/#032","title":"0.3.2","text":"<p>2025-05-15</p> <ul> <li>Enhancement: Optimize supertype lookups in IR.</li> <li>Fix: Fix generic members inherited from generic supertypes of contributed graphs.</li> <li>Fix: Fix <code>@ContributedGraphExtension</code> that extends the same interface as the parent causes a duplicate binding error.</li> <li>Fix: Fix contributed binding replacements not being respected in contributed graphs.</li> <li>Fix: Fix contributed providers not being visible to N+2+ descendant graphs.</li> <li>Fix: Collect bindings from member injectors as well as exposed accessors when determining scoped provider fields.</li> <li>Fix: Fix a few <code>-Xverify-ir</code> and <code>-Xverify-ir-visibility</code> issues + run all tests with these enabled now.</li> </ul> <p>Special thanks to @bnorm, @gabrielittner, @kevinguitar, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#031","title":"0.3.1","text":"<p>2025-05-13</p> <ul> <li>Enhancement: Rewrite graph resolution using topological sorting to vastly improve performance and simplify generation.</li> <li>Enhancement: Return early once an externally-compiled dependency graph is found.</li> <li>Enhancement: Simplify multibinding contributor handling in graph resolution by generating synthetic qualifiers for each of them. This allows them to participate in standard graph resolution.</li> <li>Enhancement: When there are multiple empty <code>@Multibinds</code> errors, report them all at once.</li> <li>Enhancement: Avoid unnecessary <code>StringBuilder</code> allocations.</li> <li>Fix: Don\u2019t transform <code>@Provides</code> function\u2019s to be private if its visibility is already explicitly defined.</li> <li>Fix: Fix a comparator infinite loop vector.</li> <li>Fix: Fix <code>@ElementsIntoSet</code> multibinding contributions triggering a dependency cycle in some situations.</li> <li>Fix: Fix assertion error for generated multibinding name hint when using both @Multibinds and @ElementsIntoSet for the same multibinding.</li> <li>Fix: Fix contributed graph extensions not inheriting empty declared multibindings.</li> <li>Fix: Ensure we report the <code>@Multibinds</code> declaration location in errors if one is available.</li> <li>Fix: Dedupe overrides by all parameters not just value parameters.</li> <li>Fix: Dedupe overrides by signature rather than name when generating contributed graphs.</li> <li>Fix: Fix accidentally adding contributed graphs as child elements of parent graphs twice.</li> <li>Fix: Fix not deep copying <code>extensionReceiverParameter</code> when implementing fake overrides in contributed graphs.</li> <li>Fix: Report fully qualified qualifier renderings in diagnostics.</li> <li>Fix: Don\u2019t generate provider fields for multibinding elements unnecessarily.</li> <li>When debug logging + reports dir is enabled, output a <code>logTrace.txt</code> to the reports dir for tracing data.</li> <li>Update to Kotlin <code>2.1.21</code>.</li> </ul> <p>Special thanks to @asapha, @gabrielittner, @jzbrooks, and @JoelWilcox for contributing to this release!</p>"},{"location":"changelog/#030","title":"0.3.0","text":"<p>2025-05-05</p> <ul> <li>New: Add support for <code>@ContributesGraphExtension</code>! See the docs for more info.</li> <li>New: Add a <code>asContribution()</code> compiler intrinsic to upcast graphs to expected contribution types. For example: <code>val contributedInterface = appGraph.asContribution&lt;ContributedInterface&gt;()</code>. This is validated at compile-time.</li> <li>New: Automatically transform <code>@Provides</code> functions to be <code>private</code>. This is enabled by defaults and supersedes the <code>publicProviderSeverity</code> when enabled, and can be disabled via the Gradle extension or <code>transform-providers-to-private</code> compiler option. Note that properties and providers with any annotations with <code>KClass</code> arguments are not supported yet pending upstream kotlinc changes.</li> <li>Enhancement: Rewrite the internal <code>BindingGraph</code> implementation to be more performant, accurate, and testable.</li> <li>Enhancement: Add diagnostic to check that graph factories don\u2019t provide their target graphs as parameters.</li> <li>Enhancement: Add diagnostic to check that a primary scope is defined if any additionalScopes are also defined on a graph annotation.</li> <li>Enhancement: Add diagnostic to validate that contributed types do not have narrower visibility that aggregating graphs. i.e. detect if you accidentally try to contribute an <code>internal</code> type to a <code>public</code> graph.</li> <li>Enhancement: Optimize supertype lookups when building binding classes by avoiding previously visited classes.</li> <li>Enhancement: Don\u2019t generate hints for contributed types with non-public API visibility.</li> <li>Enhancement: When reporting duplicate binding errors where one of the bindings is contributed, report the contributing class in the error message.</li> <li>Enhancement: When reporting scope incompatibility, check any extended parents match the scope and suggest a workaround in the error diagnostic.</li> <li>Enhancement: Allow AssistedFactory methods to be protected.</li> <li>Fix: Fix incremental compilation when a parent graph or supertype modifies/removes a provider.</li> <li>Fix: Fix rank processing error when the outranked binding is contributed using Metro\u2019s ContributesBinding annotation.</li> <li>Fix: Fix <code>@Provides</code> graph parameters not getting passed on to extended child graphs.</li> <li>Fix: Fix qualifiers on bindings not getting seen by extended child graphs.</li> <li>Fix: Fix qualifiers getting ignored on accessors from <code>@Includes</code> dependencies.</li> <li>Fix: Fix transitive scoped dependencies not always getting initialized first in graph provider fields.</li> <li>Fix: Fix injected <code>lateinit var</code> properties being treated as if they have default values.</li> <li>Fix: Alias bindings not always having their backing type visited during graph validation.</li> <li>Fix: Fix race condition in generating parent graphs first even if child graph is encountered first in processing.</li> <li>Fix: Fallback <code>AssistedInjectChecker</code> error report to the declaration source.</li> <li>Fix: Fix missing parent supertype bindings in graph extensions.</li> <li>Change: <code>InstanceFactory</code> is no longer a value class. This wasn\u2019t going to offer much value in practice.</li> <li>Change: Change debug reports dir to be per-compilation rather than per-platform.</li> </ul> <p>Special thanks to @gabrielittner, @kevinguitar, @JoelWilcox, and @japplin for contributing to this release!</p>"},{"location":"changelog/#020","title":"0.2.0","text":"<p>2025-04-21</p> <ul> <li>New: Nullable bindings are now allowed! See the nullability docs for more info.</li> <li>Enhancement: Add diagnostics for multibindings with star projections.</li> <li>Enhancement: Add diagnostic for map multibindings with nullable keys.</li> <li>Fix: Ensure assisted factories\u2019 target bindings\u2019 parameters are processed in MetroGraph creation. Previously, these weren\u2019t processed and could result in scoped bindings not being cached.</li> <li>Fix: Fix duplicate field accessors generated for graph supertypes.</li> <li>Add compose navigation sample.</li> </ul> <p>Special thanks to @bnorm and @yschimke for contributing to this release!</p>"},{"location":"changelog/#013","title":"0.1.3","text":"<p>2025-04-18</p> <ul> <li>Change: Multibindings may not be empty by default. To allow an empty multibinding, <code>@Multibinds(allowEmpty = true)</code> must be explicitly declared now.</li> <li>New: Write graph metadata to reports (if enabled).</li> <li>New: Support configuring debug and reports globally via <code>metro.debug</code> and <code>metro.reportsDestination</code> Gradle properties (respectively).</li> <li>Enhancement: Change how aggregation hints are generated to improve incremental compilation. Externally contributed hints are now looked up lazily per-scope instead of all at once.</li> <li>Enhancement: Optimize empty map multibindings to reuse a singleton instance.</li> <li>Enhancement: Report error diagnostic if Dagger\u2019s <code>@Reusable</code> is used on a provider or injected class.</li> <li>Enhancement: Tweak diagnostic error strings for members so that IDE terminals auto-link them better. i.e., instead of printing <code>example.AppGraph.provideString</code>, Metro will print <code>example.AppGraph#provideString</code> instead.</li> <li>Enhancement: Support repeatable @ContributesBinding annotations with different scopes.</li> <li>Fix: Fix incremental compilation when <code>@Includes</code>-annotated graph parameters change accessor signatures.</li> <li>Fix: Don\u2019t allow graph extensions to use the same scope as any extended ancestor graphs.</li> <li>Fix: Don\u2019t allow multiple ancestor graphs of graph extensions to use the same scope.</li> <li>Fix: Handle scenarios where the compose-compiler plugin runs before Metro\u2019s when generating wrapper classes for top-level <code>@Composable</code> functions.</li> <li>Fix: Fix an edge case in graph extensions where child graphs would miss a provided scoped binding in a parent graph that was also exposed as an accessor.</li> <li>Fix: Fix Dagger interop issue when calling Javax/Jakarta/Dagger providers from Metro factories.</li> <li>Fix: Fix Dagger interop issue when calling <code>dagger.Lazy</code> from Metro factories.</li> <li>Fix: Preserve the original <code>Provider</code> or <code>Lazy</code> type used in injected types when generating factory creators.</li> <li>Temporarily disable hint generation in WASM targets to avoid file count mismatches until KT-75865.</li> <li>Add an Android sample: https://github.com/ZacSweers/metro/tree/main/samples/android-app</li> <li>Add a multiplatform Circuit sample: https://github.com/ZacSweers/metro/tree/main/samples/circuit-app</li> <li>Add samples docs: https://zacsweers.github.io/metro/samples</li> <li>Add FAQ docs: https://zacsweers.github.io/metro/faq</li> </ul> <p>Special thanks to @JoelWilcox, @bnorm, and @japplin for contributing to this release!</p>"},{"location":"changelog/#012","title":"0.1.2","text":"<p>2025-04-08</p> <ul> <li>Enhancement: Implement <code>createGraph</code> and <code>createGraphFactory</code> FIR checkers for better error diagnostics on erroneous type arguments.</li> <li>Enhancement: Add <code>ContributesBinding.rank</code> interop support with Anvil.</li> <li>Enhancement: Check Kotlin version compatibility. Use the <code>metro.version.check=false</code> Gradle property to disable these warnings if you\u2019re feeling adventurous.</li> <li>Fix: Fix class-private qualifiers on multibinding contributions in other modules not being recognized in downstream graphs.</li> <li>Fix: Fix member injectors not getting properly visited in graph validation.</li> <li>Fix: Fix a bug where <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> multibindings weren\u2019t always unwrapped correctly.</li> <li>Fix: Fix <code>Map&lt;Key, Provider&lt;Value&gt;&gt;</code> type keys not correctly interpreting the underlying type key as <code>Map&lt;Key, Value&gt;</code>.</li> <li>Change: Change <code>InstanceFactory</code> to a value class.</li> <li>Change: Make <code>providerOf</code> use <code>InstanceFactory</code> under the hood.</li> </ul> <p>Special thanks to @JoelWilcox, @bnorm, @japplin, @kevinguitar, and @erawhctim for contributing to this release!</p>"},{"location":"changelog/#011","title":"0.1.1","text":"<p>2025-04-03</p> <p>Initial release!</p> <p>See the announcement blog post: https://www.zacsweers.dev/introducing-metro/</p>"},{"location":"code-of-conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code-of-conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code-of-conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> <li>Respecting maintainers\u2019 time and not asking for ETAs</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others\u2019 private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code-of-conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code-of-conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code-of-conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at pandanomic@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code-of-conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code-of-conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code-of-conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code-of-conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code-of-conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code-of-conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla\u2019s code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing to Metro","text":"<p>Metro welcomes contributions! Small contributions like documentation improvements, small obvious fixes, etc are always good and don\u2019t need prior discussion. I liberally leave TODO comments in code that don\u2019t quite meet the standard of an issue but are still things worth improving :). For larger functionality changes or features, please raise a discussion or issue first before starting work.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>Local development with Metro is fairly straightforward. You should be able to clone the repo and open it in IntelliJ as a standard Gradle project.</p> <p>There are a few primary subprojects to consider.</p> <ol> <li><code>:compiler</code> \u2014 Metro\u2019s compiler plugin implementation lives. This includes compiler-supported interop features too.</li> <li><code>:compiler-tests</code> \u2014 Compiler tests using JetBrains\u2019 official compiler testing infrastructure.</li> <li><code>:gradle-plugin</code> \u2014 Metro\u2019s companion Gradle plugin implementation. Mostly just an extension API and compiler plugin wiring with KGP.<ul> <li>This is also where incremental compilation integration tests live!</li> </ul> </li> <li><code>:runtime</code> \u2014 Metro\u2019s core multiplatform runtime API. This is mostly annotations plus some small runtime APIs.</li> <li><code>:interop-dagger</code> \u2014 An ancillary set of JVM-only Dagger-specific runtime APIs for interop with Dagger.</li> <li><code>samples/</code> \u2014 A separate gradle project that contains several sample projects. This includes the core artifacts as an included build. You can add this project in IntelliJ as another Gradle project to support developing both. There are also some integration tests in here.</li> <li><code>:integration-tests</code> \u2014 self-explanatory.</li> <li><code>:multi-module-test</code> \u2014 A multi-module integration test.</li> </ol> <p>There is a useful <code>./metrow</code> helper CLI that can perform a few common commands across the various subprojects.</p> <p>[!TIP] Before submitting a PR, it is useful to run <code>regen</code> and <code>check</code>.</p> <ul> <li><code>./metrow format</code> \u2014 Runs all code formatters.</li> <li><code>./metrow regen</code> \u2014 Regenerates <code>.api</code> files and runs all code formatters.</li> <li><code>./metrow check</code> \u2014 Runs checks across all included Gradle projects (including samples and the Gradle plugin).</li> <li><code>./metrow publish --local --version x.y.z</code> \u2014 Publishes to maven local with the specified <code>x.y.z</code> version (replace this with whatever you want, like <code>1.0.0-LOCAL01</code>.)</li> </ul>"},{"location":"contributing/#testing","title":"Testing","text":"<p>Tests are spread across a few areas.</p> <ul> <li><code>compiler-tests/</code> \u2014 New compiler tests using JetBrains\u2019 official compiler testing infrastructure. If possible, write new compiler tests in here! See this PR for more details on how they work.</li> <li><code>compiler/src/test/</code> \u2014 Core compiler tests. These should be focused primarily on error testing but can also perform limited functional testing. Note that while many tests are here, new tests should ideally use <code>compiler-tests</code>.</li> <li><code>gradle-plugin/src/functionalTest</code> \u2014 Integration gradle tests, primarily focused on exercising different incremental compilation scenarios.</li> <li><code>samples/</code> \u2014 Some samples have tests! This is useful to assert that these samples work as expected.<ul> <li><code>integration-tests/</code> \u2014 Integration tests. These should only be functional in nature and not test error cases (error cases won\u2019t compile!). Note that new integration tests should usually be written in <code>compiler-tests</code>. Some scenarios, such as multi-compilation tests across Gradle, may make more sense to write here.</li> </ul> </li> </ul> <p>To publish to a local maven repo, run this:</p> <pre><code>./metrow publish --local --version 1.0.0-LOCAL01 # whatever version you want\n</code></pre>"},{"location":"contributing/#compiler-plugin-design","title":"Compiler Plugin Design","text":"<p>The compiler plugin is implemented primarily in two parts.</p>"},{"location":"contributing/#1-fir","title":"1. FIR","text":"<p>The FIR frontend generates declarations, generates supertypes, and performs diagnostic checks for Metro types. Any class or callable declaration generated by Metro should be done here as this is required for them to be visible in Kotlin metadata later.</p> <p>Generators go in the <code>dev.zacsweers.metro.compiler.fir.generators</code> package.</p> <p>Checkers go in the <code>dev.zacsweers.metro.compiler.fir.checkers</code> package.</p> <p>New checker contributions are generally welcome. New generators almost always warrant prior discussion first!</p>"},{"location":"contributing/#2-ir","title":"2. IR","text":"<p>The IR backend performs two main functions:</p> <ol> <li>Implements declarations generated in FIR. This includes generated graphs, factories, member injectors, etc.</li> <li>Performs dependency graph construction and validation. This is primarily spread across <code>DependencyGraphTransformer</code>, <code>BindingGraph</code>, and <code>Binding</code>.</li> </ol> <p>Most of this is implemented as transformers in the <code>dev.zacsweers.metro.compiler.ir.transformers</code> package. Note that all transformers are run from the <code>DependencyGraphTransformer</code>, which is the only true <code>IrTransformer</code> of the bunch and just delegates out to the other transformers as needed.</p> <p>Aggregation hint properties are also implemented in IR as a workaround to support incremental compilation. See <code>ContributionHintIrTransformer</code> for more details.</p>"},{"location":"contributing/#typekey-and-contextualtypekey","title":"<code>TypeKey</code> and <code>ContextualTypeKey</code>","text":"<p><code>TypeKey</code> and <code>ContextualTypeKey</code> (and their FIR counterparts) deserve special mention. Most of the compiler\u2019s dependency graph analysis thinks in terms of these two types.</p> <p>A <code>TypeKey</code> is the canonical representations of specific binding, composed of a type and optional qualifier.</p> <p>A <code>ContextualTypeKey</code> can be thought up as a <code>TypeKey</code> with context of how it\u2019s used. This is useful for a few reasons:</p> <ul> <li>Allows Metro\u2019s compiler plugin to generate code accordingly for how the given <code>TypeKey</code> is used at runtime, for example wrapping in <code>Provider</code>, <code>Lazy</code>, etc.</li> <li>Allows dependency graph resolution to understand if the type is deferrable, which is useful in breaking dependency cycles.</li> </ul>"},{"location":"contributing/#misc-notes","title":"Misc Notes","text":"<ul> <li>IR code should cache eagerly.</li> <li>FIR code should cache carefully (remember it runs in the IDE!).</li> <li>FIR code should be defensive. It may run continuously in the IDE and not all information may be available to the compiler as the user has written it. If you\u2019ve ever written a custom lint check, your methodology should be similar.</li> <li>Inversely, IR code should be offensive. Assert expectations with clear error messages, report errors with useful error messages.</li> <li>FIR-generated declaration should use descriptive keys to declarations that can be referenced later in FIR and IR (as <code>origins</code>). See <code>Keys.kt</code> for FIR declarations and <code>Origins.kt</code> for their IR analogs.</li> </ul>"},{"location":"debugging/","title":"Debugging","text":"<p>One major downside to generating IR directly is that developers cannot step into generated source code with the debugger. This is an accepted trade-off with Metro (or any other compiler plugin).</p> <p>Metro does offer a <code>debug</code> option in its plugin options/Gradle extension that will print verbose Kotlin pseudocode for all generated IR classes. This can be further tuned to print just certain classes.</p> <pre><code>metro {\n  debug.set(true)\n}\n</code></pre> <p>In the future, we could possibly explore including information in IR to synthesize call stack information similar to coroutines, but will save that for if/when it\u2019s asked for.</p>"},{"location":"debugging/#reports","title":"Reports","text":"<p>Similar to Compose, Metro supports a <code>reportsDestination</code> property in its Gradle DSL and can output various graph reports to this destination if specified. This is very much a WIP, feedback is welcome!</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre>"},{"location":"dependency-graphs/","title":"Dependency Graphs","text":"<p>The primary entry points in Metro are dependency graphs. These are interfaces annotated with <code>@DependencyGraph</code> and created with <code>@DependencyGraph.Factory</code> interfaces. Graphs expose types from the object graph via accessor properties or functions.</p> <p>Tip</p> <p>These are synonymous with components and <code>@Component</code>/<code>@Component.Factory</code> in Dagger and kotlin-inject.</p> <p>Tip</p> <p>\u201cAccessors\u201d in Metro are synonymous with Dagger\u2019s provision methods.</p> <p>Accessors and member injections act as roots, from which the dependency graph is resolved. Dependencies can be provided via conventional <code>@Provides</code> functions in graphs or their supertypes, constructor-injected classes, or accessed from graph dependencies.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @Provides\n  fun provideMessage(): String = \"Hello, world!\"\n}\n</code></pre> <p>Note the <code>@Provides</code> function must define an explicit return type.</p> <p>Simple graphs like this can be created via the <code>createGraph()</code> intrinsic.</p> <pre><code>val graph = createGraph&lt;AppGraph&gt;()\n</code></pre> <p>Graphs are relatively cheap and should be used freely.</p>"},{"location":"dependency-graphs/#inputs","title":"Inputs","text":"<p>Runtime inputs can be provided via a <code>@DependencyGraph.Factory</code> interface that returns the target graph. These parameters must be annotated with exactly one of <code>@Provides</code>, <code>@Includes</code>, or <code>@Extends</code>.</p>"},{"location":"dependency-graphs/#provides","title":"Provides","text":"<p>The simplest input is an instance parameter annotated with <code>@Provides</code>. This provides this instance as an available binding on the graph.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n</code></pre> <p>Provided parameters may be any type.</p> <p>Tip</p> <p>This is analogous to Dagger\u2019s <code>@BindsInstance</code>.</p>"},{"location":"dependency-graphs/#includes","title":"Includes","text":"<p><code>@Includes</code>-annotated parameters are treated as containers of available bindings. Metro will treat accessors of these types as usable dependencies.</p> <p>They are commonly other graph types whose\u2019 dependencies you want to consume via explicit API.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageGraph: MessageGraph): AppGraph\n  }\n\n  @DependencyGraph interface MessageGraph {\n    val message: String\n\n    @Provides fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre> <p><code>@Includes</code> instance dependencies do not need to be other graphs though! They can be any regular class type. They cannot be enums or annotation classes.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Includes messageProvider: MessageProvider): AppGraph\n  }\n\n  interface MessageProvider {\n    val message: String\n  }\n}\n</code></pre> <p>Warning</p> <p>Includes parameters cannot be injected from the graph.</p> <p>Binding Containers are a special type of <code>@Includes</code> type, see more in its section below.</p>"},{"location":"dependency-graphs/#extends","title":"Extends","text":"<p><code>@Extends</code>-annotated parameters are for extending parent graphs. See Graph Extensions at the bottom of this doc for more information.</p>"},{"location":"dependency-graphs/#creating-factories","title":"Creating factories","text":"<p>Graph factories can be created with the <code>createGraphFactory()</code> intrinsic.</p> <pre><code>val messageGraph =\n  createGraphFactory&lt;AppGraph.Factory&gt;()\n    .create(\"Hello, world!\")\n</code></pre>"},{"location":"dependency-graphs/#scoping","title":"Scoping","text":"<p>See Scopes for more details on scopes!</p> <p>Graphs may declare a <code>scope</code> (and optionally <code>additionalScopes</code> if there are more). Each of these declared scopes act as an implicit <code>@SingleIn</code> representation of that scope for aggregation.</p> <p>For example: <pre><code>@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre></p> <p>Is functionally equivalent to writing the below.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph(AppScope::class)\ninterface AppGraph\n</code></pre>"},{"location":"dependency-graphs/#graph-extensions","title":"Graph Extensions","text":"<p>Dependency graphs can be marked as extendable to allow child graphs to extend them. These are similar in functionality to Dagger\u2019s <code>Subcomponents</code> but are detached in nature like in kotlin-inject.</p> <p>A graph must opt itself into extension in via <code>@DependencyGraph(..., isExtendable = true)</code>, which will make the Metro compiler generate extra metadata for downstream child graphs.</p> <p>Then, a child graph can add an <code>@Extends</code>-annotated parameter to its creator to extend that graph.</p> <pre><code>@DependencyGraph(isExtendable = true)\ninterface AppGraph {\n  @Provides fun provideHttpClient(): HttpClient { ... }\n}\n\n@DependencyGraph\ninterface UserGraph {\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Extends appGraph: AppGraph): UserGraph\n  }\n}\n</code></pre> <p>Child graphs then contain a superset of bindings they can inject, including both their bindings and their parents\u2019. Graph extensions can be chained as well.</p> <p>Child graphs also implicitly inherit their parents\u2019 scopes.</p> <p>Hoisting unused scoped class injections in parent graphs</p> <p>In some cases, there are scoped bindings that are unused in the parent graph but are used in child graphs. Due to the detached nature of graph extensions, these bindings by default end up scoped to the child. To enforce that these bindings are scoped and held by the parent, Metro generates hints for these classes and discovers them during graph processing by default. You can disable this via the <code>enableScopedInjectClassHints</code> property in the Gradle DSL.</p> <p>See https://github.com/ZacSweers/metro/issues/377 for more details.</p>"},{"location":"dependency-graphs/#contributed-graph-extensions","title":"Contributed Graph Extensions","text":"<p><code>@ContributesGraphExtension</code> is a specialized type of graph that is contributed to some parent scope. Its generation is deferred until the parent graph interface is merged.</p>"},{"location":"dependency-graphs/#the-problem","title":"The Problem","text":"<p>Imagine this module dependency tree:</p> <pre><code>        :app\n      /     \\\n     v       v\n  :login   :user-data\n</code></pre> <p><code>:app</code> defines the main dependency graph with <code>@DependencyGraph</code>. The <code>:login</code> module defines a graph extension for authenticated user flows, and <code>:user-data</code> provides some core functionality like <code>UserRepository</code>.</p> <p>If <code>:login</code> defines its own graph directly with <code>@DependencyGraph</code>, it won\u2019t see contributions from <code>:user-data</code> unless <code>:login</code> depends on it directly.</p>"},{"location":"dependency-graphs/#the-solution","title":"The Solution","text":"<p>Instead, <code>:login</code> can use <code>@ContributesGraphExtension(LoggedInScope::class)</code> + an associated <code>@ContributesGraphExtension.Factory(AppScope::class)</code> to say: \u201cI want to contribute a new graph extension to a future <code>AppScope</code> parent graph.\u201d</p> <p>The graph extension will then be generated in <code>:app</code>, which already depends on both <code>:login</code> and <code>:user-data</code>. Now <code>UserRepository</code> can be injected in <code>LoggedInGraph</code>.</p> <pre><code>@ContributesGraphExtension(LoggedInScope::class)\ninterface LoggedInGraph {\n\n  val userRepository: UserRepository\n\n  @ContributesGraphExtension.Factory(AppScope::class)\n  interface Factory {\n    fun createLoggedInGraph(): LoggedInGraph\n  }\n}\n</code></pre> <p>In the <code>:app</code> module:</p> <pre><code>@DependencyGraph(AppScope::class, isExtendable = true)\ninterface AppGraph\n</code></pre> <p>The generated code will modify <code>AppGraph</code> to implement <code>LoggedInGraph.Factory</code> and implement <code>createLoggedInGraph()</code> using a generated final <code>$$ContributedLoggedInGraph</code> class that includes all contributed bindings, including <code>UserRepository</code> from <code>:user-data</code>.</p> <pre><code>interface AppGraph \n  // modifications generated during compile-time\n  : LoggedInGraph.Factory {\n  override fun createLoggedInGraph(): LoggedInGraph {\n    return $$ContributedLoggedInGraph(this)\n  }\n\n  // Generated in IR\n  @DependencyGraph(LoggedInScope::class)\n  class LoggedInGraph$$MetroGraph(appGraph: AppGraph) : LoggedInGraph {\n    // ...\n  }\n}\n</code></pre> <p>Finally, you can obtain a <code>LoggedInGraph</code> instance from <code>AppGraph</code> since it now implements <code>LoggedInGraph.Factory</code>:</p> <pre><code>// Using the asContribution() intrinsic\nval loggedInGraph = appGraph.asContribution&lt;LoggedInGraph.Factory&gt;().createLoggedInGraph()\n\n// Or if you have IDE support enabled\nval loggedInGraph = appGraph.createLoggedInGraph()\n</code></pre>"},{"location":"dependency-graphs/#graph-arguments","title":"Graph arguments","text":"<p>You can pass arguments to the graph via the factory:</p> <pre><code>@ContributesGraphExtension.Factory(AppScope::class)\ninterface Factory {\n  fun create(@Provides userId: String): LoggedInGraph\n}\n</code></pre> <p>This maps to:</p> <pre><code>// Generated in IR\n@DependencyGraph(LoggedInScope::class)\nclass $$ContributedLoggedInGraph(\n  @Extends parent: AppGraph,\n  @Provides userId: String\n): LoggedInGraph {\n  // ...\n}\n</code></pre> <p>In <code>AppGraph</code>, the generated factory method looks like:</p> <pre><code>// Generated in IR\noverride fun create(userId: String): LoggedInGraph {\n  return LoggedInGraph$$MetroGraph(this, userId)\n}\n</code></pre> <p>Warning</p> <p>Abstract factory classes cannot be used as graph contributions.</p> <p>Contributed graphs may also be chained, but note that <code>@ContributesGraphExtension.isExtendable</code> must be true to do so!</p>"},{"location":"dependency-graphs/#binding-containers","title":"Binding Containers","text":"<p>Binding containers are classes or interfaces annotated with <code>@BindingContainer</code> that contain binding declarations (<code>@Provides</code> or <code>@Binds</code>) but are not themselves complete dependency graphs. They\u2019re analogous to Dagger\u2019s <code>@Module</code> annotation and can be used in cases where defining bindings in an (extended) interface is unwieldy or not helpful.</p> <p>Unlike graphs and other <code>@Includes</code> types, their public accessors are not read. Only <code>@Binds</code> and <code>@Provides</code> declarations are read.</p> <p>Tip</p> <p>Binding containers can be seen as partial graphs and are intended to be reusable, composable units that are included in a complete graph.</p>"},{"location":"dependency-graphs/#including-via-includes-parameters","title":"Including via <code>@Includes</code> Parameters","text":"<p>The most flexible way to include binding containers is via <code>@Includes</code>-annotated parameters on graph factories.</p> <pre><code>@BindingContainer\nclass NetworkBindings(private val baseUrl: String) {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(baseUrl)\n}\n\n@DependencyGraph\ninterface AppGraph {\n  val httpClient: HttpClient\n\n  @DependencyGraph.Factory\n  interface Factory {\n    fun create(@Includes networkBindings: NetworkBindings): AppGraph\n  }\n}\n</code></pre> <p>This allows you to bring any instance to the graph with its own internal logic.</p>"},{"location":"dependency-graphs/#including-via-dependencygraphbindingcontainers","title":"Including via <code>@DependencyGraph.bindingContainers</code>","text":"<p>For simple binding containers, you can declare them directly in the graph annotation:</p> <pre><code>@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>This method works for: - <code>object</code> classes - <code>interface</code> or <code>abstract class</code> types with only <code>@Binds</code> providers or companion object <code>@Provides</code> providers - Simple classes with a public, no-arg constructor</p>"},{"location":"dependency-graphs/#chaining-binding-containers","title":"Chaining Binding Containers","text":"<p>Binding containers can include other binding containers using the <code>includes</code> parameter:</p> <pre><code>@BindingContainer\nobject CacheBindings {\n  @Provides fun provideHttpCache(): Cache = Cache()\n}\n\n@BindingContainer(includes = [CacheBindings::class])\nobject NetworkBindings {\n  @Provides fun provideHttpClient(cache: Cache): HttpClient = HttpClient(cache)\n}\n\n@DependencyGraph(bindingContainers = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>The transitive closure of all included binding containers will be included in the final consuming graph.</p>"},{"location":"dependency-graphs/#contributing-binding-containers","title":"Contributing Binding Containers","text":"<p>Binding containers can be contributed to scopes via <code>@ContributesTo</code>:</p> <pre><code>@ContributesTo(AppScope::class)\n@BindingContainer\nobject NetworkBindings {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph(AppScope::class)\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre> <p>They can also replace other contributed binding containers:</p> <pre><code>// In a test variant\n@ContributesTo(AppScope::class, replaces = [NetworkBindings::class])\n@BindingContainer\nobject FakeNetworkBindings {\n  @Provides fun provideFakeHttpClient(): HttpClient = FakeHttpClient()\n}\n</code></pre> <p>Graphs may exclude contributed containers:</p> <pre><code>@DependencyGraph(AppScope::class, excludes = [NetworkBindings::class])\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n</code></pre>"},{"location":"dependency-graphs/#notes","title":"Notes","text":"<ul> <li>Companion objects, annotation classes, and enum classes/entries cannot be annotated with <code>@BindingContainer</code></li> <li>Companion object providers within a binding container are automatically included</li> <li>Enclosing classes of <code>@Binds</code> or <code>@Provides</code> providers don\u2019t need to be annotated with <code>@BindingContainer</code> for Metro to process them - the annotation is primarily for reference to <code>@DependencyGraph.Factory</code> and the ability to use <code>includes</code></li> <li>Binding containers may also be contributed.</li> <li>See #172 for more details.</li> </ul>"},{"location":"dependency-graphs/#implementation-notes","title":"Implementation Notes","text":"<p>Dependency graph code gen is designed to largely match how Dagger components are generated.</p> <ul> <li>Internal graph validation uses Tarjan\u2019s algorithm + topological sort implementation.</li> <li>This runs in O(V+E) time</li> <li>The returned ordered list of bindings can be used to determine provider field generation order.</li> <li>Any binding whose order depends on one later in the returned order implicitly requires use of <code>DelegateFactory</code>.</li> <li>Dependencies are traversed from public accessors and <code>inject()</code> functions.</li> <li>Metro generates Provider Factory classes for each provider. These should be generated at the same time that the provider is compiled so that their factory classes. This is for two primary purposes:<ul> <li>They can be reused to avoid code duplication</li> <li>Metro can copy default values for provider values over to the generated factory to support optional bindings. Since default values may refer to private references, we must generate these factories as nested classes.</li> </ul> </li> <li>Metro generates a graph impl class that holds all aggregated bindings and manages scoping.</li> <li>Scoped bindings are stored in provider fields backed by <code>DoubleCheck</code>.</li> <li>Reused unscoped providers instances are stored in reusable fields.</li> <li><code>@Provides</code> factory parameters are stored in a field backed by <code>InstanceFactory</code>.</li> <li>Multibindings create new collection instances every time.</li> <li>Multibinding providers are not accessible as standalone bindings.</li> <li>Graph extensions are implemented via a combination of things<ul> <li>Custom <code>MetroMetadata</code> is generated and serialized into Kotlin\u2019s <code>Metadata</code> annotations.</li> <li>Extendable parent graphs opt-in to generating this metadata. They write information about their available provider and instance fields, binds callable IDs, parent graphs, and provides callable IDs.</li> <li>Extendable parent graphs generate <code>_metroAccessor</code>-suffixed <code>internal</code> functions that expose instance fields and provider fields.</li> <li>Child graphs read this metadata and look up the relevant callable symbols, then incorporating these when building its own binding graph.</li> </ul> </li> </ul>"},{"location":"differences/","title":"Differences from other DI frameworks","text":""},{"location":"differences/#from-dagger","title":"\u2026from Dagger","text":"<ul> <li><code>@Binds</code> and <code>@Provides</code> declarations can be added directly within graphs and their supertypes.<ul> <li><code>@BindingContainer</code> is the Metro equivalent of a Dagger <code>@Module</code> but it should rarely be used.</li> <li><code>@BindingContainer</code> cannot declare graph extensions in the way <code>@Module</code> can declare subcomponents. Use <code>@ContributesGraphExtension</code>.</li> </ul> </li> <li>There is no Producers support.</li> <li>There is no Hilt support, though some features are similar in the same way that Anvil\u2019s features are similar.</li> <li>There is no <code>@Reusable</code>.</li> <li>There is no <code>@BindsOptionalOf</code>. Instead, Metro supports default optional dependencies.</li> <li>There is no <code>@Subcomponent</code>. Instead, Metro uses graph extensions.</li> <li>Metro can inject private properties and functions.</li> <li>There is no <code>@BindsInstance</code>. Use <code>@Provides</code> on <code>@DependencyGraph.Factory</code> function parameters instead</li> <li>Component dependencies must be annotated with <code>@Includes</code>.</li> <li>Metro does not process Java code.</li> <li><code>@Multibinds</code> declarations are implemented in Metro graphs to return the declared multibinding.</li> <li>Empty multibindings are an error by default in Metro. To allow a multibinding to be empty, it must be declared with <code>@Multibinds(allowEmpty = true)</code>.</li> <li>Metro graph classes may not directly extend other graph classes. You should use <code>@Extends</code> instead in Metro.</li> <li>Dagger technically allows this, but only accessors and injectors cross these boundaries.</li> </ul>"},{"location":"differences/#from-kotlin-inject","title":"\u2026from Kotlin-Inject","text":"<ul> <li>typealiases are not treated as implicit qualifiers.</li> <li>Dependency graph classes cannot have primary constructors, their parameters must be defined as <code>@Provides</code> or graph parameters on a <code>@DependencyGraph.Factory</code> function like Dagger.</li> <li>Higher order functions cannot be used. Instead, use <code>Provider</code> and declared <code>@AssistedFactory</code>-annotated types.</li> <li>No need for use-site targets for most annotations.</li> <li>No need for <code>@get:Provides Impl.bind: Type get() = this</code> to achieve type bindings. See the docs on <code>@Binds</code>.</li> <li>Metro can inject private properties and functions.</li> <li>When extending parent graphs, they must be annotated with <code>@Extends</code> in the child graph\u2019s creator.</li> <li>Metro does not process Java code.</li> <li>Metro does not support assisted parameters in <code>@Provides</code> functions.</li> </ul>"},{"location":"differences/#from-anvil","title":"\u2026from Anvil","text":"<ul> <li>There is no <code>rank</code> in Metro\u2019s <code>@Contributes*</code> annotations.<ul> <li>Note that if Anvil interop is enabled, its <code>rank</code> properties are supported in interop.</li> </ul> </li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> <li><code>@Contributes*.replaces</code> cannot replace classes in the same compilation as the graph that is merging them</li> <li>Metro only merges graphs and cannot merge arbitrary interfaces.</li> </ul>"},{"location":"differences/#from-kotlin-inject-anvil","title":"\u2026from kotlin-inject-anvil","text":"<ul> <li>There is no need for <code>@CreateComponent</code> or <code>expect fun createComponent()</code> functions.</li> <li><code>@ContributesBinding</code> uses a <code>binding</code> API to support generic bound types. See the aggregation docs for more info.<ul> <li>Note that if Anvil interop is enabled, its <code>boundType</code> properties are supported in interop.</li> </ul> </li> <li><code>@Contributes*.replaces</code> cannot replace classes in the same compilation as the graph that is merging them</li> </ul>"},{"location":"faq/","title":"FAQ","text":"<p>This is a list of frequently asked questions about Metro. Consider also searching the issue tracker and discussions section of the Metro repo for anything not covered here!</p>"},{"location":"faq/#compiler-plugins-are-not-a-stable-api-is-metro-safe-to-use","title":"Compiler plugins are not a stable API, is Metro safe to use?","text":"<p>This is a fair question! Metro will often require new companion releases for each Kotlin release. This is a part of life when using compiler plugins. That said, Kotlin does extensive beta/RC cycles that Metro will test against and turn around new releases within a day or two barring any unexpected circumstances (or vacation!)</p> <p>The harder issue is going to be IDE support, as the Kotlin IDE plugin branches independently from regular Kotlin releases. Right now the answer is \u201cYMMV\u201d, but we\u2019re exploring a couple solutions for this to ensure better stability.</p>"},{"location":"faq/#will-metro-add-support-for-hilt-features-or-hilt-interop","title":"Will Metro add support for Hilt features or Hilt interop?","text":"<p>Metro is largely inspired by Dagger and Anvil, but not Hilt. Hilt works in different ways and has different goals. Hilt is largely focused around supporting android components and relies heavily on subcomponents to achieve this.</p> <p>Some features overlap but just work differently in Metro:</p> <ul> <li>Instead of <code>@UninstallModules</code> and <code>@TestInstallIn</code>, Metro graphs can exclude aggregations and contributed bindings can replace other bindings.</li> <li>Hilt has support for injecting <code>ViewModel</code>s, but this is entirely doable without Hilt as well by just creating a multibinding. See the android-app sample for an example.</li> <li>Hilt has support for aggregation with <code>@InstallIn</code>, Metro uses <code>@Contributes*</code> annotations.</li> </ul> <p>Some features are focused around injecting Android framework components. There are two arguably better solutions to this and one not-better solution.</p> <ol> <li>(Not better) Expose injector functions on a graph to do member injection directly from the graph.</li> <li>(Better) Constructor-inject these types using <code>AppComponentFactory</code>. This does require minSdk 28. When Hilt was first released in 2020, this was a relatively new API. However, 2020 was a long time ago! minSdk 28+ is much more common today, making this much more feasible of a solution.</li> <li>(Best) Use an app architecture that better abstracts away the surrounding Android framework components, making them solely entry points.</li> </ol> <p>The rest of Hilt\u2019s features focus on gluing these pieces together and also supporting Java (which Metro doesn\u2019t support).</p>"},{"location":"faq/#why-doesnt-metro-support-reusable","title":"Why doesn\u2019t Metro support <code>@Reusable</code>?","text":"<p>Some technical context</p> <p><code>@Reusable</code> works almost identically in code gen as scoped types, it just uses <code>SingleCheck</code> instead of <code>DoubleCheck</code>. It\u2019s basically like using <code>lazy(NONE)</code> instead of <code>lazy(SYNCHRONIZED)</code>.</p> <p>A few different reasons Metro doesn\u2019t have it</p> <ul> <li>I think it risks being like <code>@Stable</code> in compose where people chase it for perceived performance benefits that they have not profiled or would not actualize if they did. Basically it becomes a premature optimization vector<ul> <li>Ron Shapiro (the author of it) even said you shouldn\u2019t use it or scoping in general [for performance reasons] unless you\u2019ve measured it: https://medium.com/@shapiro.rd/reusable-has-many-of-the-same-costs-as-singleton-c20b5d1ef308</li> </ul> </li> <li>Most people don\u2019t really know when to use it. It doesn\u2019t really strike a balance so much as blurs the line for limited value (see: the first bullet).</li> <li>It invites people to make unclear assumptions. It\u2019s pretty simple to assume something stateful is always a new instance or always the same scoped instance. It is harder to envision scenarios where you have stateful types where you don\u2019t care about knowing if it\u2019s shared or not. You could say this should only be for stateless types then, but then you\u2019re deciding\u2026<ul> <li>Do you want to limit instances? Just scope it</li> <li>Do you not care about limiting instances? Don\u2019t scope it</li> </ul> </li> <li>What\u2019s the expected behavior if you have a <code>@Reusable</code> type <code>Thing</code> and then request a <code>Lazy&lt;Thing&gt;</code> elsewhere? Currently, Metro <code>DoubleCheck.lazy(...)</code>\u2019s whatever binding provides it at the injection site, which would then defeat this. To undo that, Metro would need to introduce some means of indicating \u201cwhat kind\u201d of <code>Lazy</code> is needed, which just complicates things for the developer.</li> </ul>"},{"location":"features/","title":"Features","text":""},{"location":"features/#familiar-semantics","title":"Familiar semantics","text":"<p>Metro builds on top of established patterns from existing DI frameworks with familiar semantics like constructor injection, providers, multibindings, scopes, assisted injection, and intrinsics like Provider/Lazy.</p>"},{"location":"features/#compile-time-validation","title":"Compile-time validation","text":"<p>Like Dagger and KI, Metro validates your dependency graph at compile-time.</p>"},{"location":"features/#compile-time-firir-code-gen","title":"Compile-time FIR+IR code gen","text":"<p>Metro is implemented entirely as a Kotlin compiler plugin, primarily using FIR for error reporting and both FIR and IR for code gen. This affords significant build performance and wins compared to Dagger and KAPT/KSP in two ways:</p> <ul> <li>It avoids extra Kotlin compiler (frontend) invocations to analyze sources and generate new sources.</li> <li>It generates new code to FIR/IR directly, allowing it to be lowered directly into target platforms</li> </ul> <p>FIR/IR generation allows Metro to generate code directly into existing classes, which in turn allows it to do certain things that source-generation cannot. This includes:</p> <ul> <li>Private <code>@Provides</code> declarations.</li> <li>Injection of private member properties and functions.</li> <li>Copying + reuse of default value expressions for optional dependencies, even if they reference private APIs within the source class.</li> </ul>"},{"location":"features/#dagger-esque-code-gen-and-runtime","title":"Dagger-esque code gen and runtime","text":"<ul> <li>Metro\u2019s generated code is similar to Dagger: lean, limited duplication, and practical.</li> <li>Metro\u2019s runtime is similar to Dagger. This includes patterns like <code>DoubleCheck</code>, heavy use of factories, and an assumption that this is going to run in a large/modularized codebase.</li> </ul>"},{"location":"features/#kotlin-inject-esque-api","title":"Kotlin-Inject-esque API","text":"<p>Metro\u2019s user-facing API is similar to kotlin-inject: focused on simplicity and leaning into kotlin-language features.</p> <ul> <li>Top-level function injection</li> <li>Providers live in graph interfaces or supertypes</li> <li>Native support for optional bindings via default parameter values</li> <li>Use of Kotlin\u2019s native <code>Lazy</code> type for lazy injections</li> </ul>"},{"location":"features/#anvil-esque-aggregation","title":"Anvil-esque aggregation","text":"<p>Like Anvil, Metro supports contributing types via aggregation with annotations like <code>@ContributesTo</code>, <code>@ContributesBinding</code>, etc.</p>"},{"location":"features/#multiplatform","title":"Multiplatform","text":"<p>Metro is multiplatform and supports most major Kotlin multiplatform targets.</p> <p>Warning</p> <p>Multi-module multiplatform targets cannot contribute dependencies (i.e. with <code>@Contributes*</code> annotations) from native targets until https://youtrack.jetbrains.com/issue/KT-75865.</p>"},{"location":"features/#ide-integration","title":"IDE Integration","text":"<p>Most errors are reported in FIR, which should (eventually) be visible in the K2 IDE plugin as well.</p>"},{"location":"features/#helpful-diagnostics","title":"Helpful diagnostics","text":"<p>Metro tries its best to give detailed-yet-readable error messages and diagnostics.</p> <pre><code>e: ExampleGraph.kt:8:3 [Metro/MissingBinding] Cannot find an @Inject constructor or @Provides-annotated function/property for: kotlin.Int\n\n    kotlin.Int is requested at\n        [test.ExampleGraph] test.ExampleGraph.int\n\nSimilar bindings:\n  - @Named(\"qualified\") Int (Different qualifier). Type: Provided. Source: ExampleGraph.kt:11:3\n  - Number (Supertype). Type: Provided. Source: ExampleGraph.kt:10:3\n  - Set&lt;Int&gt; (Multibinding). Type: Multibinding.\n</code></pre> <p>For more thorough debugging, Metro also has controls to enable debug logging controls and write graph reports to an output directory (configurable via the Gradle extension).</p>"},{"location":"features/#advanced-interop","title":"Advanced interop","text":"<p>Metro has advanced interop with existing DI tools.</p> <ul> <li>Metro supports component-level interop with Dagger and kotlin-inject. This means that Metro graphs can depend on Dagger and kotlin-inject components via <code>@Includes</code> dependencies.</li> <li>Metro supports defining user-defined alternatives for common annotations in addition to its first-party options. This allows easier introduction to codebases using annotations from existing DI frameworks.</li> <li>If Dagger interop is enabled, Metro can generate code that both interops with Dagger/Javax/Jakarta\u2019s types directly as well as reuse Dagger/Anvil\u2019s generated factories.</li> <li>If Anvil interop is enabled, Metro\u2019s compiler can interpret Anvil\u2019s <code>@ContributesMultibinding</code> and <code>boundType</code> APIs.</li> </ul>"},{"location":"generating-metro-code/","title":"Generating Metro Code","text":"<p>Java annotation processing and KSP both support multiple rounds of processing, allowing custom processors to generate new code with injection annotations that can be processed in later rounds. Anvil supported custom <code>CodeGenerator</code> implementations in K1 and anvil-ksp and kotlin-inject-anvil support specifying custom contributing annotations to allow them to intelligently defer processing to later rounds.</p> <p>Since Metro is implemented as a compiler plugin, asking users to write compiler plugins to interact with it would be a bit unwieldy. However, KSP processors that generate metro-annotated code work out of the box with it since they run before Metro\u2019s plugin does.</p> <p>If you have an existing KSP processor for a different framework, you could leverage it + custom annotations interop support described above to make them work out of the box with Metro.</p>"},{"location":"injection-types/","title":"Injection Types","text":"<p>Metro supports multiple common injection types.</p>"},{"location":"injection-types/#constructor-injection","title":"Constructor Injection","text":"<p>Most types should use constructor injection if possible. For this case, you can annotate either a class itself (if it has exactly one, primary constructor) or exactly one specific constructor.</p> <pre><code>@Inject\nclass ClassInjected\n\nclass SpecificConstructorInjection(val text: String) {\n  @Inject constructor(value: Int) : this(value.toString())\n}\n</code></pre> <p>Constructor-injected classes can be instantiated+managed entirely by Metro and encourages immutability.</p>"},{"location":"injection-types/#assisted-injection","title":"Assisted Injection","text":"<p>For types that require dynamic dependencies at instantiation, assisted injection can be used to supply these inputs. In this case - an injected constructor (or class with one constructor) must be annotated with <code>@Inject</code>, assisted parameters annotated with <code>@Assisted</code>, and a factory interface or abstract class with one single abstract function that accepts these assisted parameters and returns the target class.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted val timeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeout: Duration): HttpClient\n  }\n}\n</code></pre> <p>Then, the <code>@AssistedFactory</code>-annotated type can be accessed from the dependency graph.</p> <pre><code>@Inject\nclass ApiClient(httpClientFactory: HttpClient.Factory) {\n  private val httpClient = httpClientFactory.create(30.seconds)\n}\n</code></pre> <p>Like Dagger, the <code>@Assisted</code> parameters can take optional <code>value</code> keys to disambiguate matching types.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted(\"connect\") val connectTimeout: Duration,\n  @Assisted(\"request\") val requestTimeout: Duration,\n  val cache: Cache\n) {\n  @AssistedFactory\n  fun interface Factory {\n    fun create(\n      @Assisted(\"connect\") connectTimeout: Duration,\n      @Assisted(\"request\") requestTimeout: Duration,\n    ): HttpClient\n  }\n}\n</code></pre>"},{"location":"injection-types/#automatic-assisted-factory-generation","title":"Automatic Assisted Factory Generation","text":"<p>Metro supports automatic generation of assisted factories via opt-in compiler option. If enabled, Metro will automatically generate a default factory as a nested class within the injected type.</p> <pre><code>@Inject\nclass HttpClient(\n  @Assisted timeoutDuration: Duration,\n  cache: Cache,\n) {\n  // Generated by Metro\n  @AssistedFactory\n  fun interface Factory {\n    fun create(timeoutDuration: Duration): HttpClient\n  }\n}\n</code></pre> <p>If a nested class called <code>Factory</code> is already present, Metro will do nothing.</p>"},{"location":"injection-types/#why-opt-in","title":"Why opt-in?","text":"<p>The main reason this is behind an opt-in option at the moment is because compiler plugin IDE support is rudimentary at best and currently requires enabling a custom registry flag. See the docs for how to enable IDE support.</p> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  generateAssistedFactories.set(true)\n}\n</code></pre>"},{"location":"injection-types/#member-injection","title":"Member Injection","text":"<p>Metro supports member injection to inject mutable properties or functions post-construction or into existing class instances.</p> <p>This can be useful for classes that cannot be constructor-injected, for example Android Activity classes (on older SDK versions) as well as constructor-injected classes that perhaps don\u2019t want or need to expose certain types directly in their constructors.</p> <p>Tip</p> <p>Unlike Dagger and kotlin-inject, injected members in Metro can be <code>private</code>.</p> <p>Note</p> <p>Member function injection does not (currently) support default values.</p> <pre><code>class ProfileActivity : Activity() {\n  // Property injection\n  @Inject private lateinit var db: UserDatabase\n\n  @Inject private var notifications: Notifications? = null\n\n  // Function injection\n  @Inject private fun injectUser(user: User) {\n    // ...\n  }\n}\n</code></pre> <p>Like Dagger, these classes can be injected via multiple avenues.</p>"},{"location":"injection-types/#1-in-constructor-injected-types-inject-annotated-members-are-injected-automatically","title":"1. In constructor-injected types, <code>@Inject</code>-annotated members are injected automatically.","text":"<pre><code>// Injection with constructor injection\n@Inject\nclass ProfileInjector(\n  // ...\n) {\n  // Automatically injected during constructor injection\n  @Inject private fun injectUser(value: String) {\n    // ...\n  }\n}\n</code></pre> <p>In these cases, Metro will automatically inject these members automatically and immediately after instantiation during constructor injection.</p>"},{"location":"injection-types/#2-exposing-a-fun-injecttarget-profileactivity-function-on-the-graph","title":"2. Exposing a <code>fun inject(target: ProfileActivity)</code> function on the graph","text":"<pre><code>// Graph inject() functions\n@DependencyGraph\ninterface AppGraph {\n  // ...\n\n  fun inject(target: ProfileActivity)\n}\n\n// Somewhere else\nval graph = createGraph&lt;AppGraph&gt;()\ngraph.inject(profileActivity)\n</code></pre> <p>With this option, you can call <code>graph.inject(target)</code> on the instance with members you wish to inject.</p>"},{"location":"injection-types/#3-requesting-a-membersinjector-instance-from-the-dependency-graph","title":"3. Requesting a <code>MembersInjector</code> instance from the dependency graph.","text":"<pre><code>// Injection with MembersInjector\n@Inject\nclass ProfileInjector(\n  private val injector: MembersInjector&lt;ProfileActivity&gt;\n) {\n  fun performInjection(activity: ProfileActivity) {\n    injector.inject(activity)\n  }\n}\n</code></pre> <p>Like Dagger, option #3 is accomplished via <code>MembersInjector</code> interface at runtime and in code gen. This should be reserved for advanced use cases.</p>"},{"location":"injection-types/#implementation-notes","title":"Implementation notes","text":"<ul> <li>Property accessors don\u2019t use <code>get</code>/<code>set</code> names in <code>inject{name}()</code> function names.</li> <li>MembersInjector classes are generated as nested classes, allowing private member access.<ul> <li>This includes parent classes\u2019 private members (!!)</li> </ul> </li> <li>Optional bindings are not supported for injected member functions currently, but may be possible in the future.</li> </ul>"},{"location":"injection-types/#top-level-function-injection","title":"Top-level Function Injection","text":"<p>Like KI, Metro supports top-level function injection (behind an opt-in compiler option). The primary use case for this is composable functions and standalone applications that run from <code>main</code> functions.</p> <pre><code>@Inject\nfun App(message: String) {\n  // ...\n}\n</code></pre> <p>To do this, Metro\u2019s FIR plugin will generate a concrete type that acts as a bridge for this function.</p> <pre><code>@Inject\nclass AppClass(\n  private val message: Provider&lt;String&gt;\n) {\n  operator fun invoke() {\n    App(message())\n  }\n}\n</code></pre> <p>Because it\u2019s generated in FIR, this type will be user-visible in the IDE and can then be referenced in a graph.</p> <p>Note that this feature requires enabling third party FIR plugins in the IDE to fully work. It will compile without it, but generated wrapper classes will be red/missing in the IDE.</p> <p>Note</p> <p>The generated class is called <code>&lt;function name&gt;</code> + <code>Class</code> because of a limitation in the Kotlin compiler. TODO Link issue?</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  val app: AppClass\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): AppGraph\n  }\n}\n\n// Usage\nval app = createGraphFactory&lt;AppGraph.Factory&gt;()\n  .create(\"Hello, world!\")\n  .app\n\n// Run the app\napp()\n</code></pre> <p>To add assisted parameters, use <code>@Assisted</code> on the parameters in the function description. These will be propagated accordingly.</p> <pre><code>@Inject\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval app = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Run the app\napp(\"Hello, world!\")\n</code></pre> <p>This is particularly useful for Compose, and <code>@Composable</code> functions will be copied over accordingly.</p> <pre><code>@Inject\n@Composable\nfun App(@Assisted message: String) {\n  // ...\n}\n\n// Generates...\n@Inject\nclass AppClass {\n  @Composable\n  operator fun invoke(message: String) {\n    App(message)\n  }\n}\n\n// Usage\nval App = createGraph&lt;AppGraph&gt;()\n  .app\n\n// Call it in composition\nsetContent {\n  App(\"Hello, world!\")\n}\n</code></pre> <p>Similarly, if the injected function is a <code>suspend</code> function, the <code>suspend</code> keyword will be ported to the generated <code>invoke()</code> function too.</p>"},{"location":"injection-types/#why-opt-in_1","title":"Why opt-in?","text":"<p>There are two reasons this is behind an opt-in option at the moment.</p> <ol> <li>Generating top-level declarations in Kotlin compiler plugins (in FIR specifically) is not    currently compatible with incremental compilation.</li> <li>IDE support is rudimentary at best and currently requires enabling a custom registry flag.    See the docs for how to enable IDE support.</li> </ol> <p>Because of this, it\u2019s likely better for now to just hand-write the equivalent class that Metro generates. If you still wish to proceed with using this, it can be enabled via the Gradle DSL.</p> <pre><code>metro {\n  enableTopLevelFunctionInjection.set(true)\n}\n</code></pre>"},{"location":"injection-types/#implementation-notes_1","title":"Implementation notes","text":"<ul> <li>This is fairly different from kotlin-inject\u2019s typealias approach. This is necessary because Metro doesn\u2019t use higher order function types or typealiases as qualifiers.</li> <li>Since the compose-compiler\u2019s IR transformer may run before Metro\u2019s, we check for this during implementation body generation and look up the transformed target composable function as needed.</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Metro is primarily applied via its companion Gradle plugin.</p> <pre><code>plugins {\n  kotlin(\"multiplatform\") // or jvm, android, etc\n  id(\"dev.zacsweers.metro\")\n}\n</code></pre> <p>\u2026and that\u2019s it! This will add metro\u2019s runtime dependencies and do all the necessary compiler plugin wiring.</p> <p>If applying in other build systems, apply it however that build system conventionally applies Kotlin compiler plugins. For example with Bazel:</p> <pre><code>load(\"@rules_kotlin//kotlin:core.bzl\", \"kt_compiler_plugin\")\nload(\"@rules_kotlin//kotlin:jvm.bzl\", \"kt_jvm_library\")\n\nkt_compiler_plugin(\n    name = \"metro_plugin\",\n    compile_phase = True,\n    id = \"dev.zacsweers.metro.compiler\",\n    options = {\n        \"enabled\": \"true\",\n        \"debug\": \"false\",\n    },\n    deps = [\n        \"@maven//:dev_zacsweers_metro_compiler\",\n    ],\n)\n\nkt_jvm_library(\n    name = \"sample\",\n    # The SampleGraph class is annotated with @DependencyGraph\n    srcs = [\"SampleGraph.kt\"],\n    plugins = [\n        \":metro_plugin\",\n    ],\n    deps = [\n        \"@maven//:dev_zacsweers_metro_runtime_jvm\",\n    ],\n)\n</code></pre>"},{"location":"installation/#ide-support","title":"IDE Support","text":"<p>The K2 Kotlin IntelliJ plugin supports running third party FIR plugins in the IDE, but this feature is hidden behind a flag. Some Metro features can take advantage of this, namely diagnostic reporting directly in the IDE and some opt-in features to see generated declarations. </p> <p>To enable it, do the following:</p> <ol> <li>Enable K2 Mode for the Kotlin IntelliJ plugin.</li> <li>Open the Registry</li> <li>Set the <code>kotlin.k2.only.bundled.compiler.plugins.enabled</code> entry to <code>false</code>.</li> </ol> <p>Note that support is unstable and subject to change.</p>"},{"location":"interop/","title":"Interop","text":""},{"location":"interop/#annotations","title":"Annotations","text":"<p>Metro supports user-defined annotations for common annotations. This means that a user doesn\u2019t necessarily have to use Metro\u2019s annotations if they\u2019re introducing it to an existing codebase. Support varies depending on the annotation\u2019s use case.</p> <p>Compile-only annotations are mostly supported. This includes the following:</p> <ul> <li><code>@AssistedFactory</code></li> <li><code>@AssistedInject</code></li> <li><code>@Assisted</code></li> <li><code>@BindsInstance</code></li> <li><code>@Binds</code></li> <li><code>@ContributesBinding</code></li> <li><code>@ContributesTo</code></li> <li><code>@DependencyGraph.Factory</code></li> <li><code>@DependencyGraph</code></li> <li><code>@ElementsIntoSet</code></li> <li><code>@Inject</code></li> <li><code>@IntoMap</code></li> <li><code>@IntoSet</code></li> <li><code>@MapKey</code></li> <li><code>@Module</code></li> <li><code>@Multibinds</code></li> <li><code>@Provides</code></li> <li><code>@Qualifier</code></li> <li><code>@Scope</code></li> </ul> <p>These are configurable via Metro\u2019s Gradle extension.</p> <pre><code>metro {\n  interop {\n    assisted.add(\"dagger/assisted/Assisted\")\n  }\n}\n</code></pre> <p>For Dagger and KI specifically, there are convenience helper functions.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n    includeKotlinInject()\n    includeAnvil()\n  }\n}\n</code></pre> <p><code>@DependencyGraph</code> is replaceable but your mileage may vary if you use Anvil or modules, since Metro\u2019s annotation unifies Anvil\u2019s <code>@MergeComponent</code> functionality and doesn\u2019t support modules.</p> <p>Similarly, <code>@ContributesBinding</code> is replaceable but there are not direct analogues for Anvil\u2019s <code>@ContributesMultibinding</code> or kotlin-inject-anvil\u2019s <code>@ContributesBinding(multibinding = \u2026)</code> as these annotations are implemented as <code>@ContributesInto*</code> annotations in Metro.</p> <p><code>binding</code> in Metro uses a more flexible mechanism to support generics, but interop with Anvil\u2019s <code>boundType: KClass&lt;*&gt;</code> property is supported.</p>"},{"location":"interop/#components","title":"Components","text":"<p>Metro graphs can interop with components generated by Dagger and Kotlin-Inject. These work exclusively through their public accessors and can be depended on like any other graph dependency.</p> <pre><code>@DependencyGraph\ninterface MetroGraph {\n  val message: String\n\n  @DependencyGraph.Factory\n  fun interface Factory {\n    fun create(\n      @Includes daggerComponent: DaggerComponent\n    ): MetroGraph\n  }\n}\n\n@dagger.Component\ninterface DaggerComponent {\n  val message: String\n\n  @dagger.Component.Factory\n  fun interface Factory {\n    fun create(@Provides message: String): DaggerComponent\n  }\n}\n</code></pre> <p>Conversely, kotlin-inject and Dagger components can also depend on Metro graphs.</p> <pre><code>@DependencyGraph\ninterface MessageGraph {\n  val message: String\n\n  // ...\n}\n\n// Dagger\n@Component(dependencies = [MessageGraph::class])\ninterface DaggerComponent {\n  val message: String\n\n  @Component.Factory\n  fun interface Factory {\n    fun create(messageGraph: MessageGraph): DaggerComponent\n  }\n}\n\n// kotlin-inject\n@Component\nabstract class KotlinInjectComponent(\n  @Component val messageGraph: MessageGraph\n) {\n  abstract val message: String\n}\n</code></pre>"},{"location":"interop/#runtime","title":"Runtime","text":"<p>Enabling dagger interop also enables more advanced runtime interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code>/<code>Lazy</code> types.</p> <pre><code>metro {\n  interop {\n    includeDagger()\n  }\n}\n</code></pre> <p>This specifically enables two features.</p> <ol> <li>Interop with Dagger/Javax/Jakarta\u2019s <code>Provider</code> and <code>Lazy</code> runtime intrinsics.</li> <li>Interop with generated Dagger factories for constructor-injected and assisted-injected classes. This means that an upstream class that was processed with the dagger compiler and has a generated Java factory class for a constructor injected class can be reused by Metro natively.</li> </ol> <p>Note this also automatically adds an extra <code>interop-dagger</code> dependency to support this scenario.</p>"},{"location":"metro-intrinsics/","title":"Metro Intrinsics","text":"<p>Like Dagger, Metro supports injection of bindings wrapped in intrinsic types. Namely - <code>Provider</code> and <code>Lazy</code>. These are useful for deferring creation/initialization of dependencies. These only need to be requested at the injection site, Metro\u2019s code gen will generate all the necessary stitching to fulfill that request.</p>"},{"location":"metro-intrinsics/#provider","title":"<code>Provider</code>","text":"<p><code>Provider</code> is like Dagger\u2019s <code>Provider</code> \u2014 it is a simple interface who\u2019s <code>invoke()</code> call returns a new instance every time. If the underlying binding is scoped, then the same (scoped) instance is returned every time <code>invoke()</code> is called.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Provider&lt;Cache&gt;) {\n  fun createCache() {\n    val cache = cacheProvider()\n  }\n}\n</code></pre>"},{"location":"metro-intrinsics/#lazy","title":"<code>Lazy</code>","text":"<p><code>Lazy</code> is Kotlin\u2019s standard library <code>Lazy</code>. It lazily computes a value the first time it\u2019s evaluated and is thread-safe.</p> <pre><code>@Inject\nclass HttpClient(val cacheProvider: Lazy&lt;Cache&gt;) {\n  fun createCache() {\n    // The value is computed once and cached after\n    val cache = cacheProvider.value\n  }\n}\n</code></pre> <p>Note that <code>Lazy</code> is different from scoping in that it is confined to the scope of the injected type, rather than the component instance itself. There is functionally no difference between injecting a <code>Provider</code> or <code>Lazy</code> of a scoped binding. A <code>Lazy</code> of a scoped binding can still be useful to defer initialization. The underlying implementation in Metro\u2019s <code>DoubleCheck</code> prevents double memoization in this case.</p> <p>Why doesn\u2019t <code>Provider</code> just use a property like <code>Lazy</code>?</p> <p>A property is appropriate for <code>Lazy</code> because it fits the definition of being a computed value that is idempotent for repeat calls. Metro opts to make its <code>Provider</code> use an <code>invoke()</code> function because it does not abide by that contract.</p>"},{"location":"metro-intrinsics/#providers-of-lazy","title":"Providers of Lazy","text":"<p>Metro supports combining <code>Provider</code> and <code>Lazy</code> to inject <code>Provider&lt;Lazy&lt;T&gt;&gt;</code>. On unscoped bindings this means the provider will return a new deferrable computable value (i.e. a new Lazy). Meanwhile <code>Lazy&lt;Provider&lt;T&gt;&gt;</code> is meaningless and not supported.</p>"},{"location":"multiplatform/","title":"Multiplatform","text":"<p>Should Just Work\u2122\ufe0f! The runtime and code gen have been implemented to be entirely platform-agnostic so far.</p> <p>There is one issue in the repo right now where the compiler appears to have a bug with generated FIR declarations where it doesn\u2019t deserialize them correctly on non-JVM targets. Waiting for feedback from JB.</p> <p>When mixing contributions between common and platform-specific source sets, you must define your final <code>@DependencyGraph</code> in the platform-specific code. This is because a graph defined in commonMain wouldn\u2019t have full visibility of contributions from platform-specific types. A good pattern for this is to define your canonical graph in commonMain without a <code>@DependencyGraph</code> annotation and then a <code>{Platform}{Graph}</code> type in the platform source set that extends it and does have the <code>@DependencyGraph</code>. Metro automatically exposes bindings of the base graph type on the graph for any injections that need it.</p> <pre><code>// In commonMain\ninterface AppGraph {\n  val httpClient: HttpClient\n}\n\n// In jvmMain\n@DependencyGraph\ninterface JvmAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(Netty)\n}\n\n// In androidMain\n@DependencyGraph\ninterface AndroidAppGraph : AppGraph {\n  @Provides fun provideHttpClient(): HttpClient = HttpClient(OkHttp)\n}\n</code></pre>"},{"location":"performance/","title":"Performance","text":"<p>Metro strives to be a performant solution with minimal overhead at build-time and generating fast, efficient code at runtime. As build performance is the primary consideration for most developers considering this, most of this doc will be focused on that.</p>"},{"location":"performance/#build-performance","title":"Build Performance","text":"<p>Metro\u2019s compiler plugin is designed to be fast. Running as a compiler plugin allows it to: - Avoid generating new sources that need to be compiled - Avoid running KSP/KAPT - Generate IR that lowers directly into target platforms - Hook directly into kotlinc\u2019s IC APIs.</p> <p>In a straightforward migration, it improves ABI-changing build performance from 30-70%.</p>"},{"location":"performance/#benchmarking","title":"Benchmarking","text":"<p>To benchmark against Anvil-KSP, Dagger (KSP or KAPT), and Kotlin-Inject (+ Anvil), there is a benchmark directory with a generator script. There are more details in its README, but in short it generates a nontrivial multi-module project (default is 500 modules but is configurable) and benchmarks with gradle-profiler.</p> <p>Summary</p> <p>Results as of Metro <code>0.3.7</code>, Anvil-KSP <code>0.4.1</code>, Dagger <code>2.56.2</code>, and Kotlin-Inject <code>0.8.0</code> with kotlin-inject-anvil <code>0.1.6</code> are as follows.</p> <p>(Median times in seconds)</p> Metro Anvil KSP Anvil Kapt Kotlin-Inject ABI 5.3s 40.5s (+663%) 25.3s (+377%) 10.3s (+94%) Non-ABI 2.6s 3.8s (+45%) 7.1s (+171%) 3.3s (+26%) Graph processing 6.9s 28.9s (+318%) 8.7s (+25%) 11s (+59%)"},{"location":"performance/#modes","title":"Modes","text":"<ul> <li>Metro: Purely running metro</li> <li>Anvil KSP: Running dagger-ksp with anvil-ksp for contribution merging.</li> <li>Anvil KAPT: Running dagger with kapt with anvil-ksp for contribution merging.</li> <li>Kotlin Inject: Running kotlin-inject + kotlin-inject-anvil for contribution merging.</li> </ul>"},{"location":"performance/#abi-change","title":"ABI Change","text":"<p>This benchmark makes ABI-breaking source changes in a lower level module. This is where Metro shines the most.</p> <p></p>"},{"location":"performance/#non-abi-change","title":"Non-ABI Change","text":"<p>This benchmark makes non-ABI-breaking source changes in a lower level module. The differences are less significant here as KSP is quite good at compilation avoidance now too. The outlier here is KAPT, which still has to run stub gen + apt and cannot fully avoid it.</p> <p></p>"},{"location":"performance/#raw-graphcomponent-processing","title":"Raw Graph/Component Processing","text":"<p>This benchmark reruns the top-level merging graph/component where all the downstream contributions are merged. This also builds the full dependency graph and any contributed graph extensions/subcomponents.</p> <p>Metro again shines here. Dagger-KSP seems to have a bottleneck that disproportionately affects it here too.</p> <p></p>"},{"location":"performance/#real-world-results","title":"Real-World Results","text":"<p>Below are some results from real-world projects, shared with the developers\u2019 permission.</p> <p>Gabriel Ittner from Freeletics</p> <p>I\u2019ve got Metro working on our code base now using the Kotlin 2.2.0 preview</p> <p>Background numbers</p> <ul> <li>551 modules total</li> <li>105 modules using Anvil KSP \u27a1\ufe0f migrated to pure Metro</li> <li>154 modules using Anvil KSP + other KSP processor \u27a1\ufe0f Metro + other KSP processor</li> <li>1 module using Dagger KAPT \u27a1\ufe0f migrated to pure Metro</li> </ul> <p>Build performance</p> <ul> <li>Clean builds without build cache are 12 percentage points faster</li> <li>Any app module change ~50% faster (this is the one place that had kapt and it\u2019s mostly empty other than generating graphs/components)</li> <li>ABI changes in other modules ~ 40% - 55% faster</li> <li>non ABI changes in other modules unchanged or minimally faster</li> </ul> <p>Madis Pink from emulator.wtf</p> <p>I got our monorepo migrated over from anvil, it sliced off one third of our Gradle tasks and <code>./gradlew classes</code> from clean is ~4x faster</p> <p>Kevin Chiu from BandLab</p> <p>We migrated our main project at BandLab to metro, finally!</p> <p>Some context about our project:</p> <ul> <li>We use Dagger + Anvil KSP</li> <li>929 modules, 89 of them are running Dagger compiler (KAPT) to process components</li> <li>7 KSP processors</li> </ul> Build Dagger + Anvil KSP Metro (\u0394) UiKit ABI change (Incremental) 59.7 s 26.9 s (55% faster) Root ABI change (Incremental) 95.7 s 48.1 s (49.8% faster) Root non-ABI change (Incremental) 70.9 s 38.9 s (45.2% faster) Clean build 327 s 288 s (11.7% faster)"},{"location":"performance/#reporting","title":"Reporting","text":"<p>If you want to investigate the performance of different stages of Metro\u2019s compiler pipeline, you can enable reporting in the Gradle DSL.</p> <pre><code>metro {\n  reportsDestination.set(layout.buildDirectory.dir(\"metro/reports\"))\n}\n</code></pre> <p>Among the reports written there, there will also be a trace log that dumps a simple trace of the different stages.</p> <pre><code>[ExampleGraph] \u25b6 Transform dependency graph\n  \u25b6 Build DependencyGraphNode\n  \u25c0 Build DependencyGraphNode (xx ms)\n  \u25b6 Implement creator functions\n  \u25c0 Implement creator functions (xx ms)\n  \u25b6 Build binding graph\n  \u25c0 Build binding graph (xx ms)\n  \u25b6 Validate binding graph\n    \u25b6 Check self-cycles\n    \u25c0 Check self-cycles (xx ms)\n    \u25b6 Validate graph\n      \u25b6 seal graph\n        \u25b6 Populate bindings\n        \u25c0 Populate bindings (xx ms)\n        \u25b6 Build adjacency list\n        \u25c0 Build adjacency list (xx ms)\n        \u25b6 Sort and validate\n          \u25b6 Topo sort\n            \u25b6 Compute SCCs\n            \u25c0 Compute SCCs (xx ms)\n            \u25b6 Check for cycles\n            \u25c0 Check for cycles (xx ms)\n            \u25b6 Build component DAG\n            \u25c0 Build component DAG (xx ms)\n            \u25b6 Topo sort component DAG\n            \u25c0 Topo sort component DAG (xx ms)\n            \u25b6 Expand components\n            \u25c0 Expand components (xx ms)\n          \u25c0 Topo sort (xx ms)\n        \u25c0 Sort and validate (xx ms)\n        \u25b6 Compute binding indices\n        \u25c0 Compute binding indices (xx ms)\n      \u25c0 seal graph (xx ms)\n      \u25b6 check empty multibindings\n      \u25c0 check empty multibindings (xx ms)\n      \u25b6 check for absent bindings\n      \u25c0 check for absent bindings (xx ms)\n    \u25c0 Validate graph (xx ms)\n  \u25c0 Validate binding graph (xx ms)\n  \u25b6 Transform metro graph\n    \u25b6 Collect bindings\n    \u25c0 Collect bindings (xx ms)\n    \u25b6 Implement overrides\n    \u25c0 Implement overrides (xx ms)\n  \u25c0 Transform metro graph (xx ms)\n[ExampleGraph] \u25c0 Transform dependency graph (xx ms)\n</code></pre>"},{"location":"performance/#runtime-performance","title":"Runtime Performance","text":"<p>Metro\u2019s compiler generates Dagger-style factory classes for every injection site.</p> <p>The same factory classes are reused across modules and downstream builds, so there\u2019s no duplicated glue code or runtime discovery cost.</p> <p>Because the full dependency graph is wired at compile-time, each binding is accessed through a direct field reference in the generated code. No reflection, no hashmap lookups, no runtime service locator hops, etc.</p>"},{"location":"provides/","title":"<code>@Provides</code>","text":"<p>Providers can be defined in graphs or supertypes that graphs extend. Defining them in supertypes allows for them to be reused across multiple graphs and organize providers into logic groups. This is similar to how modules in Dagger work.</p> <pre><code>interface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface AppGraph : NetworkProviders\n</code></pre> <p>Provider functions should be <code>private</code> by default and are automatically transformed to be private by the Metro compiler. This means you can write a provider function with no explicit (or public) visibility and it will be made private by Metro at compile-time.</p> <p>Provider properties cannot be private yet due to KT-76257, but may be supported in the future.</p> <p>Providers may also be declared in binding Containers.</p> <p>Tip</p> <p>It\u2019s recommended to not call providers from each other.</p>"},{"location":"provides/#overrides","title":"Overrides","text":"<p>It is an error to override providers declarations. While it can be enticing for testing reasons to try to replicate Dagger 1\u2019s module overrides, it quickly becomes difficult to reason about in code gen.</p> <ul> <li>What if you override with sub/supertypes?</li> <li>What if your override\u2019s implementation needs different dependencies?</li> </ul> <p>To the testing end, it is recommended to instead leverage the <code>DependencyGraph.excludes</code> + <code>ContributesTo.replaces</code> APIs in merging.</p> <pre><code>// Don't do this pattern!\ninterface NetworkProviders {\n  @Provides\n  fun provideHttpClient(): HttpClient = HttpClient()\n}\n\n@DependencyGraph\ninterface TestAppGraph : NetworkProviders {\n  // This will fail to compile\n  override fun provideHttpClient(): HttpClient = TestHttpClient()\n}\n</code></pre>"},{"location":"provides/#companion-providers","title":"Companion Providers","text":"<p>Providers can alternatively be implemented in <code>companion object</code>s for staticization.</p> <pre><code>interface MessageGraph {\n  val message: String\n  companion object {\n    @Provides\n    private fun provideMessage(): String = \"Hello, world!\"\n  }\n}\n</code></pre>"},{"location":"provides/#implementation-notes","title":"Implementation Notes","text":"<p>private interface functions are not usually visible to downstream compilations in IR. To work around this, Metro will use a new API in Kotlin 2.1.20 to add custom metadata to the parent class to denote these private providers\u2019 existence and where to find them.</p>"},{"location":"samples/","title":"Metro Samples","text":"<p>The samples directory contains various sample projects demonstrating different use cases and integrations for Metro.</p>"},{"location":"samples/#android-app","title":"android-app","text":"<p>A simple Android sample app that demonstrates using Metro to constructor-inject Android framework components like <code>Activity</code>, <code>Fragment</code>, and <code>ViewModel</code> with multibindings.</p>"},{"location":"samples/#circuit-app","title":"circuit-app","text":"<p>A multiplatform sample that demonstrates using Metro with Circuit and Jetpack Compose.</p>"},{"location":"samples/#interop","title":"interop","text":"<p>Various demonstrating interop between Metro and other dependency injection frameworks.</p>"},{"location":"samples/#multi-module-test","title":"multi-module-test","text":"<p>A sample + integration test demonstrating Metro in a multi-module project structure with.</p> <p>This sample shows how Metro handles dependencies across module boundaries and component hierarchies.</p>"},{"location":"samples/#weather-app","title":"weather-app","text":"<p>A simple command-line weather app that demonstrates basic Metro usage.</p>"},{"location":"scopes/","title":"Scopes","text":"<p>Like Dagger and KI, Metro supports scopes to limit instances of types on the dependency graph. A scope is any annotation annotated with <code>@Scope</code>, with a convenience <code>@SingleIn</code> scope available in Metro\u2019s runtime.</p> <p>Scopes must be applied to either the injected class or the provider function providing that binding. They must also match the graph that they are used in.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\nabstract class AppGraph {\n  private var counter = 0\n\n  abstract val count: Int\n\n  @SingleIn(AppScope::class) @Provides fun provideCount() = counter++\n}\n</code></pre> <p>In the above example, multiple calls to <code>AppGraph.count</code> will always return 0 because the returned value from <code>provideCount()</code> will be cached in the <code>AppGraph</code> instance the first time it\u2019s called.</p> <p>It is an error for an unscoped graph to access scoped bindings.</p> <pre><code>@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>It is also an error for a scoped graph to access scoped bindings whose scope does not match.</p> <pre><code>@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is an error!\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(UserScope::class)\n@Inject\nclass ExampleClass\n</code></pre> <p>Like Dagger, graphs can have multiple scopes that they support.</p> <pre><code>@Scope annotation class Singleton\n\n@Singleton\n@SingleIn(AppScope::class)\n@DependencyGraph\ninterface AppGraph {\n  // This is ok\n  val exampleClass: ExampleClass\n}\n\n@SingleIn(AppScope::class)\n@Inject\nclass ExampleClass\n</code></pre>"},{"location":"validation-and-error-reporting/","title":"Validation &amp; Error Reporting","text":"<p>Common programmer/usage errors are implemented in FIR. This should allow errors to appear directly in the IDE, offering the best and fastest feedback loop for developers writing their code.</p> <p>TODO IDE screenshot example</p> <p>Dependency graph validation is performed at the per-graph level. Metro seeks to report binding validation errors at least on par with Dagger, if not better.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/DependencyCycle] Found a dependency cycle:\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n    kotlin.String is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideDouble(..., string)\n    kotlin.Double is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideInt(..., double)\n    kotlin.Int is injected at\n        [test.ExampleGraph] test.ExampleGraph.provideString(..., int)\n</code></pre> <p>Binding errors take learnings from Dagger and report fully qualified references that IDEs like IntelliJ can usually autolink.</p> <pre><code>ExampleGraph.kt:6:1 [Metro/GraphDependencyCycle] Dependency graph dependency cycle detected! The below graph depends on itself.\n    test.CharSequenceGraph is requested at\n        [test.CharSequenceGraph] test.CharSequenceGraph.Factory.create()\n</code></pre> <p>Note that binding graph resolution currently only happens in the compiler IR backend, but maybe someday we can move this to FIR to get errors in the IDE.</p>"}]}