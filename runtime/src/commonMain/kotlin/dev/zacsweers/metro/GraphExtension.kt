// Copyright (C) 2025 Zac Sweers
// SPDX-License-Identifier: Apache-2.0
package dev.zacsweers.metro

import kotlin.reflect.KClass

/**
 * Declares the annotated type to be a dependency graph _extension_. As the name implies, graph
 * extensions _extend_ a parent graph they are declared for and contain a superset of bindings that
 * includes both the parent graph(s) as well as their own. These are similar in functionality to
 * Dagger’s Subcomponent
 *
 * _See [DependencyGraph] before reading this section!_
 *
 * Graph extensions must be either an interface or an abstract class.
 *
 * Metro's compiler plugin will build, validate, and implement this graph at compile-time _when the
 * parent graph is generated_.
 *
 * Graph extensions can be chained and implicitly inherit their parents’ scopes.
 *
 * ## Creating Graphs
 *
 * You cannot create a graph extension independent of its parent graph, you may only access it via
 * accessor on the parent graph. You can declare this in multiple ways.
 * * Declare an accessor on the parent graph directly.
 *
 * ```kotlin
 * @GraphExtension
 * interface LoggedInGraph
 *
 * @DependencyGraph
 * interface AppGraph {
 *   val loggedInGraph: LoggedInGraph
 * }
 * ```
 * * (If the extension has a creator) declare the creator on the parent graph directly.
 *
 * ```kotlin
 * @GraphExtension
 * interface LoggedInGraph {
 *   @GraphExtension.Factory
 *   interface Factory {
 *     fun createLoggedInGraph(): LoggedInGraph
 *   }
 * }
 *
 * @DependencyGraph
 * interface AppGraph {
 *   val loggedInGraphFactory: LoggedInGraph.Factory
 * }
 * ```
 * * (If the extension has a creator) make the parent graph implement the creator.
 *
 * ```kotlin
 * @GraphExtension
 * interface LoggedInGraph {
 *   @GraphExtension.Factory
 *   interface Factory {
 *     fun createLoggedInGraph(): LoggedInGraph
 *   }
 * }
 *
 * @DependencyGraph
 * interface AppGraph : LoggedInGraph.Factory
 * ```
 * * Contribute the factory to the parent graph via [ContributesGraphExtension].
 *
 * ```kotlin
 * @GraphExtension
 * interface LoggedInGraph {
 *   @ContributesGraphExtension.Factory(AppScope::class)
 *   interface Factory {
 *     fun createLoggedInGraph(): LoggedInGraph
 *   }
 * }
 *
 * @DependencyGraph(AppScope::class)
 * interface AppGraph
 * ```
 *
 * ## Scoping
 *
 * _See [Scope] and [DependencyGraph] before reading this section!_
 *
 * Like [DependencyGraph], graph extensions may declare a [scope] (and optionally [additionalScopes]
 * if there are more). Each of these declared scopes act as an implicit [SingleIn] representation of
 * that scope. For example:
 * ```
 * @GraphExtension(AppScope::class)
 * interface AppGraph
 * ```
 *
 * Is functionally equivalent to writing the below.
 *
 * ```
 * @SingleIn(AppScope::class)
 * @GraphExtension(AppScope::class)
 * interface AppGraph
 * ```
 *
 * ## Providers
 *
 * Like [DependencyGraph], graph extensions may declare providers via [Provides] and [Binds] to
 * provide dependencies into the graph.
 *
 * _Creators_ can provide instance dependencies and other graphs as dependencies.
 *
 * ```
 * @GraphExtension
 * interface AppGraph {
 *   val httpClient: HttpClient
 *
 *   @Provides fun provideHttpClient: HttpClient = HttpClient()
 * }
 * ```
 *
 * ## Creators
 *
 * See [DependencyGraph]'s section on creators.
 *
 * ## Aggregation
 *
 * See [DependencyGraph]'s section on aggregation.
 *
 * @property excludes Optional list of excluded contributing classes (requires a [scope] to be
 *   defined).
 * @property bindingContainers Optional list of included binding containers. See the doc on
 *   [BindingContainer] for more details.
 */
@Target(AnnotationTarget.CLASS)
public annotation class GraphExtension(
  val scope: KClass<*> = Nothing::class,
  val additionalScopes: Array<KClass<*>> = [],
  val excludes: Array<KClass<*>> = [],
  val bindingContainers: Array<KClass<*>> = [],
) {
  /**
   * Graph extension factories work the same as [DependencyGraph.Factory] except they do not support
   * standalone graph factory generation (since they are generated by the parent graphs.)
   */
  @Target(AnnotationTarget.CLASS) public annotation class Factory
}
