# Metro Benchmark Project

This is a large-scale benchmark project for testing Metro's performance. It contains 500 modules organized in a
realistic architecture with extensive use of `@ContributesBinding` and `@ContributesMultibinding` annotations.

## Architecture

The project is organized into three layers:

- **Core layer** (80 modules): Fundamental utilities, data models, networking, platform abstractions
- **Features layer** (350 modules): Business logic features like auth, user management, content, social, commerce,
  analytics
- **App layer** (70 modules): UI components, navigation, integration glue, and dependency wiring

## Module Structure

Each module contributes 1-10 bindings using:

- `@ContributesBinding` for interface implementations
- `@ContributesMultibinding` for plugin-style extensions and initializers
- Realistic inter-module dependencies following the layered architecture
- 5 subcomponents for hierarchical scoping

## Generation

The entire project is generated by the `generate-projects.main.kts` script, which can be re-run to regenerate modules
with different parameters. This makes it easy to experiment with different scales and configurations.

## Usage

```bash
# Generate the project
kotlin generate-projects.main.kts

# Build the entire benchmark
./gradlew build

# Run the app component (creates the full dependency graph)
./gradlew :app:component:run
```

## Interop

The benchmark uses:

- `javax.inject` annotations for dependency injection
- `dev.zacsweers.anvil:annotations` (anvil-ksp fork) for contribution annotations
- Metro's interop system to bridge Anvil annotations to Metro's code generation

This tests Metro's ability to work with existing Anvil codebases and validates the interop functionality at scale.

## Statistics

- **500 total modules**
- **~2,760 total contributions** (varies due to randomization)
- **5 subcomponents** for hierarchical dependency injection
- **Realistic dependency graph** following architectural best practices

This benchmark provides a comprehensive test of Metro's compilation performance, memory usage, and incremental
compilation behavior on a large, realistic codebase.
