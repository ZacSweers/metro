# Metro Benchmark Project

This is a large-scale benchmark project for testing Metro's performance. It contains a configurable number of modules
(default: 500) organized in a realistic architecture with extensive use of `@ContributesBinding` and `@ContributesMultibinding` annotations.

## Architecture

The project is organized into three layers:

- **Core layer** (~16% of total): Fundamental utilities, data models, networking, platform abstractions
- **Features layer** (~70% of total): Business logic features like auth, user management, content, social, commerce,
  analytics
- **App layer** (~14% of total): UI components, navigation, integration glue, and dependency wiring

## Module Structure

Each module contributes 1-10 bindings using:

- `@ContributesBinding` for interface implementations
- `@ContributesMultibinding` for plugin-style extensions and initializers
- Realistic inter-module dependencies following the layered architecture
- 5 subcomponents for hierarchical scoping

## Generation

The entire project is generated by the `generate-projects.main.kts` script, which can be re-run to regenerate modules
with different parameters. This makes it easy to experiment with different scales and configurations.

The script supports two modes and configurable module counts:
- **Metro mode** (`--mode metro`): Uses Metro for dependency injection with metro interop
- **Anvil mode** (`--mode anvil`): Uses pure Anvil-KSP for dependency injection
- **Module count** (`--count <number>`): Total number of modules to generate (default: 500)

## Usage

```bash
# Generate the project for Metro mode with default 500 modules
kotlin generate-projects.main.kts --mode metro

# Generate the project for Anvil mode with default 500 modules
kotlin generate-projects.main.kts --mode anvil

# Generate a larger project with 1000 modules
kotlin generate-projects.main.kts --mode metro --count 1000

# Generate a smaller project for quick testing
kotlin generate-projects.main.kts --mode anvil --count 100

# Generate a project using kapt for dagger-compiler
kotlin generate-projects.main.kts --mode anvil --processor kapt

# Build the entire benchmark
./gradlew build

# Run the app component (creates the full dependency graph)
./gradlew :app:component:run
```

## Modes

### Metro Mode
- Uses `dev.zacsweers.metro` plugin
- Uses `dev.zacsweers.anvil:annotations` with Metro interop
- Supports `AppScope` and `@SingleIn` scoping
- Generates `createGraph<AppComponent>()` for runtime execution

### Anvil Mode
- Uses `dev.zacsweers.anvil:compiler` with KSP
- Uses `dagger.runtime` for dependency injection
- Uses standard `com.squareup.anvil.annotations` (via anvil-ksp fork)
- Uses `@Singleton` and `Unit::class` scope
- Generates Dagger components with `DaggerAppComponent.factory().create()`

## Interop

The benchmark uses:

- `javax.inject` annotations for dependency injection
- `dev.zacsweers.anvil:annotations` (anvil-ksp fork) for contribution annotations
- Metro's interop system to bridge Anvil annotations to Metro's code generation

This tests Metro's ability to work with existing Anvil codebases and validates the interop functionality at scale.

## Statistics

- **Configurable module count** (default: 500, can scale from 100 to 1000+)
- **~5.5 contributions per module** (varies due to randomization, 1-10 range)
- **Proportional subcomponents** (~10% of app layer modules)
- **Realistic dependency graph** following architectural best practices

The benchmark scales proportionally with the module count:
- 100 modules: ~500 contributions, 1 subcomponent
- 500 modules: ~2,750 contributions, 7 subcomponents
- 1000 modules: ~5,400 contributions, 14 subcomponents

This provides comprehensive testing of Metro's compilation performance, memory usage, and incremental
compilation behavior across different project scales.
